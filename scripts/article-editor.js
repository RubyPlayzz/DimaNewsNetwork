var vf = Array.isArray, Xy = Array.prototype.indexOf, Sf = Array.from, zy = Object.defineProperty, or = Object.getOwnPropertyDescriptor, lm = Object.getOwnPropertyDescriptors, Dy = Object.prototype, Ly = Array.prototype, wf = Object.getPrototypeOf, Gu = Object.isExtensible;
function Iy(i) {
  return typeof i == "function";
}
const zi = () => {
};
function By(i) {
  return i();
}
function nh(i) {
  for (var e = 0; e < i.length; e++)
    i[e]();
}
function xf() {
  var i, e, t = new Promise((n, r) => {
    i = n, e = r;
  });
  return { promise: t, resolve: i, reject: e };
}
const _t = 2, bl = 4, yl = 8, en = 16, Qn = 32, vr = 64, vl = 128, wi = 512, mt = 1024, ni = 2048, tn = 4096, ii = 8192, Zn = 16384, Sl = 32768, Ln = 65536, Fu = 1 << 17, cm = 1 << 18, hs = 1 << 19, hm = 1 << 20, eo = 32768, rh = 1 << 21, kf = 1 << 22, Xn = 1 << 23, ar = Symbol("$state"), Yy = Symbol("legacy props"), Ny = Symbol(""), Mr = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
function Qf(i) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function Vy() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function qy(i) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function Wy() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function jy(i) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function Uy() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function Gy(i) {
  throw new Error("https://svelte.dev/e/props_invalid_value");
}
function Fy() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function Hy() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function Ky() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function Jy() {
  throw new Error("https://svelte.dev/e/svelte_boundary_reset_onerror");
}
const wl = 1, xl = 2, fm = 4, ev = 8, tv = 16, iv = 1, nv = 2, rv = 4, sv = 8, ov = 16, av = 4, lv = 1, cv = 2, St = Symbol(), hv = "http://www.w3.org/1999/xhtml";
function fv() {
  console.warn("https://svelte.dev/e/svelte_boundary_reset_noop");
}
let uv = !1;
function um(i) {
  return i === this.v;
}
function _f(i, e) {
  return i != i ? e == e : i !== e || i !== null && typeof i == "object" || typeof i == "function";
}
function dm(i) {
  return !_f(i, this.v);
}
let fs = !1;
function dv() {
  fs = !0;
}
let je = null;
function Wr(i) {
  je = i;
}
function us(i, e = !1, t) {
  je = {
    p: je,
    i: !1,
    c: null,
    e: null,
    s: i,
    x: null,
    l: fs && !e ? { s: null, u: null, $: [] } : null
  };
}
function ds(i) {
  var e = (
    /** @type {ComponentContext} */
    je
  ), t = e.e;
  if (t !== null) {
    e.e = null;
    for (var n of t)
      Am(n);
  }
  return i !== void 0 && (e.x = i), e.i = !0, je = e.p, i ?? /** @type {T} */
  {};
}
function ko() {
  return !fs || je !== null && je.l === null;
}
let nr = [];
function pm() {
  var i = nr;
  nr = [], nh(i);
}
function Sr(i) {
  if (nr.length === 0 && !qs) {
    var e = nr;
    queueMicrotask(() => {
      e === nr && pm();
    });
  }
  nr.push(i);
}
function pv() {
  for (; nr.length > 0; )
    pm();
}
function Om(i) {
  var e = Ae;
  if (e === null)
    return Ce.f |= Xn, i;
  if ((e.f & Sl) === 0) {
    if ((e.f & vl) === 0)
      throw i;
    e.b.error(i);
  } else
    jr(i, e);
}
function jr(i, e) {
  for (; e !== null; ) {
    if ((e.f & vl) !== 0)
      try {
        e.b.error(i);
        return;
      } catch (t) {
        i = t;
      }
    e = e.parent;
  }
  throw i;
}
const zo = /* @__PURE__ */ new Set();
let Ne = null, ba = null, ei = null, Di = [], kl = null, sh = !1, qs = !1;
class Ni {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #e = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #t = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #n = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #i = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #l = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Effect[]}
   */
  #s = [];
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Effect[]}
   */
  #o = [];
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed â€” we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(e) {
    Di = [], ba = null, this.apply();
    var t = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    for (const n of e)
      this.#r(n, t);
    this.is_fork || this.#c(), this.#i > 0 || this.is_fork ? (this.#a(t.effects), this.#a(t.render_effects), this.#a(t.block_effects)) : (ba = this, Ne = null, Hu(t.render_effects), Hu(t.effects), ba = null, this.#l?.resolve()), ei = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #r(e, t) {
    e.f ^= mt;
    for (var n = e.first; n !== null; ) {
      var r = n.f, s = (r & (Qn | vr)) !== 0, o = s && (r & mt) !== 0, a = o || (r & ii) !== 0 || this.skipped_effects.has(n);
      if ((n.f & vl) !== 0 && n.b?.is_pending() && (t = {
        parent: t,
        effect: n,
        effects: [],
        render_effects: [],
        block_effects: []
      }), !a && n.fn !== null) {
        s ? n.f ^= mt : (r & bl) !== 0 ? t.effects.push(n) : Os(n) && ((n.f & en) !== 0 && t.block_effects.push(n), Fr(n));
        var l = n.first;
        if (l !== null) {
          n = l;
          continue;
        }
      }
      var c = n.parent;
      for (n = n.next; n === null && c !== null; )
        c === t.effect && (this.#a(t.effects), this.#a(t.render_effects), this.#a(t.block_effects), t = /** @type {EffectTarget} */
        t.parent), n = c.next, c = c.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #a(e) {
    for (const t of e)
      ((t.f & ni) !== 0 ? this.#s : this.#o).push(t), bt(t, mt);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(e, t) {
    this.previous.has(e) || this.previous.set(e, t), (e.f & Xn) === 0 && (this.current.set(e, e.v), ei?.set(e, e.v));
  }
  activate() {
    Ne = this, this.apply();
  }
  deactivate() {
    Ne = null, ei = null;
  }
  flush() {
    if (this.activate(), Di.length > 0) {
      if (mm(), Ne !== null && Ne !== this)
        return;
    } else this.#n === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const e of this.#t) e(this);
    this.#t.clear();
  }
  #c() {
    if (this.#i === 0) {
      for (const e of this.#e) e();
      this.#e.clear();
    }
    this.#n === 0 && this.#h();
  }
  #h() {
    if (zo.size > 1) {
      this.previous.clear();
      var e = ei, t = !0, n = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: [],
        block_effects: []
      };
      for (const r of zo) {
        if (r === this) {
          t = !1;
          continue;
        }
        const s = [];
        for (const [a, l] of this.current) {
          if (r.current.has(a))
            if (t && l !== r.current.get(a))
              r.current.set(a, l);
            else
              continue;
          s.push(a);
        }
        if (s.length === 0)
          continue;
        const o = [...r.current.keys()].filter((a) => !this.current.has(a));
        if (o.length > 0) {
          const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const c of s)
            gm(c, o, a, l);
          if (Di.length > 0) {
            Ne = r, r.apply();
            for (const c of Di)
              r.#r(c, n);
            Di = [], r.deactivate();
          }
        }
      }
      Ne = null, ei = e;
    }
    this.committed = !0, zo.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(e) {
    this.#n += 1, e && (this.#i += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(e) {
    this.#n -= 1, e && (this.#i -= 1), this.revive();
  }
  revive() {
    for (const e of this.#s)
      bt(e, ni), dr(e);
    for (const e of this.#o)
      bt(e, tn), dr(e);
    this.#s = [], this.#o = [], this.flush();
  }
  /** @param {() => void} fn */
  oncommit(e) {
    this.#e.add(e);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(e) {
    this.#t.add(e);
  }
  settled() {
    return (this.#l ??= xf()).promise;
  }
  static ensure() {
    if (Ne === null) {
      const e = Ne = new Ni();
      zo.add(Ne), qs || Ni.enqueue(() => {
        Ne === e && e.flush();
      });
    }
    return Ne;
  }
  /** @param {() => void} task */
  static enqueue(e) {
    Sr(e);
  }
  apply() {
  }
}
function Ov(i) {
  var e = qs;
  qs = !0;
  try {
    for (var t; ; ) {
      if (pv(), Di.length === 0 && (Ne?.flush(), Di.length === 0))
        return kl = null, /** @type {T} */
        t;
      mm();
    }
  } finally {
    qs = e;
  }
}
function mm() {
  var i = cr;
  sh = !0;
  try {
    var e = 0;
    for (td(!0); Di.length > 0; ) {
      var t = Ni.ensure();
      if (e++ > 1e3) {
        var n, r;
        mv();
      }
      t.process(Di), zn.clear();
    }
  } finally {
    sh = !1, td(i), kl = null;
  }
}
function mv() {
  try {
    Uy();
  } catch (i) {
    jr(i, kl);
  }
}
let un = null;
function Hu(i) {
  var e = i.length;
  if (e !== 0) {
    for (var t = 0; t < e; ) {
      var n = i[t++];
      if ((n.f & (Zn | ii)) === 0 && Os(n) && (un = /* @__PURE__ */ new Set(), Fr(n), n.deps === null && n.first === null && n.nodes_start === null && (n.teardown === null && n.ac === null ? Zm(n) : n.fn = null), un?.size > 0)) {
        zn.clear();
        for (const r of un) {
          if ((r.f & (Zn | ii)) !== 0) continue;
          const s = [r];
          let o = r.parent;
          for (; o !== null; )
            un.has(o) && (un.delete(o), s.push(o)), o = o.parent;
          for (let a = s.length - 1; a >= 0; a--) {
            const l = s[a];
            (l.f & (Zn | ii)) === 0 && Fr(l);
          }
        }
        un.clear();
      }
    }
    un = null;
  }
}
function gm(i, e, t, n) {
  if (!t.has(i) && (t.add(i), i.reactions !== null))
    for (const r of i.reactions) {
      const s = r.f;
      (s & _t) !== 0 ? gm(
        /** @type {Derived} */
        r,
        e,
        t,
        n
      ) : (s & (kf | en)) !== 0 && (s & ni) === 0 && // we may have scheduled this one already
      bm(r, e, n) && (bt(r, ni), dr(
        /** @type {Effect} */
        r
      ));
    }
}
function bm(i, e, t) {
  const n = t.get(i);
  if (n !== void 0) return n;
  if (i.deps !== null)
    for (const r of i.deps) {
      if (e.includes(r))
        return !0;
      if ((r.f & _t) !== 0 && bm(
        /** @type {Derived} */
        r,
        e,
        t
      ))
        return t.set(
          /** @type {Derived} */
          r,
          !0
        ), !0;
    }
  return t.set(i, !1), !1;
}
function dr(i) {
  for (var e = kl = i; e.parent !== null; ) {
    e = e.parent;
    var t = e.f;
    if (sh && e === Ae && (t & en) !== 0 && (t & cm) === 0)
      return;
    if ((t & (vr | Qn)) !== 0) {
      if ((t & mt) === 0) return;
      e.f ^= mt;
    }
  }
  Di.push(e);
}
function gv(i) {
  let e = 0, t = pr(0), n;
  return () => {
    Ql() && (te(t), qn(() => (e === 0 && (n = rn(() => i(() => Ws(t)))), e += 1, () => {
      Sr(() => {
        e -= 1, e === 0 && (n?.(), n = void 0, Ws(t));
      });
    })));
  };
}
var bv = Ln | hs | vl;
function yv(i, e, t) {
  new vv(i, e, t);
}
class vv {
  /** @type {Boundary | null} */
  parent;
  #e = !1;
  /** @type {TemplateNode} */
  #t;
  /** @type {TemplateNode | null} */
  #n = null;
  /** @type {BoundaryProps} */
  #i;
  /** @type {((anchor: Node) => void)} */
  #l;
  /** @type {Effect} */
  #s;
  /** @type {Effect | null} */
  #o = null;
  /** @type {Effect | null} */
  #r = null;
  /** @type {Effect | null} */
  #a = null;
  /** @type {DocumentFragment | null} */
  #c = null;
  /** @type {TemplateNode | null} */
  #h = null;
  #f = 0;
  #u = 0;
  #p = !1;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #d = null;
  #y = gv(() => (this.#d = pr(this.#f), () => {
    this.#d = null;
  }));
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(e, t, n) {
    this.#t = e, this.#i = t, this.#l = n, this.parent = /** @type {Effect} */
    Ae.b, this.#e = !!this.#i.pending, this.#s = _l(() => {
      Ae.b = this;
      {
        var r = this.#g();
        try {
          this.#o = yi(() => n(r));
        } catch (s) {
          this.error(s);
        }
        this.#u > 0 ? this.#m() : this.#e = !1;
      }
      return () => {
        this.#h?.remove();
      };
    }, bv);
  }
  #v() {
    try {
      this.#o = yi(() => this.#l(this.#t));
    } catch (e) {
      this.error(e);
    }
    this.#e = !1;
  }
  #S() {
    const e = this.#i.pending;
    e && (this.#r = yi(() => e(this.#t)), Ni.enqueue(() => {
      var t = this.#g();
      this.#o = this.#O(() => (Ni.ensure(), yi(() => this.#l(t)))), this.#u > 0 ? this.#m() : (Lr(
        /** @type {Effect} */
        this.#r,
        () => {
          this.#r = null;
        }
      ), this.#e = !1);
    }));
  }
  #g() {
    var e = this.#t;
    return this.#e && (this.#h = Gr(), this.#t.before(this.#h), e = this.#h), e;
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#e || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#i.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #O(e) {
    var t = Ae, n = Ce, r = je;
    Ki(this.#s), Vt(this.#s), Wr(this.#s.ctx);
    try {
      return e();
    } catch (s) {
      return Om(s), null;
    } finally {
      Ki(t), Vt(n), Wr(r);
    }
  }
  #m() {
    const e = (
      /** @type {(anchor: Node) => void} */
      this.#i.pending
    );
    this.#o !== null && (this.#c = document.createDocumentFragment(), this.#c.append(
      /** @type {TemplateNode} */
      this.#h
    ), Dm(this.#o, this.#c)), this.#r === null && (this.#r = yi(() => e(this.#t)));
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #b(e) {
    if (!this.has_pending_snippet()) {
      this.parent && this.parent.#b(e);
      return;
    }
    this.#u += e, this.#u === 0 && (this.#e = !1, this.#r && Lr(this.#r, () => {
      this.#r = null;
    }), this.#c && (this.#t.before(this.#c), this.#c = null));
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(e) {
    this.#b(e), this.#f += e, this.#d && Ur(this.#d, this.#f);
  }
  get_effect_pending() {
    return this.#y(), te(
      /** @type {Source<number>} */
      this.#d
    );
  }
  /** @param {unknown} error */
  error(e) {
    var t = this.#i.onerror;
    let n = this.#i.failed;
    if (this.#p || !t && !n)
      throw e;
    this.#o && (Et(this.#o), this.#o = null), this.#r && (Et(this.#r), this.#r = null), this.#a && (Et(this.#a), this.#a = null);
    var r = !1, s = !1;
    const o = () => {
      if (r) {
        fv();
        return;
      }
      r = !0, s && Jy(), Ni.ensure(), this.#f = 0, this.#a !== null && Lr(this.#a, () => {
        this.#a = null;
      }), this.#e = this.has_pending_snippet(), this.#o = this.#O(() => (this.#p = !1, yi(() => this.#l(this.#t)))), this.#u > 0 ? this.#m() : this.#e = !1;
    };
    var a = Ce;
    try {
      Vt(null), s = !0, t?.(e, o), s = !1;
    } catch (l) {
      jr(l, this.#s && this.#s.parent);
    } finally {
      Vt(a);
    }
    n && Sr(() => {
      this.#a = this.#O(() => {
        Ni.ensure(), this.#p = !0;
        try {
          return yi(() => {
            n(
              this.#t,
              () => e,
              () => o
            );
          });
        } catch (l) {
          return jr(
            l,
            /** @type {Effect} */
            this.#s.parent
          ), null;
        } finally {
          this.#p = !1;
        }
      });
    });
  }
}
function Sv(i, e, t, n) {
  const r = ko() ? Qo : Pf;
  if (t.length === 0 && i.length === 0) {
    n(e.map(r));
    return;
  }
  var s = Ne, o = (
    /** @type {Effect} */
    Ae
  ), a = wv();
  function l() {
    Promise.all(t.map((c) => /* @__PURE__ */ xv(c))).then((c) => {
      a();
      try {
        n([...e.map(r), ...c]);
      } catch (h) {
        (o.f & Zn) === 0 && jr(h, o);
      }
      s?.deactivate(), Za();
    }).catch((c) => {
      jr(c, o);
    });
  }
  i.length > 0 ? Promise.all(i).then(() => {
    a();
    try {
      return l();
    } finally {
      s?.deactivate(), Za();
    }
  }) : l();
}
function wv() {
  var i = Ae, e = Ce, t = je, n = Ne;
  return function(s = !0) {
    Ki(i), Vt(e), Wr(t), s && n?.activate();
  };
}
function Za() {
  Ki(null), Vt(null), Wr(null);
}
// @__NO_SIDE_EFFECTS__
function Qo(i) {
  var e = _t | ni, t = Ce !== null && (Ce.f & _t) !== 0 ? (
    /** @type {Derived} */
    Ce
  ) : null;
  return Ae !== null && (Ae.f |= hs), {
    ctx: je,
    deps: null,
    effects: null,
    equals: um,
    f: e,
    fn: i,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      St
    ),
    wv: 0,
    parent: t ?? Ae,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function xv(i, e) {
  let t = (
    /** @type {Effect | null} */
    Ae
  );
  t === null && Vy();
  var n = (
    /** @type {Boundary} */
    t.b
  ), r = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), s = pr(
    /** @type {V} */
    St
  ), o = !Ce, a = /* @__PURE__ */ new Map();
  return Ev(() => {
    var l = xf();
    r = l.promise;
    try {
      Promise.resolve(i()).then(l.resolve, l.reject).then(() => {
        c === Ne && c.committed && c.deactivate(), Za();
      });
    } catch (u) {
      l.reject(u), Za();
    }
    var c = (
      /** @type {Batch} */
      Ne
    );
    if (o) {
      var h = !n.is_pending();
      n.update_pending_count(1), c.increment(h), a.get(c)?.reject(Mr), a.delete(c), a.set(c, l);
    }
    const f = (u, d = void 0) => {
      if (c.activate(), d)
        d !== Mr && (s.f |= Xn, Ur(s, d));
      else {
        (s.f & Xn) !== 0 && (s.f ^= Xn), Ur(s, u);
        for (const [p, O] of a) {
          if (a.delete(p), p === c) break;
          O.reject(Mr);
        }
      }
      o && (n.update_pending_count(-1), c.decrement(h));
    };
    l.promise.then(f, (u) => f(null, u || "unknown"));
  }), Tf(() => {
    for (const l of a.values())
      l.reject(Mr);
  }), new Promise((l) => {
    function c(h) {
      function f() {
        h === r ? l(s) : c(r);
      }
      h.then(f, f);
    }
    c(r);
  });
}
// @__NO_SIDE_EFFECTS__
function Fl(i) {
  const e = /* @__PURE__ */ Qo(i);
  return Lm(e), e;
}
// @__NO_SIDE_EFFECTS__
function Pf(i) {
  const e = /* @__PURE__ */ Qo(i);
  return e.equals = dm, e;
}
function ym(i) {
  var e = i.effects;
  if (e !== null) {
    i.effects = null;
    for (var t = 0; t < e.length; t += 1)
      Et(
        /** @type {Effect} */
        e[t]
      );
  }
}
function kv(i) {
  for (var e = i.parent; e !== null; ) {
    if ((e.f & _t) === 0)
      return (
        /** @type {Effect} */
        e
      );
    e = e.parent;
  }
  return null;
}
function $f(i) {
  var e, t = Ae;
  Ki(kv(i));
  try {
    i.f &= ~eo, ym(i), e = Nm(i);
  } finally {
    Ki(t);
  }
  return e;
}
function vm(i) {
  var e = $f(i);
  if (i.equals(e) || (i.v = e, i.wv = Bm()), !wr)
    if (ei !== null)
      Ql() && ei.set(i, i.v);
    else {
      var t = (i.f & wi) === 0 ? tn : mt;
      bt(i, t);
    }
}
let oh = /* @__PURE__ */ new Set();
const zn = /* @__PURE__ */ new Map();
let Sm = !1;
function pr(i, e) {
  var t = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: i,
    reactions: null,
    equals: um,
    rv: 0,
    wv: 0
  };
  return t;
}
// @__NO_SIDE_EFFECTS__
function qe(i, e) {
  const t = pr(i);
  return Lm(t), t;
}
// @__NO_SIDE_EFFECTS__
function ah(i, e = !1, t = !0) {
  const n = pr(i);
  return e || (n.equals = dm), fs && t && je !== null && je.l !== null && (je.l.s ??= []).push(n), n;
}
function Pe(i, e, t = !1) {
  Ce !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!qi || (Ce.f & Fu) !== 0) && ko() && (Ce.f & (_t | en | kf | Fu)) !== 0 && !bn?.includes(i) && Ky();
  let n = t ? li(e) : e;
  return Ur(i, n);
}
function Ur(i, e) {
  if (!i.equals(e)) {
    var t = i.v;
    wr ? zn.set(i, e) : zn.set(i, t), i.v = e;
    var n = Ni.ensure();
    n.capture(i, t), (i.f & _t) !== 0 && ((i.f & ni) !== 0 && $f(
      /** @type {Derived} */
      i
    ), bt(i, (i.f & wi) !== 0 ? mt : tn)), i.wv = Bm(), wm(i, ni), ko() && Ae !== null && (Ae.f & mt) !== 0 && (Ae.f & (Qn | vr)) === 0 && (oi === null ? Zv([i]) : oi.push(i)), !n.is_fork && oh.size > 0 && !Sm && Qv();
  }
  return e;
}
function Qv() {
  Sm = !1;
  const i = Array.from(oh);
  for (const e of i)
    (e.f & mt) !== 0 && bt(e, tn), Os(e) && Fr(e);
  oh.clear();
}
function Ws(i) {
  Pe(i, i.v + 1);
}
function wm(i, e) {
  var t = i.reactions;
  if (t !== null)
    for (var n = ko(), r = t.length, s = 0; s < r; s++) {
      var o = t[s], a = o.f;
      if (!(!n && o === Ae)) {
        var l = (a & ni) === 0;
        if (l && bt(o, e), (a & _t) !== 0) {
          var c = (
            /** @type {Derived} */
            o
          );
          ei?.delete(c), (a & eo) === 0 && (a & wi && (o.f |= eo), wm(c, tn));
        } else l && ((a & en) !== 0 && un !== null && un.add(
          /** @type {Effect} */
          o
        ), dr(
          /** @type {Effect} */
          o
        ));
      }
    }
}
function li(i) {
  if (typeof i != "object" || i === null || ar in i)
    return i;
  const e = wf(i);
  if (e !== Dy && e !== Ly)
    return i;
  var t = /* @__PURE__ */ new Map(), n = vf(i), r = /* @__PURE__ */ qe(0), s = hr, o = (a) => {
    if (hr === s)
      return a();
    var l = Ce, c = hr;
    Vt(null), nd(s);
    var h = a();
    return Vt(l), nd(c), h;
  };
  return n && t.set("length", /* @__PURE__ */ qe(
    /** @type {any[]} */
    i.length
  )), new Proxy(
    /** @type {any} */
    i,
    {
      defineProperty(a, l, c) {
        (!("value" in c) || c.configurable === !1 || c.enumerable === !1 || c.writable === !1) && Fy();
        var h = t.get(l);
        return h === void 0 ? h = o(() => {
          var f = /* @__PURE__ */ qe(c.value);
          return t.set(l, f), f;
        }) : Pe(h, c.value, !0), !0;
      },
      deleteProperty(a, l) {
        var c = t.get(l);
        if (c === void 0) {
          if (l in a) {
            const h = o(() => /* @__PURE__ */ qe(St));
            t.set(l, h), Ws(r);
          }
        } else
          Pe(c, St), Ws(r);
        return !0;
      },
      get(a, l, c) {
        if (l === ar)
          return i;
        var h = t.get(l), f = l in a;
        if (h === void 0 && (!f || or(a, l)?.writable) && (h = o(() => {
          var d = li(f ? a[l] : St), p = /* @__PURE__ */ qe(d);
          return p;
        }), t.set(l, h)), h !== void 0) {
          var u = te(h);
          return u === St ? void 0 : u;
        }
        return Reflect.get(a, l, c);
      },
      getOwnPropertyDescriptor(a, l) {
        var c = Reflect.getOwnPropertyDescriptor(a, l);
        if (c && "value" in c) {
          var h = t.get(l);
          h && (c.value = te(h));
        } else if (c === void 0) {
          var f = t.get(l), u = f?.v;
          if (f !== void 0 && u !== St)
            return {
              enumerable: !0,
              configurable: !0,
              value: u,
              writable: !0
            };
        }
        return c;
      },
      has(a, l) {
        if (l === ar)
          return !0;
        var c = t.get(l), h = c !== void 0 && c.v !== St || Reflect.has(a, l);
        if (c !== void 0 || Ae !== null && (!h || or(a, l)?.writable)) {
          c === void 0 && (c = o(() => {
            var u = h ? li(a[l]) : St, d = /* @__PURE__ */ qe(u);
            return d;
          }), t.set(l, c));
          var f = te(c);
          if (f === St)
            return !1;
        }
        return h;
      },
      set(a, l, c, h) {
        var f = t.get(l), u = l in a;
        if (n && l === "length")
          for (var d = c; d < /** @type {Source<number>} */
          f.v; d += 1) {
            var p = t.get(d + "");
            p !== void 0 ? Pe(p, St) : d in a && (p = o(() => /* @__PURE__ */ qe(St)), t.set(d + "", p));
          }
        if (f === void 0)
          (!u || or(a, l)?.writable) && (f = o(() => /* @__PURE__ */ qe(void 0)), Pe(f, li(c)), t.set(l, f));
        else {
          u = f.v !== St;
          var O = o(() => li(c));
          Pe(f, O);
        }
        var m = Reflect.getOwnPropertyDescriptor(a, l);
        if (m?.set && m.set.call(h, c), !u) {
          if (n && typeof l == "string") {
            var g = (
              /** @type {Source<number>} */
              t.get("length")
            ), v = Number(l);
            Number.isInteger(v) && v >= g.v && Pe(g, v + 1);
          }
          Ws(r);
        }
        return !0;
      },
      ownKeys(a) {
        te(r);
        var l = Reflect.ownKeys(a).filter((f) => {
          var u = t.get(f);
          return u === void 0 || u.v !== St;
        });
        for (var [c, h] of t)
          h.v !== St && !(c in a) && l.push(c);
        return l;
      },
      setPrototypeOf() {
        Hy();
      }
    }
  );
}
var Ku, xm, km, Qm, _m;
function _v() {
  if (Ku === void 0) {
    Ku = window, xm = document, km = /Firefox/.test(navigator.userAgent);
    var i = Element.prototype, e = Node.prototype, t = Text.prototype;
    Qm = or(e, "firstChild").get, _m = or(e, "nextSibling").get, Gu(i) && (i.__click = void 0, i.__className = void 0, i.__attributes = null, i.__style = void 0, i.__e = void 0), Gu(t) && (t.__t = void 0);
  }
}
function Gr(i = "") {
  return document.createTextNode(i);
}
// @__NO_SIDE_EFFECTS__
function Vi(i) {
  return Qm.call(i);
}
// @__NO_SIDE_EFFECTS__
function _o(i) {
  return _m.call(i);
}
function Ee(i, e) {
  return /* @__PURE__ */ Vi(i);
}
function Pm(i, e = !1) {
  {
    var t = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ Vi(
        /** @type {Node} */
        i
      )
    );
    return t instanceof Comment && t.data === "" ? /* @__PURE__ */ _o(t) : t;
  }
}
function Ze(i, e = 1, t = !1) {
  let n = i;
  for (; e--; )
    n = /** @type {TemplateNode} */
    /* @__PURE__ */ _o(n);
  return n;
}
function Pv(i) {
  i.textContent = "";
}
function $m() {
  return !1;
}
let Ju = !1;
function $v() {
  Ju || (Ju = !0, document.addEventListener(
    "reset",
    (i) => {
      Promise.resolve().then(() => {
        if (!i.defaultPrevented)
          for (
            const e of
            /**@type {HTMLFormElement} */
            i.target.elements
          )
            e.__on_r?.();
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
    { capture: !0 }
  ));
}
function ps(i) {
  var e = Ce, t = Ae;
  Vt(null), Ki(null);
  try {
    return i();
  } finally {
    Vt(e), Ki(t);
  }
}
function Tm(i, e, t, n = t) {
  i.addEventListener(e, () => ps(t));
  const r = i.__on_r;
  r ? i.__on_r = () => {
    r(), n(!0);
  } : i.__on_r = () => n(!0), $v();
}
function Cm(i) {
  Ae === null && (Ce === null && jy(), Wy()), wr && qy();
}
function Tv(i, e) {
  var t = e.last;
  t === null ? e.last = e.first = i : (t.next = i, i.prev = t, e.last = i);
}
function nn(i, e, t, n = !0) {
  var r = Ae;
  r !== null && (r.f & ii) !== 0 && (i |= ii);
  var s = {
    ctx: je,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: i | ni | wi,
    first: null,
    fn: e,
    last: null,
    next: null,
    parent: r,
    b: r && r.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (t)
    try {
      Fr(s), s.f |= Sl;
    } catch (l) {
      throw Et(s), l;
    }
  else e !== null && dr(s);
  if (n) {
    var o = s;
    if (t && o.deps === null && o.teardown === null && o.nodes_start === null && o.first === o.last && // either `null`, or a singular child
    (o.f & hs) === 0 && (o = o.first, (i & en) !== 0 && (i & Ln) !== 0 && o !== null && (o.f |= Ln)), o !== null && (o.parent = r, r !== null && Tv(o, r), Ce !== null && (Ce.f & _t) !== 0 && (i & vr) === 0)) {
      var a = (
        /** @type {Derived} */
        Ce
      );
      (a.effects ??= []).push(o);
    }
  }
  return s;
}
function Ql() {
  return Ce !== null && !qi;
}
function Tf(i) {
  const e = nn(yl, null, !1);
  return bt(e, mt), e.teardown = i, e;
}
function lr(i) {
  Cm();
  var e = (
    /** @type {Effect} */
    Ae.f
  ), t = !Ce && (e & Qn) !== 0 && (e & Sl) === 0;
  if (t) {
    var n = (
      /** @type {ComponentContext} */
      je
    );
    (n.e ??= []).push(i);
  } else
    return Am(i);
}
function Am(i) {
  return nn(bl | hm, i, !1);
}
function Cv(i) {
  return Cm(), nn(yl | hm, i, !0);
}
function Av(i) {
  Ni.ensure();
  const e = nn(vr | hs, i, !0);
  return (t = {}) => new Promise((n) => {
    t.outro ? Lr(e, () => {
      Et(e), n(void 0);
    }) : (Et(e), n(void 0));
  });
}
function Po(i) {
  return nn(bl, i, !1);
}
function ed(i, e) {
  var t = (
    /** @type {ComponentContextLegacy} */
    je
  ), n = { effect: null, ran: !1, deps: i };
  t.l.$.push(n), n.effect = qn(() => {
    i(), !n.ran && (n.ran = !0, rn(e));
  });
}
function Rv() {
  var i = (
    /** @type {ComponentContextLegacy} */
    je
  );
  qn(() => {
    for (var e of i.l.$) {
      e.deps();
      var t = e.effect;
      (t.f & mt) !== 0 && bt(t, tn), Os(t) && Fr(t), e.ran = !1;
    }
  });
}
function Ev(i) {
  return nn(kf | hs, i, !0);
}
function qn(i, e = 0) {
  return nn(yl | e, i, !0);
}
function xi(i, e = [], t = [], n = [], r = !1) {
  Sv(n, e, t, (s) => {
    nn(r ? bl : yl, () => i(...s.map(te)), !0);
  });
}
function _l(i, e = 0) {
  var t = nn(en | e, i, !0);
  return t;
}
function yi(i, e = !0) {
  return nn(Qn | hs, i, !0, e);
}
function Rm(i) {
  var e = i.teardown;
  if (e !== null) {
    const t = wr, n = Ce;
    id(!0), Vt(null);
    try {
      e.call(null);
    } finally {
      id(t), Vt(n);
    }
  }
}
function Em(i, e = !1) {
  var t = i.first;
  for (i.first = i.last = null; t !== null; ) {
    const r = t.ac;
    r !== null && ps(() => {
      r.abort(Mr);
    });
    var n = t.next;
    (t.f & vr) !== 0 ? t.parent = null : Et(t, e), t = n;
  }
}
function Mv(i) {
  for (var e = i.first; e !== null; ) {
    var t = e.next;
    (e.f & Qn) === 0 && Et(e), e = t;
  }
}
function Et(i, e = !0) {
  var t = !1;
  (e || (i.f & cm) !== 0) && i.nodes_start !== null && i.nodes_end !== null && (Mm(
    i.nodes_start,
    /** @type {TemplateNode} */
    i.nodes_end
  ), t = !0), Em(i, e && !t), Xa(i, 0), bt(i, Zn);
  var n = i.transitions;
  if (n !== null)
    for (const s of n)
      s.stop();
  Rm(i);
  var r = i.parent;
  r !== null && r.first !== null && Zm(i), i.next = i.prev = i.teardown = i.ctx = i.deps = i.fn = i.nodes_start = i.nodes_end = i.ac = null;
}
function Mm(i, e) {
  for (; i !== null; ) {
    var t = i === e ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ _o(i)
    );
    i.remove(), i = t;
  }
}
function Zm(i) {
  var e = i.parent, t = i.prev, n = i.next;
  t !== null && (t.next = n), n !== null && (n.prev = t), e !== null && (e.first === i && (e.first = n), e.last === i && (e.last = t));
}
function Lr(i, e, t = !0) {
  var n = [];
  Cf(i, n, !0), Xm(n, () => {
    t && Et(i), e && e();
  });
}
function Xm(i, e) {
  var t = i.length;
  if (t > 0) {
    var n = () => --t || e();
    for (var r of i)
      r.out(n);
  } else
    e();
}
function Cf(i, e, t) {
  if ((i.f & ii) === 0) {
    if (i.f ^= ii, i.transitions !== null)
      for (const o of i.transitions)
        (o.is_global || t) && e.push(o);
    for (var n = i.first; n !== null; ) {
      var r = n.next, s = (n.f & Ln) !== 0 || // If this is a branch effect without a block effect parent,
      // it means the parent block effect was pruned. In that case,
      // transparency information was transferred to the branch effect.
      (n.f & Qn) !== 0 && (i.f & en) !== 0;
      Cf(n, e, s ? t : !1), n = r;
    }
  }
}
function Af(i) {
  zm(i, !0);
}
function zm(i, e) {
  if ((i.f & ii) !== 0) {
    i.f ^= ii, (i.f & mt) === 0 && (bt(i, ni), dr(i));
    for (var t = i.first; t !== null; ) {
      var n = t.next, r = (t.f & Ln) !== 0 || (t.f & Qn) !== 0;
      zm(t, r ? e : !1), t = n;
    }
    if (i.transitions !== null)
      for (const s of i.transitions)
        (s.is_global || e) && s.in();
  }
}
function Dm(i, e) {
  for (var t = i.nodes_start, n = i.nodes_end; t !== null; ) {
    var r = t === n ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ _o(t)
    );
    e.append(t), t = r;
  }
}
let cr = !1;
function td(i) {
  cr = i;
}
let wr = !1;
function id(i) {
  wr = i;
}
let Ce = null, qi = !1;
function Vt(i) {
  Ce = i;
}
let Ae = null;
function Ki(i) {
  Ae = i;
}
let bn = null;
function Lm(i) {
  Ce !== null && (bn === null ? bn = [i] : bn.push(i));
}
let At = null, Kt = 0, oi = null;
function Zv(i) {
  oi = i;
}
let Im = 1, to = 0, hr = to;
function nd(i) {
  hr = i;
}
function Bm() {
  return ++Im;
}
function Os(i) {
  var e = i.f;
  if ((e & ni) !== 0)
    return !0;
  if (e & _t && (i.f &= ~eo), (e & tn) !== 0) {
    var t = i.deps;
    if (t !== null)
      for (var n = t.length, r = 0; r < n; r++) {
        var s = t[r];
        if (Os(
          /** @type {Derived} */
          s
        ) && vm(
          /** @type {Derived} */
          s
        ), s.wv > i.wv)
          return !0;
      }
    (e & wi) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    ei === null && bt(i, mt);
  }
  return !1;
}
function Ym(i, e, t = !0) {
  var n = i.reactions;
  if (n !== null && !bn?.includes(i))
    for (var r = 0; r < n.length; r++) {
      var s = n[r];
      (s.f & _t) !== 0 ? Ym(
        /** @type {Derived} */
        s,
        e,
        !1
      ) : e === s && (t ? bt(s, ni) : (s.f & mt) !== 0 && bt(s, tn), dr(
        /** @type {Effect} */
        s
      ));
    }
}
function Nm(i) {
  var e = At, t = Kt, n = oi, r = Ce, s = bn, o = je, a = qi, l = hr, c = i.f;
  At = /** @type {null | Value[]} */
  null, Kt = 0, oi = null, Ce = (c & (Qn | vr)) === 0 ? i : null, bn = null, Wr(i.ctx), qi = !1, hr = ++to, i.ac !== null && (ps(() => {
    i.ac.abort(Mr);
  }), i.ac = null);
  try {
    i.f |= rh;
    var h = (
      /** @type {Function} */
      i.fn
    ), f = h(), u = i.deps;
    if (At !== null) {
      var d;
      if (Xa(i, Kt), u !== null && Kt > 0)
        for (u.length = Kt + At.length, d = 0; d < At.length; d++)
          u[Kt + d] = At[d];
      else
        i.deps = u = At;
      if (cr && Ql() && (i.f & wi) !== 0)
        for (d = Kt; d < u.length; d++)
          (u[d].reactions ??= []).push(i);
    } else u !== null && Kt < u.length && (Xa(i, Kt), u.length = Kt);
    if (ko() && oi !== null && !qi && u !== null && (i.f & (_t | tn | ni)) === 0)
      for (d = 0; d < /** @type {Source[]} */
      oi.length; d++)
        Ym(
          oi[d],
          /** @type {Effect} */
          i
        );
    return r !== null && r !== i && (to++, oi !== null && (n === null ? n = oi : n.push(.../** @type {Source[]} */
    oi))), (i.f & Xn) !== 0 && (i.f ^= Xn), f;
  } catch (p) {
    return Om(p);
  } finally {
    i.f ^= rh, At = e, Kt = t, oi = n, Ce = r, bn = s, Wr(o), qi = a, hr = l;
  }
}
function Xv(i, e) {
  let t = e.reactions;
  if (t !== null) {
    var n = Xy.call(t, i);
    if (n !== -1) {
      var r = t.length - 1;
      r === 0 ? t = e.reactions = null : (t[n] = t[r], t.pop());
    }
  }
  t === null && (e.f & _t) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (At === null || !At.includes(e)) && (bt(e, tn), (e.f & wi) !== 0 && (e.f ^= wi, e.f &= ~eo), ym(
    /** @type {Derived} **/
    e
  ), Xa(
    /** @type {Derived} **/
    e,
    0
  ));
}
function Xa(i, e) {
  var t = i.deps;
  if (t !== null)
    for (var n = e; n < t.length; n++)
      Xv(i, t[n]);
}
function Fr(i) {
  var e = i.f;
  if ((e & Zn) === 0) {
    bt(i, mt);
    var t = Ae, n = cr;
    Ae = i, cr = !0;
    try {
      (e & en) !== 0 ? Mv(i) : Em(i), Rm(i);
      var r = Nm(i);
      i.teardown = typeof r == "function" ? r : null, i.wv = Im;
      var s;
    } finally {
      cr = n, Ae = t;
    }
  }
}
async function Vm() {
  await Promise.resolve(), Ov();
}
function te(i) {
  var e = i.f, t = (e & _t) !== 0;
  if (Ce !== null && !qi) {
    var n = Ae !== null && (Ae.f & Zn) !== 0;
    if (!n && !bn?.includes(i)) {
      var r = Ce.deps;
      if ((Ce.f & rh) !== 0)
        i.rv < to && (i.rv = to, At === null && r !== null && r[Kt] === i ? Kt++ : At === null ? At = [i] : At.includes(i) || At.push(i));
      else {
        (Ce.deps ??= []).push(i);
        var s = i.reactions;
        s === null ? i.reactions = [Ce] : s.includes(Ce) || s.push(Ce);
      }
    }
  }
  if (wr) {
    if (zn.has(i))
      return zn.get(i);
    if (t) {
      var o = (
        /** @type {Derived} */
        i
      ), a = o.v;
      return ((o.f & mt) === 0 && o.reactions !== null || Wm(o)) && (a = $f(o)), zn.set(o, a), a;
    }
  } else if (t) {
    if (o = /** @type {Derived} */
    i, ei?.has(o))
      return ei.get(o);
    Os(o) && vm(o), cr && Ql() && (o.f & wi) === 0 && qm(o);
  } else if (ei?.has(i))
    return ei.get(i);
  if ((i.f & Xn) !== 0)
    throw i.v;
  return i.v;
}
function qm(i) {
  if (i.deps !== null) {
    i.f ^= wi;
    for (const e of i.deps)
      (e.reactions ??= []).push(i), (e.f & _t) !== 0 && (e.f & wi) === 0 && qm(
        /** @type {Derived} */
        e
      );
  }
}
function Wm(i) {
  if (i.v === St) return !0;
  if (i.deps === null) return !1;
  for (const e of i.deps)
    if (zn.has(e) || (e.f & _t) !== 0 && Wm(
      /** @type {Derived} */
      e
    ))
      return !0;
  return !1;
}
function rn(i) {
  var e = qi;
  try {
    return qi = !0, i();
  } finally {
    qi = e;
  }
}
const zv = -7169;
function bt(i, e) {
  i.f = i.f & zv | e;
}
function za(i) {
  if (!(typeof i != "object" || !i || i instanceof EventTarget)) {
    if (ar in i)
      lh(i);
    else if (!Array.isArray(i))
      for (let e in i) {
        const t = i[e];
        typeof t == "object" && t && ar in t && lh(t);
      }
  }
}
function lh(i, e = /* @__PURE__ */ new Set()) {
  if (typeof i == "object" && i !== null && // We don't want to traverse DOM elements
  !(i instanceof EventTarget) && !e.has(i)) {
    e.add(i), i instanceof Date && i.getTime();
    for (let n in i)
      try {
        lh(i[n], e);
      } catch {
      }
    const t = wf(i);
    if (t !== Object.prototype && t !== Array.prototype && t !== Map.prototype && t !== Set.prototype && t !== Date.prototype) {
      const n = lm(t);
      for (let r in n) {
        const s = n[r].get;
        if (s)
          try {
            s.call(i);
          } catch {
          }
      }
    }
  }
}
const Dv = ["touchstart", "touchmove"];
function Lv(i) {
  return Dv.includes(i);
}
const jm = /* @__PURE__ */ new Set(), ch = /* @__PURE__ */ new Set();
function Iv(i, e, t, n = {}) {
  function r(s) {
    if (n.capture || Ls.call(e, s), !s.cancelBubble)
      return ps(() => t?.call(this, s));
  }
  return i.startsWith("pointer") || i.startsWith("touch") || i === "wheel" ? Sr(() => {
    e.addEventListener(i, r, n);
  }) : e.addEventListener(i, r, n), r;
}
function Bv(i, e, t, n, r) {
  var s = { capture: n, passive: r }, o = Iv(i, e, t, s);
  (e === document.body || // @ts-ignore
  e === window || // @ts-ignore
  e === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  e instanceof HTMLMediaElement) && Tf(() => {
    e.removeEventListener(i, o, s);
  });
}
function Rf(i) {
  for (var e = 0; e < i.length; e++)
    jm.add(i[e]);
  for (var t of ch)
    t(i);
}
let rd = null;
function Ls(i) {
  var e = this, t = (
    /** @type {Node} */
    e.ownerDocument
  ), n = i.type, r = i.composedPath?.() || [], s = (
    /** @type {null | Element} */
    r[0] || i.target
  );
  rd = i;
  var o = 0, a = rd === i && i.__root;
  if (a) {
    var l = r.indexOf(a);
    if (l !== -1 && (e === document || e === /** @type {any} */
    window)) {
      i.__root = e;
      return;
    }
    var c = r.indexOf(e);
    if (c === -1)
      return;
    l <= c && (o = l);
  }
  if (s = /** @type {Element} */
  r[o] || i.target, s !== e) {
    zy(i, "currentTarget", {
      configurable: !0,
      get() {
        return s || t;
      }
    });
    var h = Ce, f = Ae;
    Vt(null), Ki(null);
    try {
      for (var u, d = []; s !== null; ) {
        var p = s.assignedSlot || s.parentNode || /** @type {any} */
        s.host || null;
        try {
          var O = s["__" + n];
          O != null && (!/** @type {any} */
          s.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          i.target === s) && O.call(s, i);
        } catch (m) {
          u ? d.push(m) : u = m;
        }
        if (i.cancelBubble || p === e || p === null)
          break;
        s = p;
      }
      if (u) {
        for (let m of d)
          queueMicrotask(() => {
            throw m;
          });
        throw u;
      }
    } finally {
      i.__root = e, delete i.currentTarget, Vt(h), Ki(f);
    }
  }
}
function Ef(i) {
  var e = document.createElement("template");
  return e.innerHTML = i.replaceAll("<!>", "<!---->"), e.content;
}
function Da(i, e) {
  var t = (
    /** @type {Effect} */
    Ae
  );
  t.nodes_start === null && (t.nodes_start = i, t.nodes_end = e);
}
// @__NO_SIDE_EFFECTS__
function ri(i, e) {
  var t = (e & lv) !== 0, n = (e & cv) !== 0, r, s = !i.startsWith("<!>");
  return () => {
    r === void 0 && (r = Ef(s ? i : "<!>" + i), t || (r = /** @type {Node} */
    /* @__PURE__ */ Vi(r)));
    var o = (
      /** @type {TemplateNode} */
      n || km ? document.importNode(r, !0) : r.cloneNode(!0)
    );
    if (t) {
      var a = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Vi(o)
      ), l = (
        /** @type {TemplateNode} */
        o.lastChild
      );
      Da(a, l);
    } else
      Da(o, o);
    return o;
  };
}
// @__NO_SIDE_EFFECTS__
function Yv(i, e, t = "svg") {
  var n = !i.startsWith("<!>"), r = `<${t}>${n ? i : "<!>" + i}</${t}>`, s;
  return () => {
    if (!s) {
      var o = (
        /** @type {DocumentFragment} */
        Ef(r)
      ), a = (
        /** @type {Element} */
        /* @__PURE__ */ Vi(o)
      );
      s = /** @type {Element} */
      /* @__PURE__ */ Vi(a);
    }
    var l = (
      /** @type {TemplateNode} */
      s.cloneNode(!0)
    );
    return Da(l, l), l;
  };
}
// @__NO_SIDE_EFFECTS__
function Nv(i, e) {
  return /* @__PURE__ */ Yv(i, e, "svg");
}
function qt(i, e) {
  i !== null && i.before(
    /** @type {Node} */
    e
  );
}
let hh = !0;
function mn(i, e) {
  var t = e == null ? "" : typeof e == "object" ? e + "" : e;
  t !== (i.__t ??= i.nodeValue) && (i.__t = t, i.nodeValue = t + "");
}
function Vv(i, e) {
  return qv(i, e);
}
const Pr = /* @__PURE__ */ new Map();
function qv(i, { target: e, anchor: t, props: n = {}, events: r, context: s, intro: o = !0 }) {
  _v();
  var a = /* @__PURE__ */ new Set(), l = (f) => {
    for (var u = 0; u < f.length; u++) {
      var d = f[u];
      if (!a.has(d)) {
        a.add(d);
        var p = Lv(d);
        e.addEventListener(d, Ls, { passive: p });
        var O = Pr.get(d);
        O === void 0 ? (document.addEventListener(d, Ls, { passive: p }), Pr.set(d, 1)) : Pr.set(d, O + 1);
      }
    }
  };
  l(Sf(jm)), ch.add(l);
  var c = void 0, h = Av(() => {
    var f = t ?? e.appendChild(Gr());
    return yv(
      /** @type {TemplateNode} */
      f,
      {
        pending: () => {
        }
      },
      (u) => {
        if (s) {
          us({});
          var d = (
            /** @type {ComponentContext} */
            je
          );
          d.c = s;
        }
        r && (n.$$events = r), hh = o, c = i(u, n) || {}, hh = !0, s && ds();
      }
    ), () => {
      for (var u of a) {
        e.removeEventListener(u, Ls);
        var d = (
          /** @type {number} */
          Pr.get(u)
        );
        --d === 0 ? (document.removeEventListener(u, Ls), Pr.delete(u)) : Pr.set(u, d);
      }
      ch.delete(l), f !== t && f.parentNode?.removeChild(f);
    };
  });
  return Wv.set(c, h), c;
}
let Wv = /* @__PURE__ */ new WeakMap();
class Um {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #e = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Effect>} */
  #t = /* @__PURE__ */ new Map();
  /** @type {Map<Key, Branch>} */
  #n = /* @__PURE__ */ new Map();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #i = !0;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(e, t = !0) {
    this.anchor = e, this.#i = t;
  }
  #l = () => {
    var e = (
      /** @type {Batch} */
      Ne
    );
    if (this.#e.has(e)) {
      var t = (
        /** @type {Key} */
        this.#e.get(e)
      ), n = this.#t.get(t);
      if (n)
        Af(n);
      else {
        var r = this.#n.get(t);
        r && (this.#t.set(t, r.effect), this.#n.delete(t), r.fragment.lastChild.remove(), this.anchor.before(r.fragment), n = r.effect);
      }
      for (const [s, o] of this.#e) {
        if (this.#e.delete(s), s === e)
          break;
        const a = this.#n.get(o);
        a && (Et(a.effect), this.#n.delete(o));
      }
      for (const [s, o] of this.#t) {
        if (s === t) continue;
        const a = () => {
          if (Array.from(this.#e.values()).includes(s)) {
            var c = document.createDocumentFragment();
            Dm(o, c), c.append(Gr()), this.#n.set(s, { effect: o, fragment: c });
          } else
            Et(o);
          this.#t.delete(s);
        };
        this.#i || !n ? Lr(o, a, !1) : a();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #s = (e) => {
    this.#e.delete(e);
    const t = Array.from(this.#e.values());
    for (const [n, r] of this.#n)
      t.includes(n) || (Et(r.effect), this.#n.delete(n));
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(e, t) {
    var n = (
      /** @type {Batch} */
      Ne
    ), r = $m();
    if (t && !this.#t.has(e) && !this.#n.has(e))
      if (r) {
        var s = document.createDocumentFragment(), o = Gr();
        s.append(o), this.#n.set(e, {
          effect: yi(() => t(o)),
          fragment: s
        });
      } else
        this.#t.set(
          e,
          yi(() => t(this.anchor))
        );
    if (this.#e.set(n, e), r) {
      for (const [a, l] of this.#t)
        a === e ? n.skipped_effects.delete(l) : n.skipped_effects.add(l);
      for (const [a, l] of this.#n)
        a === e ? n.skipped_effects.delete(l.effect) : n.skipped_effects.add(l.effect);
      n.oncommit(this.#l), n.ondiscard(this.#s);
    } else
      this.#l();
  }
}
function La(i, e, t = !1) {
  var n = new Um(i), r = t ? Ln : 0;
  function s(o, a) {
    n.ensure(o, a);
  }
  _l(() => {
    var o = !1;
    e((a, l = !0) => {
      o = !0, s(l, a);
    }), o || s(!1, null);
  }, r);
}
function Mf(i, e) {
  return e;
}
function jv(i, e, t) {
  for (var n = i.items, r = [], s = e.length, o = 0; o < s; o++)
    Cf(e[o].e, r, !0);
  var a = s > 0 && r.length === 0 && t !== null;
  if (a) {
    var l = (
      /** @type {Element} */
      /** @type {Element} */
      t.parentNode
    );
    Pv(l), l.append(
      /** @type {Element} */
      t
    ), n.clear(), Xi(i, e[0].prev, e[s - 1].next);
  }
  Xm(r, () => {
    for (var c = 0; c < s; c++) {
      var h = e[c];
      a || (n.delete(h.k), Xi(i, h.prev, h.next)), Et(h.e, !a);
    }
  });
}
function Zf(i, e, t, n, r, s = null) {
  var o = i, a = { flags: e, items: /* @__PURE__ */ new Map(), first: null }, l = (e & fm) !== 0;
  if (l) {
    var c = (
      /** @type {Element} */
      i
    );
    o = c.appendChild(Gr());
  }
  var h = null, f = !1, u = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ Pf(() => {
    var g = t();
    return vf(g) ? g : g == null ? [] : Sf(g);
  }), p, O;
  function m() {
    Uv(
      O,
      p,
      a,
      u,
      o,
      r,
      e,
      n,
      t
    ), s !== null && (p.length === 0 ? h ? Af(h) : h = yi(() => s(o)) : h !== null && Lr(h, () => {
      h = null;
    }));
  }
  _l(() => {
    O ??= /** @type {Effect} */
    Ae, p = /** @type {V[]} */
    te(d);
    var g = p.length;
    if (!(f && g === 0)) {
      f = g === 0;
      var v, S, w, x;
      if ($m()) {
        var P = /* @__PURE__ */ new Set(), k = (
          /** @type {Batch} */
          Ne
        );
        for (S = 0; S < g; S += 1) {
          w = p[S], x = n(w, S);
          var A = a.items.get(x) ?? u.get(x);
          A ? (e & (wl | xl)) !== 0 && Gm(A, w, S, e) : (v = Fm(
            null,
            a,
            null,
            null,
            w,
            x,
            S,
            r,
            e,
            t,
            !0
          ), u.set(x, v)), P.add(x);
        }
        for (const [C, Z] of a.items)
          P.has(C) || k.skipped_effects.add(Z.e);
        k.oncommit(m);
      } else
        m();
      te(d);
    }
  });
}
function Uv(i, e, t, n, r, s, o, a, l) {
  var c = (o & ev) !== 0, h = (o & (wl | xl)) !== 0, f = e.length, u = t.items, d = t.first, p = d, O, m = null, g, v = [], S = [], w, x, P, k;
  if (c)
    for (k = 0; k < f; k += 1)
      w = e[k], x = a(w, k), P = u.get(x), P !== void 0 && (P.a?.measure(), (g ??= /* @__PURE__ */ new Set()).add(P));
  for (k = 0; k < f; k += 1) {
    if (w = e[k], x = a(w, k), P = u.get(x), P === void 0) {
      var A = n.get(x);
      if (A !== void 0) {
        n.delete(x), u.set(x, A);
        var C = m ? m.next : p;
        Xi(t, m, A), Xi(t, A, C), Hl(A, C, r), m = A;
      } else {
        var Z = p ? (
          /** @type {TemplateNode} */
          p.e.nodes_start
        ) : r;
        m = Fm(
          Z,
          t,
          m,
          m === null ? t.first : m.next,
          w,
          x,
          k,
          s,
          o,
          l
        );
      }
      u.set(x, m), v = [], S = [], p = m.next;
      continue;
    }
    if (h && Gm(P, w, k, o), (P.e.f & ii) !== 0 && (Af(P.e), c && (P.a?.unfix(), (g ??= /* @__PURE__ */ new Set()).delete(P))), P !== p) {
      if (O !== void 0 && O.has(P)) {
        if (v.length < S.length) {
          var I = S[0], Q;
          m = I.prev;
          var E = v[0], y = v[v.length - 1];
          for (Q = 0; Q < v.length; Q += 1)
            Hl(v[Q], I, r);
          for (Q = 0; Q < S.length; Q += 1)
            O.delete(S[Q]);
          Xi(t, E.prev, y.next), Xi(t, m, E), Xi(t, y, I), p = I, m = y, k -= 1, v = [], S = [];
        } else
          O.delete(P), Hl(P, p, r), Xi(t, P.prev, P.next), Xi(t, P, m === null ? t.first : m.next), Xi(t, m, P), m = P;
        continue;
      }
      for (v = [], S = []; p !== null && p.k !== x; )
        (p.e.f & ii) === 0 && (O ??= /* @__PURE__ */ new Set()).add(p), S.push(p), p = p.next;
      if (p === null)
        continue;
      P = p;
    }
    v.push(P), m = P, p = P.next;
  }
  if (p !== null || O !== void 0) {
    for (var L = O === void 0 ? [] : Sf(O); p !== null; )
      (p.e.f & ii) === 0 && L.push(p), p = p.next;
    var se = L.length;
    if (se > 0) {
      var V = (o & fm) !== 0 && f === 0 ? r : null;
      if (c) {
        for (k = 0; k < se; k += 1)
          L[k].a?.measure();
        for (k = 0; k < se; k += 1)
          L[k].a?.fix();
      }
      jv(t, L, V);
    }
  }
  c && Sr(() => {
    if (g !== void 0)
      for (P of g)
        P.a?.apply();
  }), i.first = t.first && t.first.e, i.last = m && m.e;
  for (var fe of n.values())
    Et(fe.e);
  n.clear();
}
function Gm(i, e, t, n) {
  (n & wl) !== 0 && Ur(i.v, e), (n & xl) !== 0 ? Ur(
    /** @type {Value<number>} */
    i.i,
    t
  ) : i.i = t;
}
function Fm(i, e, t, n, r, s, o, a, l, c, h) {
  var f = (l & wl) !== 0, u = (l & tv) === 0, d = f ? u ? /* @__PURE__ */ ah(r, !1, !1) : pr(r) : r, p = (l & xl) === 0 ? o : pr(o), O = {
    i: p,
    v: d,
    k: s,
    a: null,
    // @ts-expect-error
    e: null,
    prev: t,
    next: n
  };
  try {
    if (i === null) {
      var m = document.createDocumentFragment();
      m.append(i = Gr());
    }
    return O.e = yi(() => a(
      /** @type {Node} */
      i,
      d,
      p,
      c
    ), uv), O.e.prev = t && t.e, O.e.next = n && n.e, t === null ? h || (e.first = O) : (t.next = O, t.e.next = O.e), n !== null && (n.prev = O, n.e.prev = O.e), O;
  } finally {
  }
}
function Hl(i, e, t) {
  for (var n = i.next ? (
    /** @type {TemplateNode} */
    i.next.e.nodes_start
  ) : t, r = e ? (
    /** @type {TemplateNode} */
    e.e.nodes_start
  ) : t, s = (
    /** @type {TemplateNode} */
    i.e.nodes_start
  ); s !== null && s !== n; ) {
    var o = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ _o(s)
    );
    r.before(s), s = o;
  }
}
function Xi(i, e, t) {
  e === null ? i.first = t : (e.next = t, e.e.next = t && t.e), t !== null && (t.prev = e, t.e.prev = e && e.e);
}
function Gv(i, e, t = !1, n = !1, r = !1) {
  var s = i, o = "";
  xi(() => {
    var a = (
      /** @type {Effect} */
      Ae
    );
    if (o !== (o = e() ?? "") && (a.nodes_start !== null && (Mm(
      a.nodes_start,
      /** @type {TemplateNode} */
      a.nodes_end
    ), a.nodes_start = a.nodes_end = null), o !== "")) {
      var l = o + "";
      t ? l = `<svg>${l}</svg>` : n && (l = `<math>${l}</math>`);
      var c = Ef(l);
      if ((t || n) && (c = /** @type {Element} */
      /* @__PURE__ */ Vi(c)), Da(
        /** @type {TemplateNode} */
        /* @__PURE__ */ Vi(c),
        /** @type {TemplateNode} */
        c.lastChild
      ), t || n)
        for (; /* @__PURE__ */ Vi(c); )
          s.before(
            /** @type {Node} */
            /* @__PURE__ */ Vi(c)
          );
      else
        s.before(c);
    }
  });
}
function Fv(i, e, ...t) {
  var n = new Um(i);
  _l(() => {
    const r = e() ?? null;
    n.ensure(r, r && ((s) => r(s, ...t)));
  }, Ln);
}
function Hm(i, e) {
  Po(() => {
    var t = i.getRootNode(), n = (
      /** @type {ShadowRoot} */
      t.host ? (
        /** @type {ShadowRoot} */
        t
      ) : (
        /** @type {Document} */
        t.head ?? /** @type {Document} */
        t.ownerDocument.head
      )
    );
    if (!n.querySelector("#" + e.hash)) {
      const r = document.createElement("style");
      r.id = e.hash, r.textContent = e.code, n.appendChild(r);
    }
  });
}
function Km(i, e, t) {
  Po(() => {
    var n = rn(() => e(i, t?.()) || {});
    if (t && n?.update) {
      var r = !1, s = (
        /** @type {any} */
        {}
      );
      qn(() => {
        var o = t();
        za(o), r && _f(s, o) && (s = o, n.update(o));
      }), r = !0;
    }
    if (n?.destroy)
      return () => (
        /** @type {Function} */
        n.destroy()
      );
  });
}
function Hv(i, e, t) {
  var n = i == null ? "" : "" + i;
  return e && (n = n ? n + " " + e : e), n === "" ? null : n;
}
function sd(i, e = !1) {
  var t = e ? " !important;" : ";", n = "";
  for (var r in i) {
    var s = i[r];
    s != null && s !== "" && (n += " " + r + ": " + s + t);
  }
  return n;
}
function Kv(i, e) {
  if (e) {
    var t = "", n, r;
    return Array.isArray(e) ? (n = e[0], r = e[1]) : n = e, n && (t += sd(n)), r && (t += sd(r, !0)), t = t.trim(), t === "" ? null : t;
  }
  return String(i);
}
function Jm(i, e, t, n, r, s) {
  var o = i.__className;
  if (o !== t || o === void 0) {
    var a = Hv(t, n);
    a == null ? i.removeAttribute("class") : i.className = a, i.__className = t;
  }
  return s;
}
function Kl(i, e = {}, t, n) {
  for (var r in t) {
    var s = t[r];
    e[r] !== s && (t[r] == null ? i.style.removeProperty(r) : i.style.setProperty(r, s, n));
  }
}
function Ia(i, e, t, n) {
  var r = i.__style;
  if (r !== e) {
    var s = Kv(e, n);
    s == null ? i.removeAttribute("style") : i.style.cssText = s, i.__style = e;
  } else n && (Array.isArray(n) ? (Kl(i, t?.[0], n[0]), Kl(i, t?.[1], n[1], "important")) : Kl(i, t, n));
  return n;
}
const Jv = Symbol("is custom element"), eS = Symbol("is html");
function ya(i, e, t, n) {
  var r = tS(i);
  r[e] !== (r[e] = t) && (e === "loading" && (i[Ny] = t), t == null ? i.removeAttribute(e) : typeof t != "string" && iS(i).includes(e) ? i[e] = t : i.setAttribute(e, t));
}
function tS(i) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    i.__attributes ??= {
      [Jv]: i.nodeName.includes("-"),
      [eS]: i.namespaceURI === hv
    }
  );
}
var od = /* @__PURE__ */ new Map();
function iS(i) {
  var e = i.getAttribute("is") || i.nodeName, t = od.get(e);
  if (t) return t;
  od.set(e, t = []);
  for (var n, r = i, s = Element.prototype; s !== r; ) {
    n = lm(r);
    for (var o in n)
      n[o].set && t.push(o);
    r = wf(r);
  }
  return t;
}
const nS = () => performance.now(), Li = {
  // don't access requestAnimationFrame eagerly outside method
  // this allows basic testing of user code without JSDOM
  // bunder will eval and remove ternary when the user's app is built
  tick: (
    /** @param {any} _ */
    (i) => requestAnimationFrame(i)
  ),
  now: () => nS(),
  tasks: /* @__PURE__ */ new Set()
};
function eg() {
  const i = Li.now();
  Li.tasks.forEach((e) => {
    e.c(i) || (Li.tasks.delete(e), e.f());
  }), Li.tasks.size !== 0 && Li.tick(eg);
}
function tg(i) {
  let e;
  return Li.tasks.size === 0 && Li.tick(eg), {
    promise: new Promise((t) => {
      Li.tasks.add(e = { c: i, f: t });
    }),
    abort() {
      Li.tasks.delete(e);
    }
  };
}
function Do(i, e) {
  ps(() => {
    i.dispatchEvent(new CustomEvent(e));
  });
}
function rS(i) {
  if (i === "float") return "cssFloat";
  if (i === "offset") return "cssOffset";
  if (i.startsWith("--")) return i;
  const e = i.split("-");
  return e.length === 1 ? e[0] : e[0] + e.slice(1).map(
    /** @param {any} word */
    (t) => t[0].toUpperCase() + t.slice(1)
  ).join("");
}
function ad(i) {
  const e = {}, t = i.split(";");
  for (const n of t) {
    const [r, s] = n.split(":");
    if (!r || s === void 0) break;
    const o = rS(r.trim());
    e[o] = s.trim();
  }
  return e;
}
const sS = (i) => i;
function oS(i, e, t, n) {
  var r = (i & av) !== 0, s = "both", o, a = e.inert, l = e.style.overflow, c, h;
  function f() {
    return ps(() => o ??= t()(e, n?.() ?? /** @type {P} */
    {}, {
      direction: s
    }));
  }
  var u = {
    is_global: r,
    in() {
      e.inert = a, Do(e, "introstart"), c = fh(e, f(), h, 1, () => {
        Do(e, "introend"), c?.abort(), c = o = void 0, e.style.overflow = l;
      });
    },
    out(m) {
      e.inert = !0, Do(e, "outrostart"), h = fh(e, f(), c, 0, () => {
        Do(e, "outroend"), m?.();
      });
    },
    stop: () => {
      c?.abort(), h?.abort();
    }
  }, d = (
    /** @type {Effect} */
    Ae
  );
  if ((d.transitions ??= []).push(u), hh) {
    var p = r;
    if (!p) {
      for (var O = (
        /** @type {Effect | null} */
        d.parent
      ); O && (O.f & Ln) !== 0; )
        for (; (O = O.parent) && (O.f & en) === 0; )
          ;
      p = !O || (O.f & Sl) !== 0;
    }
    p && Po(() => {
      rn(() => u.in());
    });
  }
}
function fh(i, e, t, n, r) {
  var s = n === 1;
  if (Iy(e)) {
    var o, a = !1;
    return Sr(() => {
      if (!a) {
        var m = e({ direction: s ? "in" : "out" });
        o = fh(i, m, t, n, r);
      }
    }), {
      abort: () => {
        a = !0, o?.abort();
      },
      deactivate: () => o.deactivate(),
      reset: () => o.reset(),
      t: () => o.t()
    };
  }
  if (t?.deactivate(), !e?.duration)
    return r(), {
      abort: zi,
      deactivate: zi,
      reset: zi,
      t: () => n
    };
  const { delay: l = 0, css: c, tick: h, easing: f = sS } = e;
  var u = [];
  if (s && t === void 0 && (h && h(0, 1), c)) {
    var d = ad(c(0, 1));
    u.push(d, d);
  }
  var p = () => 1 - n, O = i.animate(u, { duration: l, fill: "forwards" });
  return O.onfinish = () => {
    O.cancel();
    var m = t?.t() ?? 1 - n;
    t?.abort();
    var g = n - m, v = (
      /** @type {number} */
      e.duration * Math.abs(g)
    ), S = [];
    if (v > 0) {
      var w = !1;
      if (c)
        for (var x = Math.ceil(v / 16.666666666666668), P = 0; P <= x; P += 1) {
          var k = m + g * f(P / x), A = ad(c(k, 1 - k));
          S.push(A), w ||= A.overflow === "hidden";
        }
      w && (i.style.overflow = "hidden"), p = () => {
        var C = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          O.currentTime
        );
        return m + g * f(C / v);
      }, h && tg(() => {
        if (O.playState !== "running") return !1;
        var C = p();
        return h(C, 1 - C), !0;
      });
    }
    O = i.animate(S, { duration: v, fill: "forwards" }), O.onfinish = () => {
      p = () => n, h?.(n, 1 - n), r();
    };
  }, {
    abort: () => {
      O && (O.cancel(), O.effect = null, O.onfinish = zi);
    },
    deactivate: () => {
      r = zi;
    },
    reset: () => {
      n === 0 && h?.(1, 0);
    },
    t: () => p()
  };
}
function ld(i, e, t = e) {
  var n = /* @__PURE__ */ new WeakSet();
  Tm(i, "input", async (r) => {
    var s = r ? i.defaultValue : i.value;
    if (s = Jl(i) ? ec(s) : s, t(s), Ne !== null && n.add(Ne), await Vm(), s !== (s = e())) {
      var o = i.selectionStart, a = i.selectionEnd, l = i.value.length;
      if (i.value = s ?? "", a !== null) {
        var c = i.value.length;
        o === a && a === l && c > l ? (i.selectionStart = c, i.selectionEnd = c) : (i.selectionStart = o, i.selectionEnd = Math.min(a, c));
      }
    }
  }), // If we are hydrating and the value has since changed,
  // then use the updated value from the input instead.
  // If defaultValue is set, then value == defaultValue
  // TODO Svelte 6: remove input.value check and set to empty string?
  rn(e) == null && i.value && (t(Jl(i) ? ec(i.value) : i.value), Ne !== null && n.add(Ne)), qn(() => {
    var r = e();
    if (i === document.activeElement) {
      var s = (
        /** @type {Batch} */
        ba ?? Ne
      );
      if (n.has(s))
        return;
    }
    Jl(i) && r === ec(i.value) || i.type === "date" && !r && !i.value || r !== i.value && (i.value = r ?? "");
  });
}
function Jl(i) {
  var e = i.type;
  return e === "number" || e === "range";
}
function ec(i) {
  return i === "" ? null : +i;
}
function aS(i, e, t = e) {
  Tm(i, "change", () => {
    t(i.files);
  }), qn(() => {
    i.files = e();
  });
}
function lS(i, e, t) {
  var n = or(i, e);
  n && n.set && (i[e] = t, Tf(() => {
    i[e] = null;
  }));
}
function cd(i, e) {
  return i === e || i?.[ar] === e;
}
function Pl(i = {}, e, t, n) {
  return Po(() => {
    var r, s;
    return qn(() => {
      r = s, s = n?.() || [], rn(() => {
        i !== t(...s) && (e(i, ...s), r && cd(t(...r), i) && e(null, ...r));
      });
    }), () => {
      Sr(() => {
        s && cd(t(...s), i) && e(null, ...s);
      });
    };
  }), i;
}
function cS(i = !1) {
  const e = (
    /** @type {ComponentContextLegacy} */
    je
  ), t = e.l.u;
  if (!t) return;
  let n = () => za(e.s);
  if (i) {
    let r = 0, s = (
      /** @type {Record<string, any>} */
      {}
    );
    const o = /* @__PURE__ */ Qo(() => {
      let a = !1;
      const l = e.s;
      for (const c in l)
        l[c] !== s[c] && (s[c] = l[c], a = !0);
      return a && r++, r;
    });
    n = () => te(o);
  }
  t.b.length && Cv(() => {
    hd(e, n), nh(t.b);
  }), lr(() => {
    const r = rn(() => t.m.map(By));
    return () => {
      for (const s of r)
        typeof s == "function" && s();
    };
  }), t.a.length && lr(() => {
    hd(e, n), nh(t.a);
  });
}
function hd(i, e) {
  if (i.l.s)
    for (const t of i.l.s) te(t);
  e();
}
const $r = [];
function hS(i, e) {
  return {
    subscribe: fS(i, e).subscribe
  };
}
function fS(i, e = zi) {
  let t = null;
  const n = /* @__PURE__ */ new Set();
  function r(a) {
    if (_f(i, a) && (i = a, t)) {
      const l = !$r.length;
      for (const c of n)
        c[1](), $r.push(c, i);
      if (l) {
        for (let c = 0; c < $r.length; c += 2)
          $r[c][0]($r[c + 1]);
        $r.length = 0;
      }
    }
  }
  function s(a) {
    r(a(
      /** @type {T} */
      i
    ));
  }
  function o(a, l = zi) {
    const c = [a, l];
    return n.add(c), n.size === 1 && (t = e(r, s) || zi), a(
      /** @type {T} */
      i
    ), () => {
      n.delete(c), n.size === 0 && t && (t(), t = null);
    };
  }
  return { set: r, update: s, subscribe: o };
}
let Lo = !1;
function uS(i) {
  var e = Lo;
  try {
    return Lo = !1, [i(), Lo];
  } finally {
    Lo = e;
  }
}
function Cn(i, e, t, n) {
  var r = !fs || (t & nv) !== 0, s = (t & sv) !== 0, o = (t & ov) !== 0, a = (
    /** @type {V} */
    n
  ), l = !0, c = () => (l && (l = !1, a = o ? rn(
    /** @type {() => V} */
    n
  ) : (
    /** @type {V} */
    n
  )), a), h;
  if (s) {
    var f = ar in i || Yy in i;
    h = or(i, e)?.set ?? (f && e in i ? (S) => i[e] = S : void 0);
  }
  var u, d = !1;
  s ? [u, d] = uS(() => (
    /** @type {V} */
    i[e]
  )) : u = /** @type {V} */
  i[e], u === void 0 && n !== void 0 && (u = c(), h && (r && Gy(), h(u)));
  var p;
  if (r ? p = () => {
    var S = (
      /** @type {V} */
      i[e]
    );
    return S === void 0 ? c() : (l = !0, S);
  } : p = () => {
    var S = (
      /** @type {V} */
      i[e]
    );
    return S !== void 0 && (a = /** @type {V} */
    void 0), S === void 0 ? a : S;
  }, r && (t & rv) === 0)
    return p;
  if (h) {
    var O = i.$$legacy;
    return (
      /** @type {() => V} */
      (function(S, w) {
        return arguments.length > 0 ? ((!r || !w || O || d) && h(w ? p() : S), S) : p();
      })
    );
  }
  var m = !1, g = ((t & iv) !== 0 ? Qo : Pf)(() => (m = !1, p()));
  s && te(g);
  var v = (
    /** @type {Effect} */
    Ae
  );
  return (
    /** @type {() => V} */
    (function(S, w) {
      if (arguments.length > 0) {
        const x = w ? te(g) : r && s ? li(S) : S;
        return Pe(g, x), m = !0, a !== void 0 && (a = x), S;
      }
      return wr && m || (v.f & Zn) !== 0 ? g.v : te(g);
    })
  );
}
function ig(i) {
  je === null && Qf(), fs && je.l !== null ? mS(je).m.push(i) : lr(() => {
    const e = rn(i);
    if (typeof e == "function") return (
      /** @type {() => void} */
      e
    );
  });
}
function dS(i) {
  je === null && Qf(), ig(() => () => rn(i));
}
function pS(i, e, { bubbles: t = !1, cancelable: n = !1 } = {}) {
  return new CustomEvent(i, { detail: e, bubbles: t, cancelable: n });
}
function OS() {
  const i = je;
  return i === null && Qf(), (e, t, n) => {
    const r = (
      /** @type {Record<string, Function | Function[]>} */
      i.s.$$events?.[
        /** @type {string} */
        e
      ]
    );
    if (r) {
      const s = vf(r) ? r.slice() : [r], o = pS(
        /** @type {string} */
        e,
        t,
        n
      );
      for (const a of s)
        a.call(i.x, o);
      return !o.defaultPrevented;
    }
    return !0;
  };
}
function mS(i) {
  var e = (
    /** @type {ComponentContextLegacy} */
    i.l
  );
  return e.u ??= { a: [], b: [], m: [] };
}
const gS = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(gS);
function fd(i) {
  return Object.prototype.toString.call(i) === "[object Date]";
}
function uh(i, e, t, n) {
  if (typeof t == "number" || fd(t)) {
    const r = n - t, s = (t - e) / (i.dt || 1 / 60), o = i.opts.stiffness * r, a = i.opts.damping * s, l = (o - a) * i.inv_mass, c = (s + l) * i.dt;
    return Math.abs(c) < i.opts.precision && Math.abs(r) < i.opts.precision ? n : (i.settled = !1, fd(t) ? new Date(t.getTime() + c) : t + c);
  } else {
    if (Array.isArray(t))
      return t.map(
        (r, s) => (
          // @ts-ignore
          uh(i, e[s], t[s], n[s])
        )
      );
    if (typeof t == "object") {
      const r = {};
      for (const s in t)
        r[s] = uh(i, e[s], t[s], n[s]);
      return r;
    } else
      throw new Error(`Cannot spring ${typeof t} values`);
  }
}
class Xf {
  #e = /* @__PURE__ */ qe(0.15);
  #t = /* @__PURE__ */ qe(0.8);
  #n = /* @__PURE__ */ qe(0.01);
  #i;
  #l;
  #s = (
    /** @type {T} */
    void 0
  );
  #o = 0;
  #r = 1;
  #a = 0;
  /** @type {import('../internal/client/types').Task | null} */
  #c = null;
  /** @type {ReturnType<typeof deferred> | null} */
  #h = null;
  /**
   * @param {T} value
   * @param {SpringOpts} [options]
   */
  constructor(e, t = {}) {
    this.#i = /* @__PURE__ */ qe(e), this.#l = /* @__PURE__ */ qe(e), typeof t.stiffness == "number" && (this.#e.v = Io(t.stiffness, 0, 1)), typeof t.damping == "number" && (this.#t.v = Io(t.damping, 0, 1)), typeof t.precision == "number" && (this.#n.v = t.precision);
  }
  /**
   * Create a spring whose value is bound to the return value of `fn`. This must be called
   * inside an effect root (for example, during component initialisation).
   *
   * ```svelte
   * <script>
   * 	import { Spring } from 'svelte/motion';
   *
   * 	let { number } = $props();
   *
   * 	const spring = Spring.of(() => number);
   * <\/script>
   * ```
   * @template U
   * @param {() => U} fn
   * @param {SpringOpts} [options]
   */
  static of(e, t) {
    const n = new Xf(e(), t);
    return qn(() => {
      n.set(e());
    }), n;
  }
  /** @param {T} value */
  #f(e) {
    if (Pe(this.#l, e), this.#i.v ??= e, this.#s ??= this.#i.v, !this.#c) {
      this.#o = Li.now();
      var t = 1e3 / (this.#a * 60);
      this.#c ??= tg((n) => {
        this.#r = Math.min(this.#r + t, 1);
        const r = Math.min(n - this.#o, 1e3 / 30), s = {
          inv_mass: this.#r,
          opts: {
            stiffness: this.#e.v,
            damping: this.#t.v,
            precision: this.#n.v
          },
          settled: !0,
          dt: r * 60 / 1e3
        };
        var o = uh(s, this.#s, this.#i.v, this.#l.v);
        return this.#s = this.#i.v, this.#o = n, Pe(this.#i, o), s.settled && (this.#c = null), !s.settled;
      });
    }
    return this.#c.promise;
  }
  /**
   * Sets `spring.target` to `value` and returns a `Promise` that resolves if and when `spring.current` catches up to it.
   *
   * If `options.instant` is `true`, `spring.current` immediately matches `spring.target`.
   *
   * If `options.preserveMomentum` is provided, the spring will continue on its current trajectory for
   * the specified number of milliseconds. This is useful for things like 'fling' gestures.
   *
   * @param {T} value
   * @param {SpringUpdateOpts} [options]
   */
  set(e, t) {
    if (this.#h?.reject(new Error("Aborted")), t?.instant || this.#i.v === void 0)
      return this.#c?.abort(), this.#c = null, Pe(this.#i, Pe(this.#l, e)), this.#s = e, Promise.resolve();
    t?.preserveMomentum && (this.#r = 0, this.#a = t.preserveMomentum);
    var n = this.#h = xf();
    return n.promise.catch(zi), this.#f(e).then(() => {
      n === this.#h && n.resolve(void 0);
    }), n.promise;
  }
  get current() {
    return te(this.#i);
  }
  get damping() {
    return te(this.#t);
  }
  set damping(e) {
    Pe(this.#t, Io(e, 0, 1));
  }
  get precision() {
    return te(this.#n);
  }
  set precision(e) {
    Pe(this.#n, e);
  }
  get stiffness() {
    return te(this.#e);
  }
  set stiffness(e) {
    Pe(this.#e, Io(e, 0, 1));
  }
  get target() {
    return te(this.#l);
  }
  set target(e) {
    this.set(e);
  }
}
function Io(i, e, t) {
  return Math.max(e, Math.min(t, i));
}
const ng = "(prefers-reduced-motion: reduce)", bS = () => window.matchMedia(ng).matches, yS = hS(bS(), (i) => {
  const e = (n) => {
    i(n.matches);
  }, t = window.matchMedia(ng);
  return t.addEventListener("change", e), () => {
    t.removeEventListener("change", e);
  };
});
var vS = /* @__PURE__ */ ri('<div class="cat-container svelte-9r2m2c"><img src="/assets/site-assets/icon.png" alt="â‚^â €â €â €â €^â‚Ž" class="pixelated-img svelte-9r2m2c" draggable="false"/> <img src="/assets/site-assets/eyes.png" alt="O - O" class="pixelated-img eyes svelte-9r2m2c" draggable="false"/></div>');
const SS = {
  hash: "svelte-9r2m2c",
  code: ".cat-container.svelte-9r2m2c {height:4rem;width:4rem;position:relative;}.cat-container.svelte-9r2m2c img:where(.svelte-9r2m2c) {position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:100%;width:100%;}.cat-container.svelte-9r2m2c .eyes:where(.svelte-9r2m2c) {top:52%;left:52%;}"
};
function wS(i, e) {
  us(e, !0), Hm(i, SS);
  let t = /* @__PURE__ */ qe(void 0), n = new Xf({ x: 0, y: 0 }, { stiffness: 0.05, damping: 0.5 }), r = /* @__PURE__ */ qe("transform(-50%, -48%)");
  lr(() => {
    Pe(r, `translate(-50%, -48%) translate(${n.current.x}px, ${n.current.y}px)`);
  });
  function s(c) {
    if (!te(t) || !yS) return;
    const h = te(t).getBoundingClientRect(), f = h.left + h.width / 2, u = h.top + h.height / 2, d = c.clientX - f, p = c.clientY - u, O = Math.sqrt(d * d + p * p), g = Math.min(O, 7), v = Math.atan2(p, d), S = Math.cos(v) * g, w = Math.sin(v) * g;
    n.target = { x: S, y: w };
  }
  var o = vS();
  Bv("mousemove", xm.body, s);
  var a = Ze(Ee(o), 2);
  let l;
  Pl(a, (c) => Pe(t, c), () => te(t)), xi(() => l = Ia(a, "", l, { transform: te(r) })), qt(i, o), ds();
}
function zf(i) {
  return new Promise((e, t) => {
    i.oncomplete = i.onsuccess = () => e(i.result), i.onabort = i.onerror = () => t(i.error);
  });
}
function rg(i, e) {
  let t;
  const n = () => {
    if (t)
      return t;
    const r = indexedDB.open(i);
    return r.onupgradeneeded = () => r.result.createObjectStore(e), t = zf(r), t.then((s) => {
      s.onclose = () => t = void 0;
    }, () => {
    }), t;
  };
  return (r, s) => n().then((o) => s(o.transaction(e, r).objectStore(e)));
}
let tc;
function sg() {
  return tc || (tc = rg("keyval-store", "keyval")), tc;
}
function ic(i, e = sg()) {
  return e("readonly", (t) => zf(t.get(i)));
}
function xS(i, e, t = sg()) {
  return t("readwrite", (n) => (n.put(e, i), zf(n.transaction)));
}
class kS {
  #e;
  constructor() {
    this.#e = rg("article-editor", "images");
  }
  async createKey(e) {
    const t = e.name.match(/^(.*)\.([^.]*)$/);
    let [, n = "unknown", r = ""] = t || [];
    n = n.replaceAll(" ", "-");
    let s = `${n}.${r}`, o = 1;
    for (; await ic(s, this.#e) !== void 0; )
      s = `${n}-(${o}).${r}`, o++;
    return s;
  }
  async add(e, t) {
    await xS(e, t, this.#e);
  }
  async get(e) {
    const t = await ic(e, this.#e);
    if (t)
      return URL.createObjectURL(t);
  }
  async getBlob(e) {
    return await ic(e, this.#e);
  }
}
const {
  entries: og,
  setPrototypeOf: ud,
  isFrozen: QS,
  getPrototypeOf: _S,
  getOwnPropertyDescriptor: PS
} = Object;
let {
  freeze: Xt,
  seal: pi,
  create: dh
} = Object, {
  apply: ph,
  construct: Oh
} = typeof Reflect < "u" && Reflect;
Xt || (Xt = function(e) {
  return e;
});
pi || (pi = function(e) {
  return e;
});
ph || (ph = function(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), s = 2; s < n; s++)
    r[s - 2] = arguments[s];
  return e.apply(t, r);
});
Oh || (Oh = function(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return new e(...n);
});
const Bo = zt(Array.prototype.forEach), $S = zt(Array.prototype.lastIndexOf), dd = zt(Array.prototype.pop), _s = zt(Array.prototype.push), TS = zt(Array.prototype.splice), va = zt(String.prototype.toLowerCase), nc = zt(String.prototype.toString), rc = zt(String.prototype.match), Ps = zt(String.prototype.replace), CS = zt(String.prototype.indexOf), AS = zt(String.prototype.trim), bi = zt(Object.prototype.hasOwnProperty), Tt = zt(RegExp.prototype.test), $s = RS(TypeError);
function zt(i) {
  return function(e) {
    e instanceof RegExp && (e.lastIndex = 0);
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      n[r - 1] = arguments[r];
    return ph(i, e, n);
  };
}
function RS(i) {
  return function() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return Oh(i, t);
  };
}
function xe(i, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : va;
  ud && ud(i, null);
  let n = e.length;
  for (; n--; ) {
    let r = e[n];
    if (typeof r == "string") {
      const s = t(r);
      s !== r && (QS(e) || (e[n] = s), r = s);
    }
    i[r] = !0;
  }
  return i;
}
function ES(i) {
  for (let e = 0; e < i.length; e++)
    bi(i, e) || (i[e] = null);
  return i;
}
function fn(i) {
  const e = dh(null);
  for (const [t, n] of og(i))
    bi(i, t) && (Array.isArray(n) ? e[t] = ES(n) : n && typeof n == "object" && n.constructor === Object ? e[t] = fn(n) : e[t] = n);
  return e;
}
function Ts(i, e) {
  for (; i !== null; ) {
    const n = PS(i, e);
    if (n) {
      if (n.get)
        return zt(n.get);
      if (typeof n.value == "function")
        return zt(n.value);
    }
    i = _S(i);
  }
  function t() {
    return null;
  }
  return t;
}
const pd = Xt(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), sc = Xt(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), oc = Xt(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), MS = Xt(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), ac = Xt(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), ZS = Xt(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Od = Xt(["#text"]), md = Xt(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), lc = Xt(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), gd = Xt(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Yo = Xt(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), XS = pi(/\{\{[\w\W]*|[\w\W]*\}\}/gm), zS = pi(/<%[\w\W]*|[\w\W]*%>/gm), DS = pi(/\$\{[\w\W]*/gm), LS = pi(/^data-[\-\w.\u00B7-\uFFFF]+$/), IS = pi(/^aria-[\-\w]+$/), ag = pi(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), BS = pi(/^(?:\w+script|data):/i), YS = pi(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), lg = pi(/^html$/i), NS = pi(/^[a-z][.\w]*(-[.\w]+)+$/i);
var bd = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: IS,
  ATTR_WHITESPACE: YS,
  CUSTOM_ELEMENT: NS,
  DATA_ATTR: LS,
  DOCTYPE_NAME: lg,
  ERB_EXPR: zS,
  IS_ALLOWED_URI: ag,
  IS_SCRIPT_OR_DATA: BS,
  MUSTACHE_EXPR: XS,
  TMPLIT_EXPR: DS
});
const Cs = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, VS = function() {
  return typeof window > "u" ? null : window;
}, qS = function(e, t) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let n = null;
  const r = "data-tt-policy-suffix";
  t && t.hasAttribute(r) && (n = t.getAttribute(r));
  const s = "dompurify" + (n ? "#" + n : "");
  try {
    return e.createPolicy(s, {
      createHTML(o) {
        return o;
      },
      createScriptURL(o) {
        return o;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
}, yd = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function cg() {
  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : VS();
  const e = (de) => cg(de);
  if (e.version = "3.3.0", e.removed = [], !i || !i.document || i.document.nodeType !== Cs.document || !i.Element)
    return e.isSupported = !1, e;
  let {
    document: t
  } = i;
  const n = t, r = n.currentScript, {
    DocumentFragment: s,
    HTMLTemplateElement: o,
    Node: a,
    Element: l,
    NodeFilter: c,
    NamedNodeMap: h = i.NamedNodeMap || i.MozNamedAttrMap,
    HTMLFormElement: f,
    DOMParser: u,
    trustedTypes: d
  } = i, p = l.prototype, O = Ts(p, "cloneNode"), m = Ts(p, "remove"), g = Ts(p, "nextSibling"), v = Ts(p, "childNodes"), S = Ts(p, "parentNode");
  if (typeof o == "function") {
    const de = t.createElement("template");
    de.content && de.content.ownerDocument && (t = de.content.ownerDocument);
  }
  let w, x = "";
  const {
    implementation: P,
    createNodeIterator: k,
    createDocumentFragment: A,
    getElementsByTagName: C
  } = t, {
    importNode: Z
  } = n;
  let I = yd();
  e.isSupported = typeof og == "function" && typeof S == "function" && P && P.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: Q,
    ERB_EXPR: E,
    TMPLIT_EXPR: y,
    DATA_ATTR: L,
    ARIA_ATTR: se,
    IS_SCRIPT_OR_DATA: V,
    ATTR_WHITESPACE: fe,
    CUSTOM_ELEMENT: W
  } = bd;
  let {
    IS_ALLOWED_URI: ce
  } = bd, z = null;
  const D = xe({}, [...pd, ...sc, ...oc, ...ac, ...Od]);
  let J = null;
  const ie = xe({}, [...md, ...lc, ...gd, ...Yo]);
  let U = Object.seal(dh(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Qe = null, Ie = null;
  const be = Object.seal(dh(null, {
    tagCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    }
  }));
  let _e = !0, Ue = !0, Be = !1, $t = !0, Je = !1, b = !0, N = !1, Y = !1, $ = !1, _ = !1, M = !1, j = !1, B = !0, X = !1;
  const G = "user-content-";
  let ee = !0, F = !1, oe = {}, me = null;
  const Oe = xe({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let Me = null;
  const Lt = xe({}, ["audio", "video", "img", "source", "image", "track"]);
  let at = null;
  const Ti = xe({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Xe = "http://www.w3.org/1998/Math/MathML", on = "http://www.w3.org/2000/svg", Ut = "http://www.w3.org/1999/xhtml";
  let yt = Ut, xr = !1, Qs = null;
  const Wl = xe({}, [Xe, on, Ut], nc);
  let kr = xe({}, ["mi", "mo", "mn", "ms", "mtext"]), Fn = xe({}, ["annotation-xml"]);
  const Hn = xe({}, ["title", "style", "font", "a", "script"]);
  let Ci = null;
  const Ay = ["application/xhtml+xml", "text/html"], Ry = "text/html";
  let ct = null, Qr = null;
  const Ey = t.createElement("form"), zu = function(R) {
    return R instanceof RegExp || R instanceof Function;
  }, jl = function() {
    let R = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(Qr && Qr === R)) {
      if ((!R || typeof R != "object") && (R = {}), R = fn(R), Ci = // eslint-disable-next-line unicorn/prefer-includes
      Ay.indexOf(R.PARSER_MEDIA_TYPE) === -1 ? Ry : R.PARSER_MEDIA_TYPE, ct = Ci === "application/xhtml+xml" ? nc : va, z = bi(R, "ALLOWED_TAGS") ? xe({}, R.ALLOWED_TAGS, ct) : D, J = bi(R, "ALLOWED_ATTR") ? xe({}, R.ALLOWED_ATTR, ct) : ie, Qs = bi(R, "ALLOWED_NAMESPACES") ? xe({}, R.ALLOWED_NAMESPACES, nc) : Wl, at = bi(R, "ADD_URI_SAFE_ATTR") ? xe(fn(Ti), R.ADD_URI_SAFE_ATTR, ct) : Ti, Me = bi(R, "ADD_DATA_URI_TAGS") ? xe(fn(Lt), R.ADD_DATA_URI_TAGS, ct) : Lt, me = bi(R, "FORBID_CONTENTS") ? xe({}, R.FORBID_CONTENTS, ct) : Oe, Qe = bi(R, "FORBID_TAGS") ? xe({}, R.FORBID_TAGS, ct) : fn({}), Ie = bi(R, "FORBID_ATTR") ? xe({}, R.FORBID_ATTR, ct) : fn({}), oe = bi(R, "USE_PROFILES") ? R.USE_PROFILES : !1, _e = R.ALLOW_ARIA_ATTR !== !1, Ue = R.ALLOW_DATA_ATTR !== !1, Be = R.ALLOW_UNKNOWN_PROTOCOLS || !1, $t = R.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Je = R.SAFE_FOR_TEMPLATES || !1, b = R.SAFE_FOR_XML !== !1, N = R.WHOLE_DOCUMENT || !1, _ = R.RETURN_DOM || !1, M = R.RETURN_DOM_FRAGMENT || !1, j = R.RETURN_TRUSTED_TYPE || !1, $ = R.FORCE_BODY || !1, B = R.SANITIZE_DOM !== !1, X = R.SANITIZE_NAMED_PROPS || !1, ee = R.KEEP_CONTENT !== !1, F = R.IN_PLACE || !1, ce = R.ALLOWED_URI_REGEXP || ag, yt = R.NAMESPACE || Ut, kr = R.MATHML_TEXT_INTEGRATION_POINTS || kr, Fn = R.HTML_INTEGRATION_POINTS || Fn, U = R.CUSTOM_ELEMENT_HANDLING || {}, R.CUSTOM_ELEMENT_HANDLING && zu(R.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (U.tagNameCheck = R.CUSTOM_ELEMENT_HANDLING.tagNameCheck), R.CUSTOM_ELEMENT_HANDLING && zu(R.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (U.attributeNameCheck = R.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), R.CUSTOM_ELEMENT_HANDLING && typeof R.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (U.allowCustomizedBuiltInElements = R.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Je && (Ue = !1), M && (_ = !0), oe && (z = xe({}, Od), J = [], oe.html === !0 && (xe(z, pd), xe(J, md)), oe.svg === !0 && (xe(z, sc), xe(J, lc), xe(J, Yo)), oe.svgFilters === !0 && (xe(z, oc), xe(J, lc), xe(J, Yo)), oe.mathMl === !0 && (xe(z, ac), xe(J, gd), xe(J, Yo))), R.ADD_TAGS && (typeof R.ADD_TAGS == "function" ? be.tagCheck = R.ADD_TAGS : (z === D && (z = fn(z)), xe(z, R.ADD_TAGS, ct))), R.ADD_ATTR && (typeof R.ADD_ATTR == "function" ? be.attributeCheck = R.ADD_ATTR : (J === ie && (J = fn(J)), xe(J, R.ADD_ATTR, ct))), R.ADD_URI_SAFE_ATTR && xe(at, R.ADD_URI_SAFE_ATTR, ct), R.FORBID_CONTENTS && (me === Oe && (me = fn(me)), xe(me, R.FORBID_CONTENTS, ct)), ee && (z["#text"] = !0), N && xe(z, ["html", "head", "body"]), z.table && (xe(z, ["tbody"]), delete Qe.tbody), R.TRUSTED_TYPES_POLICY) {
        if (typeof R.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw $s('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof R.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw $s('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        w = R.TRUSTED_TYPES_POLICY, x = w.createHTML("");
      } else
        w === void 0 && (w = qS(d, r)), w !== null && typeof x == "string" && (x = w.createHTML(""));
      Xt && Xt(R), Qr = R;
    }
  }, Du = xe({}, [...sc, ...oc, ...MS]), Lu = xe({}, [...ac, ...ZS]), My = function(R) {
    let K = S(R);
    (!K || !K.tagName) && (K = {
      namespaceURI: yt,
      tagName: "template"
    });
    const he = va(R.tagName), Ge = va(K.tagName);
    return Qs[R.namespaceURI] ? R.namespaceURI === on ? K.namespaceURI === Ut ? he === "svg" : K.namespaceURI === Xe ? he === "svg" && (Ge === "annotation-xml" || kr[Ge]) : !!Du[he] : R.namespaceURI === Xe ? K.namespaceURI === Ut ? he === "math" : K.namespaceURI === on ? he === "math" && Fn[Ge] : !!Lu[he] : R.namespaceURI === Ut ? K.namespaceURI === on && !Fn[Ge] || K.namespaceURI === Xe && !kr[Ge] ? !1 : !Lu[he] && (Hn[he] || !Du[he]) : !!(Ci === "application/xhtml+xml" && Qs[R.namespaceURI]) : !1;
  }, Ai = function(R) {
    _s(e.removed, {
      element: R
    });
    try {
      S(R).removeChild(R);
    } catch {
      m(R);
    }
  }, Kn = function(R, K) {
    try {
      _s(e.removed, {
        attribute: K.getAttributeNode(R),
        from: K
      });
    } catch {
      _s(e.removed, {
        attribute: null,
        from: K
      });
    }
    if (K.removeAttribute(R), R === "is")
      if (_ || M)
        try {
          Ai(K);
        } catch {
        }
      else
        try {
          K.setAttribute(R, "");
        } catch {
        }
  }, Iu = function(R) {
    let K = null, he = null;
    if ($)
      R = "<remove></remove>" + R;
    else {
      const tt = rc(R, /^[\r\n\t ]+/);
      he = tt && tt[0];
    }
    Ci === "application/xhtml+xml" && yt === Ut && (R = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + R + "</body></html>");
    const Ge = w ? w.createHTML(R) : R;
    if (yt === Ut)
      try {
        K = new u().parseFromString(Ge, Ci);
      } catch {
      }
    if (!K || !K.documentElement) {
      K = P.createDocument(yt, "template", null);
      try {
        K.documentElement.innerHTML = xr ? x : Ge;
      } catch {
      }
    }
    const vt = K.body || K.documentElement;
    return R && he && vt.insertBefore(t.createTextNode(he), vt.childNodes[0] || null), yt === Ut ? C.call(K, N ? "html" : "body")[0] : N ? K.documentElement : vt;
  }, Bu = function(R) {
    return k.call(
      R.ownerDocument || R,
      R,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, Ul = function(R) {
    return R instanceof f && (typeof R.nodeName != "string" || typeof R.textContent != "string" || typeof R.removeChild != "function" || !(R.attributes instanceof h) || typeof R.removeAttribute != "function" || typeof R.setAttribute != "function" || typeof R.namespaceURI != "string" || typeof R.insertBefore != "function" || typeof R.hasChildNodes != "function");
  }, Yu = function(R) {
    return typeof a == "function" && R instanceof a;
  };
  function an(de, R, K) {
    Bo(de, (he) => {
      he.call(e, R, K, Qr);
    });
  }
  const Nu = function(R) {
    let K = null;
    if (an(I.beforeSanitizeElements, R, null), Ul(R))
      return Ai(R), !0;
    const he = ct(R.nodeName);
    if (an(I.uponSanitizeElement, R, {
      tagName: he,
      allowedTags: z
    }), b && R.hasChildNodes() && !Yu(R.firstElementChild) && Tt(/<[/\w!]/g, R.innerHTML) && Tt(/<[/\w!]/g, R.textContent) || R.nodeType === Cs.progressingInstruction || b && R.nodeType === Cs.comment && Tt(/<[/\w]/g, R.data))
      return Ai(R), !0;
    if (!(be.tagCheck instanceof Function && be.tagCheck(he)) && (!z[he] || Qe[he])) {
      if (!Qe[he] && qu(he) && (U.tagNameCheck instanceof RegExp && Tt(U.tagNameCheck, he) || U.tagNameCheck instanceof Function && U.tagNameCheck(he)))
        return !1;
      if (ee && !me[he]) {
        const Ge = S(R) || R.parentNode, vt = v(R) || R.childNodes;
        if (vt && Ge) {
          const tt = vt.length;
          for (let It = tt - 1; It >= 0; --It) {
            const ln = O(vt[It], !0);
            ln.__removalCount = (R.__removalCount || 0) + 1, Ge.insertBefore(ln, g(R));
          }
        }
      }
      return Ai(R), !0;
    }
    return R instanceof l && !My(R) || (he === "noscript" || he === "noembed" || he === "noframes") && Tt(/<\/no(script|embed|frames)/i, R.innerHTML) ? (Ai(R), !0) : (Je && R.nodeType === Cs.text && (K = R.textContent, Bo([Q, E, y], (Ge) => {
      K = Ps(K, Ge, " ");
    }), R.textContent !== K && (_s(e.removed, {
      element: R.cloneNode()
    }), R.textContent = K)), an(I.afterSanitizeElements, R, null), !1);
  }, Vu = function(R, K, he) {
    if (B && (K === "id" || K === "name") && (he in t || he in Ey))
      return !1;
    if (!(Ue && !Ie[K] && Tt(L, K))) {
      if (!(_e && Tt(se, K))) {
        if (!(be.attributeCheck instanceof Function && be.attributeCheck(K, R))) {
          if (!J[K] || Ie[K]) {
            if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              !(qu(R) && (U.tagNameCheck instanceof RegExp && Tt(U.tagNameCheck, R) || U.tagNameCheck instanceof Function && U.tagNameCheck(R)) && (U.attributeNameCheck instanceof RegExp && Tt(U.attributeNameCheck, K) || U.attributeNameCheck instanceof Function && U.attributeNameCheck(K, R)) || // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              K === "is" && U.allowCustomizedBuiltInElements && (U.tagNameCheck instanceof RegExp && Tt(U.tagNameCheck, he) || U.tagNameCheck instanceof Function && U.tagNameCheck(he)))
            ) return !1;
          } else if (!at[K]) {
            if (!Tt(ce, Ps(he, fe, ""))) {
              if (!((K === "src" || K === "xlink:href" || K === "href") && R !== "script" && CS(he, "data:") === 0 && Me[R])) {
                if (!(Be && !Tt(V, Ps(he, fe, "")))) {
                  if (he)
                    return !1;
                }
              }
            }
          }
        }
      }
    }
    return !0;
  }, qu = function(R) {
    return R !== "annotation-xml" && rc(R, W);
  }, Wu = function(R) {
    an(I.beforeSanitizeAttributes, R, null);
    const {
      attributes: K
    } = R;
    if (!K || Ul(R))
      return;
    const he = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: J,
      forceKeepAttr: void 0
    };
    let Ge = K.length;
    for (; Ge--; ) {
      const vt = K[Ge], {
        name: tt,
        namespaceURI: It,
        value: ln
      } = vt, _r = ct(tt), Gl = ln;
      let ut = tt === "value" ? Gl : AS(Gl);
      if (he.attrName = _r, he.attrValue = ut, he.keepAttr = !0, he.forceKeepAttr = void 0, an(I.uponSanitizeAttribute, R, he), ut = he.attrValue, X && (_r === "id" || _r === "name") && (Kn(tt, R), ut = G + ut), b && Tt(/((--!?|])>)|<\/(style|title|textarea)/i, ut)) {
        Kn(tt, R);
        continue;
      }
      if (_r === "attributename" && rc(ut, "href")) {
        Kn(tt, R);
        continue;
      }
      if (he.forceKeepAttr)
        continue;
      if (!he.keepAttr) {
        Kn(tt, R);
        continue;
      }
      if (!$t && Tt(/\/>/i, ut)) {
        Kn(tt, R);
        continue;
      }
      Je && Bo([Q, E, y], (Uu) => {
        ut = Ps(ut, Uu, " ");
      });
      const ju = ct(R.nodeName);
      if (!Vu(ju, _r, ut)) {
        Kn(tt, R);
        continue;
      }
      if (w && typeof d == "object" && typeof d.getAttributeType == "function" && !It)
        switch (d.getAttributeType(ju, _r)) {
          case "TrustedHTML": {
            ut = w.createHTML(ut);
            break;
          }
          case "TrustedScriptURL": {
            ut = w.createScriptURL(ut);
            break;
          }
        }
      if (ut !== Gl)
        try {
          It ? R.setAttributeNS(It, tt, ut) : R.setAttribute(tt, ut), Ul(R) ? Ai(R) : dd(e.removed);
        } catch {
          Kn(tt, R);
        }
    }
    an(I.afterSanitizeAttributes, R, null);
  }, Zy = function de(R) {
    let K = null;
    const he = Bu(R);
    for (an(I.beforeSanitizeShadowDOM, R, null); K = he.nextNode(); )
      an(I.uponSanitizeShadowNode, K, null), Nu(K), Wu(K), K.content instanceof s && de(K.content);
    an(I.afterSanitizeShadowDOM, R, null);
  };
  return e.sanitize = function(de) {
    let R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, K = null, he = null, Ge = null, vt = null;
    if (xr = !de, xr && (de = "<!-->"), typeof de != "string" && !Yu(de))
      if (typeof de.toString == "function") {
        if (de = de.toString(), typeof de != "string")
          throw $s("dirty is not a string, aborting");
      } else
        throw $s("toString is not a function");
    if (!e.isSupported)
      return de;
    if (Y || jl(R), e.removed = [], typeof de == "string" && (F = !1), F) {
      if (de.nodeName) {
        const ln = ct(de.nodeName);
        if (!z[ln] || Qe[ln])
          throw $s("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (de instanceof a)
      K = Iu("<!---->"), he = K.ownerDocument.importNode(de, !0), he.nodeType === Cs.element && he.nodeName === "BODY" || he.nodeName === "HTML" ? K = he : K.appendChild(he);
    else {
      if (!_ && !Je && !N && // eslint-disable-next-line unicorn/prefer-includes
      de.indexOf("<") === -1)
        return w && j ? w.createHTML(de) : de;
      if (K = Iu(de), !K)
        return _ ? null : j ? x : "";
    }
    K && $ && Ai(K.firstChild);
    const tt = Bu(F ? de : K);
    for (; Ge = tt.nextNode(); )
      Nu(Ge), Wu(Ge), Ge.content instanceof s && Zy(Ge.content);
    if (F)
      return de;
    if (_) {
      if (M)
        for (vt = A.call(K.ownerDocument); K.firstChild; )
          vt.appendChild(K.firstChild);
      else
        vt = K;
      return (J.shadowroot || J.shadowrootmode) && (vt = Z.call(n, vt, !0)), vt;
    }
    let It = N ? K.outerHTML : K.innerHTML;
    return N && z["!doctype"] && K.ownerDocument && K.ownerDocument.doctype && K.ownerDocument.doctype.name && Tt(lg, K.ownerDocument.doctype.name) && (It = "<!DOCTYPE " + K.ownerDocument.doctype.name + `>
` + It), Je && Bo([Q, E, y], (ln) => {
      It = Ps(It, ln, " ");
    }), w && j ? w.createHTML(It) : It;
  }, e.setConfig = function() {
    let de = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    jl(de), Y = !0;
  }, e.clearConfig = function() {
    Qr = null, Y = !1;
  }, e.isValidAttribute = function(de, R, K) {
    Qr || jl({});
    const he = ct(de), Ge = ct(R);
    return Vu(he, Ge, K);
  }, e.addHook = function(de, R) {
    typeof R == "function" && _s(I[de], R);
  }, e.removeHook = function(de, R) {
    if (R !== void 0) {
      const K = $S(I[de], R);
      return K === -1 ? void 0 : TS(I[de], K, 1)[0];
    }
    return dd(I[de]);
  }, e.removeHooks = function(de) {
    I[de] = [];
  }, e.removeAllHooks = function() {
    I = yd();
  }, e;
}
var WS = cg(), jS = /* @__PURE__ */ ri("<span> </span>"), US = /* @__PURE__ */ ri('<h1 class="article-title"> </h1> <div class="article-card-tags"></div> <div class="article-info"><p class="article-info-item"> </p> <p class="article-info-item"> </p></div> <hr/>', 1);
function GS(i, e) {
  var t = US(), n = Pm(t), r = Ee(n), s = Ze(n, 2);
  Zf(s, 21, () => e.tags, Mf, (f, u) => {
    var d = jS(), p = Ee(d);
    xi(
      (O) => {
        Jm(d, 1, `tag-${O ?? ""}`), mn(p, te(u).name);
      },
      [() => te(u).color.toLowerCase()]
    ), qt(f, d);
  });
  var o = Ze(s, 2), a = Ee(o), l = Ee(a), c = Ze(a, 2), h = Ee(c);
  xi(() => {
    mn(r, e.title), mn(l, e.date), mn(h, `By ${e.author ?? ""}`);
  }), qt(i, t);
}
dv();
let mh = [], hg = [];
(() => {
  let i = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, t = 0; e < i.length; e++)
    (e % 2 ? hg : mh).push(t = t + i[e]);
})();
function FS(i) {
  if (i < 768) return !1;
  for (let e = 0, t = mh.length; ; ) {
    let n = e + t >> 1;
    if (i < mh[n]) t = n;
    else if (i >= hg[n]) e = n + 1;
    else return !0;
    if (e == t) return !1;
  }
}
function vd(i) {
  return i >= 127462 && i <= 127487;
}
const Sd = 8205;
function HS(i, e, t = !0, n = !0) {
  return (t ? fg : KS)(i, e, n);
}
function fg(i, e, t) {
  if (e == i.length) return e;
  e && ug(i.charCodeAt(e)) && dg(i.charCodeAt(e - 1)) && e--;
  let n = cc(i, e);
  for (e += wd(n); e < i.length; ) {
    let r = cc(i, e);
    if (n == Sd || r == Sd || t && FS(r))
      e += wd(r), n = r;
    else if (vd(r)) {
      let s = 0, o = e - 2;
      for (; o >= 0 && vd(cc(i, o)); )
        s++, o -= 2;
      if (s % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function KS(i, e, t) {
  for (; e > 0; ) {
    let n = fg(i, e - 2, t);
    if (n < e) return n;
    e--;
  }
  return 0;
}
function cc(i, e) {
  let t = i.charCodeAt(e);
  if (!dg(t) || e + 1 == i.length) return t;
  let n = i.charCodeAt(e + 1);
  return ug(n) ? (t - 55296 << 10) + (n - 56320) + 65536 : t;
}
function ug(i) {
  return i >= 56320 && i < 57344;
}
function dg(i) {
  return i >= 55296 && i < 56320;
}
function wd(i) {
  return i < 65536 ? 1 : 2;
}
let Re = class pg {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, n) {
    [e, t] = Hr(this, e, t);
    let r = [];
    return this.decompose(
      0,
      e,
      r,
      2
      /* Open.To */
    ), n.length && n.decompose(
      0,
      n.length,
      r,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      r,
      1
      /* Open.From */
    ), Ii.from(r, this.length - (t - e) + n.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    [e, t] = Hr(this, e, t);
    let n = [];
    return this.decompose(e, t, n, 0), Ii.from(n, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), n = this.length - this.scanIdentical(e, -1), r = new js(this), s = new js(e);
    for (let o = t, a = t; ; ) {
      if (r.next(o), s.next(o), o = 0, r.lineBreak != s.lineBreak || r.done != s.done || r.value != s.value)
        return !1;
      if (a += r.value.length, r.done || a >= n)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new js(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new Og(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let n;
    if (e == null)
      n = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let r = this.line(e).from;
      n = this.iterRange(r, Math.max(r, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new mg(n);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? pg.empty : e.length <= 32 ? new et(e) : Ii.from(et.split(e, []));
  }
};
class et extends Re {
  constructor(e, t = JS(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, n, r) {
    for (let s = 0; ; s++) {
      let o = this.text[s], a = r + o.length;
      if ((t ? n : a) >= e)
        return new ew(r, a, n, o);
      r = a + 1, n++;
    }
  }
  decompose(e, t, n, r) {
    let s = e <= 0 && t >= this.length ? this : new et(xd(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (r & 1) {
      let o = n.pop(), a = Sa(s.text, o.text.slice(), 0, s.length);
      if (a.length <= 32)
        n.push(new et(a, o.length + s.length));
      else {
        let l = a.length >> 1;
        n.push(new et(a.slice(0, l)), new et(a.slice(l)));
      }
    } else
      n.push(s);
  }
  replace(e, t, n) {
    if (!(n instanceof et))
      return super.replace(e, t, n);
    [e, t] = Hr(this, e, t);
    let r = Sa(this.text, Sa(n.text, xd(this.text, 0, e)), t), s = this.length + n.length - (t - e);
    return r.length <= 32 ? new et(r, s) : Ii.from(et.split(r, []), s);
  }
  sliceString(e, t = this.length, n = `
`) {
    [e, t] = Hr(this, e, t);
    let r = "";
    for (let s = 0, o = 0; s <= t && o < this.text.length; o++) {
      let a = this.text[o], l = s + a.length;
      s > e && o && (r += n), e < l && t > s && (r += a.slice(Math.max(0, e - s), t - s)), s = l + 1;
    }
    return r;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let n = [], r = -1;
    for (let s of e)
      n.push(s), r += s.length + 1, n.length == 32 && (t.push(new et(n, r)), n = [], r = -1);
    return r > -1 && t.push(new et(n, r)), t;
  }
}
class Ii extends Re {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let n of e)
      this.lines += n.lines;
  }
  lineInner(e, t, n, r) {
    for (let s = 0; ; s++) {
      let o = this.children[s], a = r + o.length, l = n + o.lines - 1;
      if ((t ? l : a) >= e)
        return o.lineInner(e, t, n, r);
      r = a + 1, n = l + 1;
    }
  }
  decompose(e, t, n, r) {
    for (let s = 0, o = 0; o <= t && s < this.children.length; s++) {
      let a = this.children[s], l = o + a.length;
      if (e <= l && t >= o) {
        let c = r & ((o <= e ? 1 : 0) | (l >= t ? 2 : 0));
        o >= e && l <= t && !c ? n.push(a) : a.decompose(e - o, t - o, n, c);
      }
      o = l + 1;
    }
  }
  replace(e, t, n) {
    if ([e, t] = Hr(this, e, t), n.lines < this.lines)
      for (let r = 0, s = 0; r < this.children.length; r++) {
        let o = this.children[r], a = s + o.length;
        if (e >= s && t <= a) {
          let l = o.replace(e - s, t - s, n), c = this.lines - o.lines + l.lines;
          if (l.lines < c >> 4 && l.lines > c >> 6) {
            let h = this.children.slice();
            return h[r] = l, new Ii(h, this.length - (t - e) + n.length);
          }
          return super.replace(s, a, l);
        }
        s = a + 1;
      }
    return super.replace(e, t, n);
  }
  sliceString(e, t = this.length, n = `
`) {
    [e, t] = Hr(this, e, t);
    let r = "";
    for (let s = 0, o = 0; s < this.children.length && o <= t; s++) {
      let a = this.children[s], l = o + a.length;
      o > e && s && (r += n), e < l && t > o && (r += a.sliceString(e - o, t - o, n)), o = l + 1;
    }
    return r;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof Ii))
      return 0;
    let n = 0, [r, s, o, a] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; r += t, s += t) {
      if (r == o || s == a)
        return n;
      let l = this.children[r], c = e.children[s];
      if (l != c)
        return n + l.scanIdentical(c, t);
      n += l.length + 1;
    }
  }
  static from(e, t = e.reduce((n, r) => n + r.length + 1, -1)) {
    let n = 0;
    for (let d of e)
      n += d.lines;
    if (n < 32) {
      let d = [];
      for (let p of e)
        p.flatten(d);
      return new et(d, t);
    }
    let r = Math.max(
      32,
      n >> 5
      /* Tree.BranchShift */
    ), s = r << 1, o = r >> 1, a = [], l = 0, c = -1, h = [];
    function f(d) {
      let p;
      if (d.lines > s && d instanceof Ii)
        for (let O of d.children)
          f(O);
      else d.lines > o && (l > o || !l) ? (u(), a.push(d)) : d instanceof et && l && (p = h[h.length - 1]) instanceof et && d.lines + p.lines <= 32 ? (l += d.lines, c += d.length + 1, h[h.length - 1] = new et(p.text.concat(d.text), p.length + 1 + d.length)) : (l + d.lines > r && u(), l += d.lines, c += d.length + 1, h.push(d));
    }
    function u() {
      l != 0 && (a.push(h.length == 1 ? h[0] : Ii.from(h, c)), c = -1, l = h.length = 0);
    }
    for (let d of e)
      f(d);
    return u(), a.length == 1 ? a[0] : new Ii(a, t);
  }
}
Re.empty = /* @__PURE__ */ new et([""], 0);
function JS(i) {
  let e = -1;
  for (let t of i)
    e += t.length + 1;
  return e;
}
function Sa(i, e, t = 0, n = 1e9) {
  for (let r = 0, s = 0, o = !0; s < i.length && r <= n; s++) {
    let a = i[s], l = r + a.length;
    l >= t && (l > n && (a = a.slice(0, n - r)), r < t && (a = a.slice(t - r)), o ? (e[e.length - 1] += a, o = !1) : e.push(a)), r = l + 1;
  }
  return e;
}
function xd(i, e, t) {
  return Sa(i, [""], e, t);
}
class js {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof et ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let n = this.nodes.length - 1, r = this.nodes[n], s = this.offsets[n], o = s >> 1, a = r instanceof et ? r.text.length : r.children.length;
      if (o == (t > 0 ? a : 0)) {
        if (n == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[n - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[n] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (r instanceof et) {
        let l = r.text[o + (t < 0 ? -1 : 0)];
        if (this.offsets[n] += t, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : t > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = r.children[o + (t < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[n] += t) : (t < 0 && this.offsets[n]--, this.nodes.push(l), this.offsets.push(t > 0 ? 1 : (l instanceof et ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class Og {
  constructor(e, t, n) {
    this.value = "", this.done = !1, this.cursor = new js(e, t > n ? -1 : 1), this.pos = t > n ? e.length : 0, this.from = Math.min(t, n), this.to = Math.max(t, n);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let n = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > n && (e = n), n -= e;
    let { value: r } = this.cursor.next(e);
    return this.pos += (r.length + e) * t, this.value = r.length <= n ? r : t < 0 ? r.slice(r.length - n) : r.slice(0, n), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class mg {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: n, value: r } = this.inner.next(e);
    return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : n ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = r, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (Re.prototype[Symbol.iterator] = function() {
  return this.iter();
}, js.prototype[Symbol.iterator] = Og.prototype[Symbol.iterator] = mg.prototype[Symbol.iterator] = function() {
  return this;
});
class ew {
  /**
  @internal
  */
  constructor(e, t, n, r) {
    this.from = e, this.to = t, this.number = n, this.text = r;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function Hr(i, e, t) {
  return e = Math.max(0, Math.min(i.length, e)), [e, Math.max(e, Math.min(i.length, t))];
}
function gt(i, e, t = !0, n = !0) {
  return HS(i, e, t, n);
}
function tw(i) {
  return i >= 56320 && i < 57344;
}
function iw(i) {
  return i >= 55296 && i < 56320;
}
function Yt(i, e) {
  let t = i.charCodeAt(e);
  if (!iw(t) || e + 1 == i.length)
    return t;
  let n = i.charCodeAt(e + 1);
  return tw(n) ? (t - 55296 << 10) + (n - 56320) + 65536 : t;
}
function Df(i) {
  return i <= 65535 ? String.fromCharCode(i) : (i -= 65536, String.fromCharCode((i >> 10) + 55296, (i & 1023) + 56320));
}
function Bi(i) {
  return i < 65536 ? 1 : 2;
}
const gh = /\r\n?|\n/;
var Ot = /* @__PURE__ */ (function(i) {
  return i[i.Simple = 0] = "Simple", i[i.TrackDel = 1] = "TrackDel", i[i.TrackBefore = 2] = "TrackBefore", i[i.TrackAfter = 3] = "TrackAfter", i;
})(Ot || (Ot = {}));
class Gi {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let n = this.sections[t + 1];
      e += n < 0 ? this.sections[t] : n;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, n = 0, r = 0; t < this.sections.length; ) {
      let s = this.sections[t++], o = this.sections[t++];
      o < 0 ? (e(n, r, s), r += s) : r += o, n += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    bh(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let n = this.sections[t++], r = this.sections[t++];
      r < 0 ? e.push(n, r) : e.push(r, n);
    }
    return new Gi(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : gg(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : yh(this, e, t);
  }
  mapPos(e, t = -1, n = Ot.Simple) {
    let r = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let a = this.sections[o++], l = this.sections[o++], c = r + a;
      if (l < 0) {
        if (c > e)
          return s + (e - r);
        s += a;
      } else {
        if (n != Ot.Simple && c >= e && (n == Ot.TrackDel && r < e && c > e || n == Ot.TrackBefore && r < e || n == Ot.TrackAfter && c > e))
          return null;
        if (c > e || c == e && t < 0 && !a)
          return e == r || t < 0 ? s : s + l;
        s += l;
      }
      r = c;
    }
    if (e > r)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${r}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let n = 0, r = 0; n < this.sections.length && r <= t; ) {
      let s = this.sections[n++], o = this.sections[n++], a = r + s;
      if (o >= 0 && r <= t && a >= e)
        return r < e && a > t ? "cover" : !0;
      r = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let n = this.sections[t++], r = this.sections[t++];
      e += (e ? " " : "") + n + (r >= 0 ? ":" + r : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Gi(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new Gi(e);
  }
}
class lt extends Gi {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return bh(this, (t, n, r, s, o) => e = e.replace(r, r + (n - t), o), !1), e;
  }
  mapDesc(e, t = !1) {
    return yh(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), n = [];
    for (let r = 0, s = 0; r < t.length; r += 2) {
      let o = t[r], a = t[r + 1];
      if (a >= 0) {
        t[r] = a, t[r + 1] = o;
        let l = r >> 1;
        for (; n.length < l; )
          n.push(Re.empty);
        n.push(o ? e.slice(s, s + o) : Re.empty);
      }
      s += o;
    }
    return new lt(t, n);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` â†’ `docB` and `other` represents `docB` â†’ `docC`, the
  returned value will represent the change `docA` â†’ `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : gg(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : yh(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    bh(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return Gi.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], n = [], r = [], s = new io(this);
    e: for (let o = 0, a = 0; ; ) {
      let l = o == e.length ? 1e9 : e[o++];
      for (; a < l || a == l && s.len == 0; ) {
        if (s.done)
          break e;
        let h = Math.min(s.len, l - a);
        wt(r, h, -1);
        let f = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
        wt(t, h, f), f > 0 && Rn(n, t, s.text), s.forward(h), a += h;
      }
      let c = e[o++];
      for (; a < c; ) {
        if (s.done)
          break e;
        let h = Math.min(s.len, c - a);
        wt(t, h, -1), wt(r, h, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(h), a += h;
      }
    }
    return {
      changes: new lt(t, n),
      filtered: Gi.create(r)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let n = this.sections[t], r = this.sections[t + 1];
      r < 0 ? e.push(n) : r == 0 ? e.push([n]) : e.push([n].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, n) {
    let r = [], s = [], o = 0, a = null;
    function l(h = !1) {
      if (!h && !r.length)
        return;
      o < t && wt(r, t - o, -1);
      let f = new lt(r, s);
      a = a ? a.compose(f.map(a)) : f, r = [], s = [], o = 0;
    }
    function c(h) {
      if (Array.isArray(h))
        for (let f of h)
          c(f);
      else if (h instanceof lt) {
        if (h.length != t)
          throw new RangeError(`Mismatched change set length (got ${h.length}, expected ${t})`);
        l(), a = a ? a.compose(h.map(a)) : h;
      } else {
        let { from: f, to: u = f, insert: d } = h;
        if (f > u || f < 0 || u > t)
          throw new RangeError(`Invalid change range ${f} to ${u} (in doc of length ${t})`);
        let p = d ? typeof d == "string" ? Re.of(d.split(n || gh)) : d : Re.empty, O = p.length;
        if (f == u && O == 0)
          return;
        f < o && l(), f > o && wt(r, f - o, -1), wt(r, u - f, O), Rn(s, r, p), o = u;
      }
    }
    return c(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new lt(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], n = [];
    for (let r = 0; r < e.length; r++) {
      let s = e[r];
      if (typeof s == "number")
        t.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, a) => a && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          t.push(s[0], 0);
        else {
          for (; n.length < r; )
            n.push(Re.empty);
          n[r] = Re.of(s.slice(1)), t.push(s[0], n[r].length);
        }
      }
    }
    return new lt(t, n);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new lt(e, t);
  }
}
function wt(i, e, t, n = !1) {
  if (e == 0 && t <= 0)
    return;
  let r = i.length - 2;
  r >= 0 && t <= 0 && t == i[r + 1] ? i[r] += e : r >= 0 && e == 0 && i[r] == 0 ? i[r + 1] += t : n ? (i[r] += e, i[r + 1] += t) : i.push(e, t);
}
function Rn(i, e, t) {
  if (t.length == 0)
    return;
  let n = e.length - 2 >> 1;
  if (n < i.length)
    i[i.length - 1] = i[i.length - 1].append(t);
  else {
    for (; i.length < n; )
      i.push(Re.empty);
    i.push(t);
  }
}
function bh(i, e, t) {
  let n = i.inserted;
  for (let r = 0, s = 0, o = 0; o < i.sections.length; ) {
    let a = i.sections[o++], l = i.sections[o++];
    if (l < 0)
      r += a, s += a;
    else {
      let c = r, h = s, f = Re.empty;
      for (; c += a, h += l, l && n && (f = f.append(n[o - 2 >> 1])), !(t || o == i.sections.length || i.sections[o + 1] < 0); )
        a = i.sections[o++], l = i.sections[o++];
      e(r, c, s, h, f), r = c, s = h;
    }
  }
}
function yh(i, e, t, n = !1) {
  let r = [], s = n ? [] : null, o = new io(i), a = new io(e);
  for (let l = -1; ; ) {
    if (o.done && a.len || a.done && o.len)
      throw new Error("Mismatched change set lengths");
    if (o.ins == -1 && a.ins == -1) {
      let c = Math.min(o.len, a.len);
      wt(r, c, -1), o.forward(c), a.forward(c);
    } else if (a.ins >= 0 && (o.ins < 0 || l == o.i || o.off == 0 && (a.len < o.len || a.len == o.len && !t))) {
      let c = a.len;
      for (wt(r, a.ins, -1); c; ) {
        let h = Math.min(o.len, c);
        o.ins >= 0 && l < o.i && o.len <= h && (wt(r, 0, o.ins), s && Rn(s, r, o.text), l = o.i), o.forward(h), c -= h;
      }
      a.next();
    } else if (o.ins >= 0) {
      let c = 0, h = o.len;
      for (; h; )
        if (a.ins == -1) {
          let f = Math.min(h, a.len);
          c += f, h -= f, a.forward(f);
        } else if (a.ins == 0 && a.len < h)
          h -= a.len, a.next();
        else
          break;
      wt(r, c, l < o.i ? o.ins : 0), s && l < o.i && Rn(s, r, o.text), l = o.i, o.forward(o.len - h);
    } else {
      if (o.done && a.done)
        return s ? lt.createSet(r, s) : Gi.create(r);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function gg(i, e, t = !1) {
  let n = [], r = t ? [] : null, s = new io(i), o = new io(e);
  for (let a = !1; ; ) {
    if (s.done && o.done)
      return r ? lt.createSet(n, r) : Gi.create(n);
    if (s.ins == 0)
      wt(n, s.len, 0, a), s.next();
    else if (o.len == 0 && !o.done)
      wt(n, 0, o.ins, a), r && Rn(r, n, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(s.len2, o.len), c = n.length;
        if (s.ins == -1) {
          let h = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          wt(n, l, h, a), r && h && Rn(r, n, o.text);
        } else o.ins == -1 ? (wt(n, s.off ? 0 : s.len, l, a), r && Rn(r, n, s.textBit(l))) : (wt(n, s.off ? 0 : s.len, o.off ? 0 : o.ins, a), r && !o.off && Rn(r, n, o.text));
        a = (s.ins > l || o.ins >= 0 && o.len > l) && (a || n.length > c), s.forward2(l), o.forward(l);
      }
    }
  }
}
class io {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? Re.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, n = this.i - 2 >> 1;
    return n >= t.length && !e ? Re.empty : t[n].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class rr {
  constructor(e, t, n) {
    this.from = e, this.to = t, this.flags = n;
  }
  /**
  The anchor of the rangeâ€”the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let n, r;
    return this.empty ? n = r = e.mapPos(this.from, t) : (n = e.mapPos(this.from, 1), r = e.mapPos(this.to, -1)), n == this.from && r == this.to ? this : new rr(n, r, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return q.range(e, t);
    let n = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return q.range(this.anchor, n);
  }
  /**
  Compare this range to another range.
  */
  eq(e, t = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!t || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return q.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, n) {
    return new rr(e, t, n);
  }
}
class q {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : q.create(this.ranges.map((n) => n.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, t = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let n = 0; n < this.ranges.length; n++)
      if (!this.ranges[n].eq(e.ranges[n], t))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new q([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return q.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let n = this.ranges.slice();
    return n[t] = e, q.create(n, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new q(e.ranges.map((t) => rr.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new q([q.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let n = 0, r = 0; r < e.length; r++) {
      let s = e[r];
      if (s.empty ? s.from <= n : s.from < n)
        return q.normalized(e.slice(), t);
      n = s.to;
    }
    return new q(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, n, r) {
    return rr.create(e, e, (t == 0 ? 0 : t < 0 ? 8 : 16) | (n == null ? 7 : Math.min(6, n)) | (r ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, t, n, r) {
    let s = (n ?? 16777215) << 6 | (r == null ? 7 : Math.min(6, r));
    return t < e ? rr.create(t, e, 48 | s) : rr.create(e, t, (t > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let n = e[t];
    e.sort((r, s) => r.from - s.from), t = e.indexOf(n);
    for (let r = 1; r < e.length; r++) {
      let s = e[r], o = e[r - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let a = o.from, l = Math.max(s.to, o.to);
        r <= t && t--, e.splice(--r, 2, s.anchor > s.head ? q.range(l, a) : q.range(a, l));
      }
    }
    return new q(e, t);
  }
}
function bg(i, e) {
  for (let t of i.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let Lf = 0;
class le {
  constructor(e, t, n, r, s) {
    this.combine = e, this.compareInput = t, this.compare = n, this.isStatic = r, this.id = Lf++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new le(e.combine || ((t) => t), e.compareInput || ((t, n) => t === n), e.compare || (e.combine ? (t, n) => t === n : If), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new wa([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new wa(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new wa(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (n) => n), this.compute([e], (n) => t(n.field(e)));
  }
}
function If(i, e) {
  return i == e || i.length == e.length && i.every((t, n) => t === e[n]);
}
class wa {
  constructor(e, t, n, r) {
    this.dependencies = e, this.facet = t, this.type = n, this.value = r, this.id = Lf++;
  }
  dynamicSlot(e) {
    var t;
    let n = this.value, r = this.facet.compareInput, s = this.id, o = e[s] >> 1, a = this.type == 2, l = !1, c = !1, h = [];
    for (let f of this.dependencies)
      f == "doc" ? l = !0 : f == "selection" ? c = !0 : (((t = e[f.id]) !== null && t !== void 0 ? t : 1) & 1) == 0 && h.push(e[f.id]);
    return {
      create(f) {
        return f.values[o] = n(f), 1;
      },
      update(f, u) {
        if (l && u.docChanged || c && (u.docChanged || u.selection) || vh(f, h)) {
          let d = n(f);
          if (a ? !kd(d, f.values[o], r) : !r(d, f.values[o]))
            return f.values[o] = d, 1;
        }
        return 0;
      },
      reconfigure: (f, u) => {
        let d, p = u.config.address[s];
        if (p != null) {
          let O = Ya(u, p);
          if (this.dependencies.every((m) => m instanceof le ? u.facet(m) === f.facet(m) : m instanceof ft ? u.field(m, !1) == f.field(m, !1) : !0) || (a ? kd(d = n(f), O, r) : r(d = n(f), O)))
            return f.values[o] = O, 0;
        } else
          d = n(f);
        return f.values[o] = d, 1;
      }
    };
  }
}
function kd(i, e, t) {
  if (i.length != e.length)
    return !1;
  for (let n = 0; n < i.length; n++)
    if (!t(i[n], e[n]))
      return !1;
  return !0;
}
function vh(i, e) {
  let t = !1;
  for (let n of e)
    Us(i, n) & 1 && (t = !0);
  return t;
}
function nw(i, e, t) {
  let n = t.map((l) => i[l.id]), r = t.map((l) => l.type), s = n.filter((l) => !(l & 1)), o = i[e.id] >> 1;
  function a(l) {
    let c = [];
    for (let h = 0; h < n.length; h++) {
      let f = Ya(l, n[h]);
      if (r[h] == 2)
        for (let u of f)
          c.push(u);
      else
        c.push(f);
    }
    return e.combine(c);
  }
  return {
    create(l) {
      for (let c of n)
        Us(l, c);
      return l.values[o] = a(l), 1;
    },
    update(l, c) {
      if (!vh(l, s))
        return 0;
      let h = a(l);
      return e.compare(h, l.values[o]) ? 0 : (l.values[o] = h, 1);
    },
    reconfigure(l, c) {
      let h = vh(l, n), f = c.config.facets[e.id], u = c.facet(e);
      if (f && !h && If(t, f))
        return l.values[o] = u, 0;
      let d = a(l);
      return e.compare(d, u) ? (l.values[o] = u, 0) : (l.values[o] = d, 1);
    }
  };
}
const No = /* @__PURE__ */ le.define({ static: !0 });
class ft {
  constructor(e, t, n, r, s) {
    this.id = e, this.createF = t, this.updateF = n, this.compareF = r, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new ft(Lf++, e.create, e.update, e.compare || ((n, r) => n === r), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(No).find((n) => n.field == this);
    return (t?.create || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (n) => (n.values[t] = this.create(n), 1),
      update: (n, r) => {
        let s = n.values[t], o = this.updateF(s, r);
        return this.compareF(s, o) ? 0 : (n.values[t] = o, 1);
      },
      reconfigure: (n, r) => {
        let s = n.facet(No), o = r.facet(No), a;
        return (a = s.find((l) => l.field == this)) && a != o.find((l) => l.field == this) ? (n.values[t] = a.create(n), 1) : r.config.address[this.id] != null ? (n.values[t] = r.field(this), 0) : (n.values[t] = this.create(n), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, No.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const tr = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function As(i) {
  return (e) => new yg(e, i);
}
const Wn = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ As(tr.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ As(tr.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ As(tr.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ As(tr.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ As(tr.lowest)
};
class yg {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class $l {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new Sh(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return $l.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class Sh {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class Ba {
  constructor(e, t, n, r, s, o) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = n, this.address = r, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < n.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, n) {
    let r = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let u of rw(e, t, o))
      u instanceof ft ? r.push(u) : (s[u.facet.id] || (s[u.facet.id] = [])).push(u);
    let a = /* @__PURE__ */ Object.create(null), l = [], c = [];
    for (let u of r)
      a[u.id] = c.length << 1, c.push((d) => u.slot(d));
    let h = n?.config.facets;
    for (let u in s) {
      let d = s[u], p = d[0].facet, O = h && h[u] || [];
      if (d.every(
        (m) => m.type == 0
        /* Provider.Static */
      ))
        if (a[p.id] = l.length << 1 | 1, If(O, d))
          l.push(n.facet(p));
        else {
          let m = p.combine(d.map((g) => g.value));
          l.push(n && p.compare(m, n.facet(p)) ? n.facet(p) : m);
        }
      else {
        for (let m of d)
          m.type == 0 ? (a[m.id] = l.length << 1 | 1, l.push(m.value)) : (a[m.id] = c.length << 1, c.push((g) => m.dynamicSlot(g)));
        a[p.id] = c.length << 1, c.push((m) => nw(m, p, d));
      }
    }
    let f = c.map((u) => u(a));
    return new Ba(e, o, f, a, l, s);
  }
}
function rw(i, e, t) {
  let n = [[], [], [], [], []], r = /* @__PURE__ */ new Map();
  function s(o, a) {
    let l = r.get(o);
    if (l != null) {
      if (l <= a)
        return;
      let c = n[l].indexOf(o);
      c > -1 && n[l].splice(c, 1), o instanceof Sh && t.delete(o.compartment);
    }
    if (r.set(o, a), Array.isArray(o))
      for (let c of o)
        s(c, a);
    else if (o instanceof Sh) {
      if (t.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      t.set(o.compartment, c), s(c, a);
    } else if (o instanceof yg)
      s(o.inner, o.prec);
    else if (o instanceof ft)
      n[a].push(o), o.provides && s(o.provides, a);
    else if (o instanceof wa)
      n[a].push(o), o.facet.extensions && s(o.facet.extensions, tr.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(c, a);
    }
  }
  return s(i, tr.default), n.reduce((o, a) => o.concat(a));
}
function Us(i, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, n = i.status[t];
  if (n == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (n & 2)
    return n;
  i.status[t] = 4;
  let r = i.computeSlot(i, i.config.dynamicSlots[t]);
  return i.status[t] = 2 | r;
}
function Ya(i, e) {
  return e & 1 ? i.config.staticValues[e >> 1] : i.values[e >> 1];
}
const vg = /* @__PURE__ */ le.define(), wh = /* @__PURE__ */ le.define({
  combine: (i) => i.some((e) => e),
  static: !0
}), Sg = /* @__PURE__ */ le.define({
  combine: (i) => i.length ? i[0] : void 0,
  static: !0
}), wg = /* @__PURE__ */ le.define(), xg = /* @__PURE__ */ le.define(), kg = /* @__PURE__ */ le.define(), Qg = /* @__PURE__ */ le.define({
  combine: (i) => i.length ? i[0] : !1
});
class _n {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new sw();
  }
}
class sw {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new _n(this, e);
  }
}
class ow {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new ge(this, e);
  }
}
class ge {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new ge(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new ow(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let n = [];
    for (let r of e) {
      let s = r.map(t);
      s && n.push(s);
    }
    return n;
  }
}
ge.reconfigure = /* @__PURE__ */ ge.define();
ge.appendConfig = /* @__PURE__ */ ge.define();
class st {
  constructor(e, t, n, r, s, o) {
    this.startState = e, this.changes = t, this.selection = n, this.effects = r, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, n && bg(n, t.newLength), s.some((a) => a.type == st.time) || (this.annotations = s.concat(st.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, n, r, s, o) {
    return new st(e, t, n, r, s, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(st.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
st.time = /* @__PURE__ */ _n.define();
st.userEvent = /* @__PURE__ */ _n.define();
st.addToHistory = /* @__PURE__ */ _n.define();
st.remote = /* @__PURE__ */ _n.define();
function aw(i, e) {
  let t = [];
  for (let n = 0, r = 0; ; ) {
    let s, o;
    if (n < i.length && (r == e.length || e[r] >= i[n]))
      s = i[n++], o = i[n++];
    else if (r < e.length)
      s = e[r++], o = e[r++];
    else
      return t;
    !t.length || t[t.length - 1] < s ? t.push(s, o) : t[t.length - 1] < o && (t[t.length - 1] = o);
  }
}
function _g(i, e, t) {
  var n;
  let r, s, o;
  return t ? (r = e.changes, s = lt.empty(e.changes.length), o = i.changes.compose(e.changes)) : (r = e.changes.map(i.changes), s = i.changes.mapDesc(e.changes, !0), o = i.changes.compose(r)), {
    changes: o,
    selection: e.selection ? e.selection.map(s) : (n = i.selection) === null || n === void 0 ? void 0 : n.map(r),
    effects: ge.mapEffects(i.effects, r).concat(ge.mapEffects(e.effects, s)),
    annotations: i.annotations.length ? i.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: i.scrollIntoView || e.scrollIntoView
  };
}
function xh(i, e, t) {
  let n = e.selection, r = Ir(e.annotations);
  return e.userEvent && (r = r.concat(st.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof lt ? e.changes : lt.of(e.changes || [], t, i.facet(Sg)),
    selection: n && (n instanceof q ? n : q.single(n.anchor, n.head)),
    effects: Ir(e.effects),
    annotations: r,
    scrollIntoView: !!e.scrollIntoView
  };
}
function Pg(i, e, t) {
  let n = xh(i, e.length ? e[0] : {}, i.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (t = !1);
    let o = !!e[s].sequential;
    n = _g(n, xh(i, e[s], o ? n.changes.newLength : i.doc.length), o);
  }
  let r = st.create(i, n.changes, n.selection, n.effects, n.annotations, n.scrollIntoView);
  return cw(t ? lw(r) : r);
}
function lw(i) {
  let e = i.startState, t = !0;
  for (let r of e.facet(wg)) {
    let s = r(i);
    if (s === !1) {
      t = !1;
      break;
    }
    Array.isArray(s) && (t = t === !0 ? s : aw(t, s));
  }
  if (t !== !0) {
    let r, s;
    if (t === !1)
      s = i.changes.invertedDesc, r = lt.empty(e.doc.length);
    else {
      let o = i.changes.filter(t);
      r = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    i = st.create(e, r, i.selection && i.selection.map(s), ge.mapEffects(i.effects, s), i.annotations, i.scrollIntoView);
  }
  let n = e.facet(xg);
  for (let r = n.length - 1; r >= 0; r--) {
    let s = n[r](i);
    s instanceof st ? i = s : Array.isArray(s) && s.length == 1 && s[0] instanceof st ? i = s[0] : i = Pg(e, Ir(s), !1);
  }
  return i;
}
function cw(i) {
  let e = i.startState, t = e.facet(kg), n = i;
  for (let r = t.length - 1; r >= 0; r--) {
    let s = t[r](i);
    s && Object.keys(s).length && (n = _g(n, xh(e, s, i.changes.newLength), !0));
  }
  return n == i ? i : st.create(e, i.changes, i.selection, n.effects, n.annotations, n.scrollIntoView);
}
const hw = [];
function Ir(i) {
  return i == null ? hw : Array.isArray(i) ? i : [i];
}
var Fe = /* @__PURE__ */ (function(i) {
  return i[i.Word = 0] = "Word", i[i.Space = 1] = "Space", i[i.Other = 2] = "Other", i;
})(Fe || (Fe = {}));
const fw = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let kh;
try {
  kh = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function uw(i) {
  if (kh)
    return kh.test(i);
  for (let e = 0; e < i.length; e++) {
    let t = i[e];
    if (/\w/.test(t) || t > "Â€" && (t.toUpperCase() != t.toLowerCase() || fw.test(t)))
      return !0;
  }
  return !1;
}
function dw(i) {
  return (e) => {
    if (!/\S/.test(e))
      return Fe.Space;
    if (uw(e))
      return Fe.Word;
    for (let t = 0; t < i.length; t++)
      if (e.indexOf(i[t]) > -1)
        return Fe.Word;
    return Fe.Other;
  };
}
class $e {
  constructor(e, t, n, r, s, o) {
    this.config = e, this.doc = t, this.selection = n, this.values = r, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      Us(this, a << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let n = this.config.address[e.id];
    if (n == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Us(this, n), Ya(this, n);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return Pg(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: n, compartments: r } = t;
    for (let a of e.effects)
      a.is($l.reconfigure) ? (t && (r = /* @__PURE__ */ new Map(), t.compartments.forEach((l, c) => r.set(c, l)), t = null), r.set(a.value.compartment, a.value.extension)) : a.is(ge.reconfigure) ? (t = null, n = a.value) : a.is(ge.appendConfig) && (t = null, n = Ir(n).concat(a.value));
    let s;
    t ? s = e.startState.values.slice() : (t = Ba.resolve(n, r, this), s = new $e(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
    let o = e.startState.facet(wh) ? e.newSelection : e.newSelection.asSingle();
    new $e(t, e.newDoc, o, s, (a, l) => l.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: q.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, n = e(t.ranges[0]), r = this.changes(n.changes), s = [n.range], o = Ir(n.effects);
    for (let a = 1; a < t.ranges.length; a++) {
      let l = e(t.ranges[a]), c = this.changes(l.changes), h = c.map(r);
      for (let u = 0; u < a; u++)
        s[u] = s[u].map(h);
      let f = r.mapDesc(c, !0);
      s.push(l.range.map(f)), r = r.compose(h), o = ge.mapEffects(o, h).concat(ge.mapEffects(Ir(l.effects), f));
    }
    return {
      changes: r,
      selection: q.create(s, t.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof lt ? e : lt.of(e, this.doc.length, this.facet($e.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return Re.of(e.split(this.facet($e.lineSeparator) || gh));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (Us(this, t), Ya(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let n in e) {
        let r = e[n];
        r instanceof ft && this.config.address[r.id] != null && (t[n] = r.spec.toJSON(this.field(e[n]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, n) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let r = [];
    if (n) {
      for (let s in n)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = n[s], a = e[s];
          r.push(o.init((l) => o.spec.fromJSON(a, l)));
        }
    }
    return $e.create({
      doc: e.doc,
      selection: q.fromJSON(e.selection),
      extensions: t.extensions ? r.concat([t.extensions]) : r
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorâ€”updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = Ba.resolve(e.extensions || [], /* @__PURE__ */ new Map()), n = e.doc instanceof Re ? e.doc : Re.of((e.doc || "").split(t.staticFacet($e.lineSeparator) || gh)), r = e.selection ? e.selection instanceof q ? e.selection : q.single(e.selection.anchor, e.selection.head) : q.single(0);
    return bg(r, n.length), t.staticFacet(wh) || (r = r.asSingle()), new $e(t, n, r, t.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet($e.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet($e.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(Qg);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let n of this.facet($e.phrases))
      if (Object.prototype.hasOwnProperty.call(n, e)) {
        e = n[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (n, r) => {
      if (r == "$")
        return "$";
      let s = +(r || 1);
      return !s || s > t.length ? n : t[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, n = -1) {
    let r = [];
    for (let s of this.facet(vg))
      for (let o of s(this, t, n))
        Object.prototype.hasOwnProperty.call(o, e) && r.push(o[e]);
    return r;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return dw(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: n, length: r } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - n, a = e - n;
    for (; o > 0; ) {
      let l = gt(t, o, !1);
      if (s(t.slice(l, o)) != Fe.Word)
        break;
      o = l;
    }
    for (; a < r; ) {
      let l = gt(t, a);
      if (s(t.slice(a, l)) != Fe.Word)
        break;
      a = l;
    }
    return o == a ? null : q.range(o + n, a + n);
  }
}
$e.allowMultipleSelections = wh;
$e.tabSize = /* @__PURE__ */ le.define({
  combine: (i) => i.length ? i[0] : 4
});
$e.lineSeparator = Sg;
$e.readOnly = Qg;
$e.phrases = /* @__PURE__ */ le.define({
  compare(i, e) {
    let t = Object.keys(i), n = Object.keys(e);
    return t.length == n.length && t.every((r) => i[r] == e[r]);
  }
});
$e.languageData = vg;
$e.changeFilter = wg;
$e.transactionFilter = xg;
$e.transactionExtender = kg;
$l.reconfigure = /* @__PURE__ */ ge.define();
function sn(i, e, t = {}) {
  let n = {};
  for (let r of i)
    for (let s of Object.keys(r)) {
      let o = r[s], a = n[s];
      if (a === void 0)
        n[s] = o;
      else if (!(a === o || o === void 0)) if (Object.hasOwnProperty.call(t, s))
        n[s] = t[s](a, o);
      else
        throw new Error("Config merge conflict for field " + s);
    }
  for (let r in e)
    n[r] === void 0 && (n[r] = e[r]);
  return n;
}
class Or {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return Qh.create(e, t, this);
  }
}
Or.prototype.startSide = Or.prototype.endSide = 0;
Or.prototype.point = !1;
Or.prototype.mapMode = Ot.TrackDel;
let Qh = class $g {
  constructor(e, t, n) {
    this.from = e, this.to = t, this.value = n;
  }
  /**
  @internal
  */
  static create(e, t, n) {
    return new $g(e, t, n);
  }
};
function _h(i, e) {
  return i.from - e.from || i.value.startSide - e.value.startSide;
}
class Bf {
  constructor(e, t, n, r) {
    this.from = e, this.to = t, this.value = n, this.maxPoint = r;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, n, r = 0) {
    let s = n ? this.to : this.from;
    for (let o = r, a = s.length; ; ) {
      if (o == a)
        return o;
      let l = o + a >> 1, c = s[l] - e || (n ? this.value[l].endSide : this.value[l].startSide) - t;
      if (l == o)
        return c >= 0 ? o : a;
      c >= 0 ? a = l : o = l + 1;
    }
  }
  between(e, t, n, r) {
    for (let s = this.findIndex(t, -1e9, !0), o = this.findIndex(n, 1e9, !1, s); s < o; s++)
      if (r(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, t) {
    let n = [], r = [], s = [], o = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let c = this.value[l], h = this.from[l] + e, f = this.to[l] + e, u, d;
      if (h == f) {
        let p = t.mapPos(h, c.startSide, c.mapMode);
        if (p == null || (u = d = p, c.startSide != c.endSide && (d = t.mapPos(h, c.endSide), d < u)))
          continue;
      } else if (u = t.mapPos(h, c.startSide), d = t.mapPos(f, c.endSide), u > d || u == d && c.startSide > 0 && c.endSide <= 0)
        continue;
      (d - u || c.endSide - c.startSide) < 0 || (o < 0 && (o = u), c.point && (a = Math.max(a, d - u)), n.push(c), r.push(u - o), s.push(d - o));
    }
    return { mapped: n.length ? new Bf(r, s, n, a) : null, pos: o };
  }
}
class Te {
  constructor(e, t, n, r) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = n, this.maxPoint = r;
  }
  /**
  @internal
  */
  static create(e, t, n, r) {
    return new Te(e, t, n, r);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: n = !1, filterFrom: r = 0, filterTo: s = this.length } = e, o = e.filter;
    if (t.length == 0 && !o)
      return this;
    if (n && (t = t.slice().sort(_h)), this.isEmpty)
      return t.length ? Te.of(t) : this;
    let a = new Tg(this, null, -1).goto(0), l = 0, c = [], h = new wn();
    for (; a.value || l < t.length; )
      if (l < t.length && (a.from - t[l].from || a.startSide - t[l].value.startSide) >= 0) {
        let f = t[l++];
        h.addInner(f.from, f.to, f.value) || c.push(f);
      } else a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == t.length || this.chunkEnd(a.chunkIndex) < t[l].from) && (!o || r > this.chunkEnd(a.chunkIndex) || s < this.chunkPos[a.chunkIndex]) && h.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!o || r > a.to || s < a.from || o(a.from, a.to, a.value)) && (h.addInner(a.from, a.to, a.value) || c.push(Qh.create(a.from, a.to, a.value))), a.next());
    return h.finishInner(this.nextLayer.isEmpty && !c.length ? Te.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: r, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], n = [], r = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let a = this.chunkPos[o], l = this.chunk[o], c = e.touchesRange(a, a + l.length);
      if (c === !1)
        r = Math.max(r, l.maxPoint), t.push(l), n.push(e.mapPos(a));
      else if (c === !0) {
        let { mapped: h, pos: f } = l.map(a, e);
        h && (r = Math.max(r, h.maxPoint), t.push(h), n.push(f));
      }
    }
    let s = this.nextLayer.map(e);
    return t.length == 0 ? s : new Te(n, t, s || Te.empty, r);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, n) {
    if (!this.isEmpty) {
      for (let r = 0; r < this.chunk.length; r++) {
        let s = this.chunkPos[r], o = this.chunk[r];
        if (t >= s && e <= s + o.length && o.between(s, e - s, t - s, n) === !1)
          return;
      }
      this.nextLayer.between(e, t, n);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return no.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return no.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, n, r, s = -1) {
    let o = e.filter((f) => f.maxPoint > 0 || !f.isEmpty && f.maxPoint >= s), a = t.filter((f) => f.maxPoint > 0 || !f.isEmpty && f.maxPoint >= s), l = Qd(o, a, n), c = new Rs(o, l, s), h = new Rs(a, l, s);
    n.iterGaps((f, u, d) => _d(c, f, h, u, d, r)), n.empty && n.length == 0 && _d(c, 0, h, 0, 0, r);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, n = 0, r) {
    r == null && (r = 999999999);
    let s = e.filter((h) => !h.isEmpty && t.indexOf(h) < 0), o = t.filter((h) => !h.isEmpty && e.indexOf(h) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let a = Qd(s, o), l = new Rs(s, a, 0).goto(n), c = new Rs(o, a, 0).goto(n);
    for (; ; ) {
      if (l.to != c.to || !Ph(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
        return !1;
      if (l.to > r)
        return !0;
      l.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, n, r, s = -1) {
    let o = new Rs(e, null, s).goto(t), a = t, l = o.openStart;
    for (; ; ) {
      let c = Math.min(o.to, n);
      if (o.point) {
        let h = o.activeForPoint(o.to), f = o.pointFrom < t ? h.length + 1 : o.point.startSide < 0 ? h.length : Math.min(h.length, l);
        r.point(a, c, o.point, h, f, o.pointRank), l = Math.min(o.openEnd(c), h.length);
      } else c > a && (r.span(a, c, o.active, l), l = o.openEnd(c));
      if (o.to > n)
        return l + (o.point && o.to > n ? 1 : 0);
      a = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let n = new wn();
    for (let r of e instanceof Qh ? [e] : t ? pw(e) : e)
      n.add(r.from, r.to, r.value);
    return n.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return Te.empty;
    let t = e[e.length - 1];
    for (let n = e.length - 2; n >= 0; n--)
      for (let r = e[n]; r != Te.empty; r = r.nextLayer)
        t = new Te(r.chunkPos, r.chunk, t, Math.max(r.maxPoint, t.maxPoint));
    return t;
  }
}
Te.empty = /* @__PURE__ */ new Te([], [], null, -1);
function pw(i) {
  if (i.length > 1)
    for (let e = i[0], t = 1; t < i.length; t++) {
      let n = i[t];
      if (_h(e, n) > 0)
        return i.slice().sort(_h);
      e = n;
    }
  return i;
}
Te.empty.nextLayer = Te.empty;
class wn {
  finishChunk(e) {
    this.chunks.push(new Bf(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, n) {
    this.addInner(e, t, n) || (this.nextLayer || (this.nextLayer = new wn())).add(e, t, n);
  }
  /**
  @internal
  */
  addInner(e, t, n) {
    let r = e - this.lastTo || n.startSide - this.last.endSide;
    if (r <= 0 && (e - this.lastFrom || n.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return r < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = n, this.lastFrom = e, this.lastTo = t, this.value.push(n), n.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let n = t.value.length - 1;
    return this.last = t.value[n], this.lastFrom = t.from[n] + e, this.lastTo = t.to[n] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Te.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = Te.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function Qd(i, e, t) {
  let n = /* @__PURE__ */ new Map();
  for (let s of i)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && n.set(s.chunk[o], s.chunkPos[o]);
  let r = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let a = n.get(s.chunk[o]);
      a != null && (t ? t.mapPos(a) : a) == s.chunkPos[o] && !t?.touchesRange(a, a + s.chunk[o].length) && r.add(s.chunk[o]);
    }
  return r;
}
class Tg {
  constructor(e, t, n, r = 0) {
    this.layer = e, this.skip = t, this.minPoint = n, this.rank = r;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, n) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let r = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(r) || this.layer.chunkEnd(this.chunkIndex) < e || r.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, n = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let r = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!n || this.rangeIndex < r) && this.setRangeIndex(r);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], n = e + t.from[this.rangeIndex];
        if (this.from = n, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class no {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, n = -1) {
    let r = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= n && r.push(new Tg(o, t, n, s));
    return r.length == 1 ? r[0] : new no(r);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let n of this.heap)
      n.goto(e, t);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      hc(this.heap, n);
    return this.next(), this;
  }
  forward(e, t) {
    for (let n of this.heap)
      n.forward(e, t);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      hc(this.heap, n);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), hc(this.heap, 0);
    }
  }
}
function hc(i, e) {
  for (let t = i[e]; ; ) {
    let n = (e << 1) + 1;
    if (n >= i.length)
      break;
    let r = i[n];
    if (n + 1 < i.length && r.compare(i[n + 1]) >= 0 && (r = i[n + 1], n++), t.compare(r) < 0)
      break;
    i[n] = t, i[e] = r, e = n;
  }
}
class Rs {
  constructor(e, t, n) {
    this.minPoint = n, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = no.from(e, t, n);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    Vo(this.active, e), Vo(this.activeTo, e), Vo(this.activeRank, e), this.minActive = Pd(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: n, to: r, rank: s } = this.cursor;
    for (; t < this.activeRank.length && (s - this.activeRank[t] || r - this.activeTo[t]) > 0; )
      t++;
    qo(this.active, t, n), qo(this.activeTo, t, r), qo(this.activeRank, t, s), e && qo(e, t, this.cursor.from), this.minActive = Pd(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let n = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let r = this.minActive;
      if (r > -1 && (this.activeTo[r] - this.cursor.from || this.active[r].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[r] > e) {
          this.to = this.activeTo[r], this.endSide = this.active[r].endSide;
          break;
        }
        this.removeActive(r), n && Vo(n, r);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(n), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (n) {
      this.openStart = 0;
      for (let r = n.length - 1; r >= 0 && n[r] < e; r--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let n = this.active.length - 1; n >= 0 && !(this.activeRank[n] < this.pointRank); n--)
      (this.activeTo[n] > e || this.activeTo[n] == e && this.active[n].endSide >= this.point.endSide) && t.push(this.active[n]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let n = this.activeTo.length - 1; n >= 0 && this.activeTo[n] > e; n--)
      t++;
    return t;
  }
}
function _d(i, e, t, n, r, s) {
  i.goto(e), t.goto(n);
  let o = n + r, a = n, l = n - e;
  for (; ; ) {
    let c = i.to + l - t.to, h = c || i.endSide - t.endSide, f = h < 0 ? i.to + l : t.to, u = Math.min(f, o);
    if (i.point || t.point ? i.point && t.point && (i.point == t.point || i.point.eq(t.point)) && Ph(i.activeForPoint(i.to), t.activeForPoint(t.to)) || s.comparePoint(a, u, i.point, t.point) : u > a && !Ph(i.active, t.active) && s.compareRange(a, u, i.active, t.active), f > o)
      break;
    (c || i.openEnd != t.openEnd) && s.boundChange && s.boundChange(f), a = f, h <= 0 && i.next(), h >= 0 && t.next();
  }
}
function Ph(i, e) {
  if (i.length != e.length)
    return !1;
  for (let t = 0; t < i.length; t++)
    if (i[t] != e[t] && !i[t].eq(e[t]))
      return !1;
  return !0;
}
function Vo(i, e) {
  for (let t = e, n = i.length - 1; t < n; t++)
    i[t] = i[t + 1];
  i.pop();
}
function qo(i, e, t) {
  for (let n = i.length - 1; n >= e; n--)
    i[n + 1] = i[n];
  i[e] = t;
}
function Pd(i, e) {
  let t = -1, n = 1e9;
  for (let r = 0; r < e.length; r++)
    (e[r] - n || i[r].endSide - i[t].endSide) < 0 && (t = r, n = e[r]);
  return t;
}
function ms(i, e, t = i.length) {
  let n = 0;
  for (let r = 0; r < t && r < i.length; )
    i.charCodeAt(r) == 9 ? (n += e - n % e, r++) : (n++, r = gt(i, r));
  return n;
}
function $h(i, e, t, n) {
  for (let r = 0, s = 0; ; ) {
    if (s >= e)
      return r;
    if (r == i.length)
      break;
    s += i.charCodeAt(r) == 9 ? t - s % t : 1, r = gt(i, r);
  }
  return n === !0 ? -1 : i.length;
}
const Th = "Í¼", $d = typeof Symbol > "u" ? "__" + Th : Symbol.for(Th), Ch = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), Td = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class In {
  // :: (Object<Style>, ?{finish: ?(string) â†’ string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: n } = t || {};
    function r(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, a, l, c) {
      let h = [], f = /^@(\w+)\b/.exec(o[0]), u = f && f[1] == "keyframes";
      if (f && a == null) return l.push(o[0] + ";");
      for (let d in a) {
        let p = a[d];
        if (/&/.test(d))
          s(
            d.split(/,\s*/).map((O) => o.map((m) => O.replace(/&/, m))).reduce((O, m) => O.concat(m)),
            p,
            l
          );
        else if (p && typeof p == "object") {
          if (!f) throw new RangeError("The value of a property (" + d + ") should be a primitive value.");
          s(r(d), p, h, u);
        } else p != null && h.push(d.replace(/_.*/, "").replace(/[A-Z]/g, (O) => "-" + O.toLowerCase()) + ": " + p + ";");
      }
      (h.length || u) && l.push((n && !f && !c ? o.map(n) : o).join(", ") + " {" + h.join(" ") + "}");
    }
    for (let o in e) s(r(o), e[o], this.rules);
  }
  // :: () â†’ string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () â†’ string
  // Generate a new unique CSS class name.
  static newName() {
    let e = Td[$d] || 1;
    return Td[$d] = e + 1, Th + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, t, n) {
    let r = e[Ch], s = n && n.nonce;
    r ? s && r.setNonce(s) : r = new Ow(e, s), r.mount(Array.isArray(t) ? t : [t], e);
  }
}
let Cd = /* @__PURE__ */ new Map();
class Ow {
  constructor(e, t) {
    let n = e.ownerDocument || e, r = n.defaultView;
    if (!e.head && e.adoptedStyleSheets && r.CSSStyleSheet) {
      let s = Cd.get(n);
      if (s) return e[Ch] = s;
      this.sheet = new r.CSSStyleSheet(), Cd.set(n, this);
    } else
      this.styleTag = n.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
    this.modules = [], e[Ch] = this;
  }
  mount(e, t) {
    let n = this.sheet, r = 0, s = 0;
    for (let o = 0; o < e.length; o++) {
      let a = e[o], l = this.modules.indexOf(a);
      if (l < s && l > -1 && (this.modules.splice(l, 1), s--, l = -1), l == -1) {
        if (this.modules.splice(s++, 0, a), n) for (let c = 0; c < a.rules.length; c++)
          n.insertRule(a.rules[c], r++);
      } else {
        for (; s < l; ) r += this.modules[s++].rules.length;
        r += a.rules.length, s++;
      }
    }
    if (n)
      t.adoptedStyleSheets.indexOf(this.sheet) < 0 && (t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets]);
    else {
      let o = "";
      for (let l = 0; l < this.modules.length; l++)
        o += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = o;
      let a = t.head || t;
      this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var Bn = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, ro = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, mw = typeof navigator < "u" && /Mac/.test(navigator.platform), gw = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var pt = 0; pt < 10; pt++) Bn[48 + pt] = Bn[96 + pt] = String(pt);
for (var pt = 1; pt <= 24; pt++) Bn[pt + 111] = "F" + pt;
for (var pt = 65; pt <= 90; pt++)
  Bn[pt] = String.fromCharCode(pt + 32), ro[pt] = String.fromCharCode(pt);
for (var fc in Bn) ro.hasOwnProperty(fc) || (ro[fc] = Bn[fc]);
function bw(i) {
  var e = mw && i.metaKey && i.shiftKey && !i.ctrlKey && !i.altKey || gw && i.shiftKey && i.key && i.key.length == 1 || i.key == "Unidentified", t = !e && i.key || (i.shiftKey ? ro : Bn)[i.keyCode] || i.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function De() {
  var i = arguments[0];
  typeof i == "string" && (i = document.createElement(i));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var n in t) if (Object.prototype.hasOwnProperty.call(t, n)) {
      var r = t[n];
      typeof r == "string" ? i.setAttribute(n, r) : r != null && (i[n] = r);
    }
    e++;
  }
  for (; e < arguments.length; e++) Cg(i, arguments[e]);
  return i;
}
function Cg(i, e) {
  if (typeof e == "string")
    i.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    i.appendChild(e);
  else if (Array.isArray(e))
    for (var t = 0; t < e.length; t++) Cg(i, e[t]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
let Rt = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Ah = typeof document < "u" ? document : { documentElement: { style: {} } };
const Rh = /* @__PURE__ */ /Edge\/(\d+)/.exec(Rt.userAgent), Ag = /* @__PURE__ */ /MSIE \d/.test(Rt.userAgent), Eh = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Rt.userAgent), Tl = !!(Ag || Eh || Rh), Ad = !Tl && /* @__PURE__ */ /gecko\/(\d+)/i.test(Rt.userAgent), uc = !Tl && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Rt.userAgent), yw = "webkitFontSmoothing" in Ah.documentElement.style, Mh = !Tl && /* @__PURE__ */ /Apple Computer/.test(Rt.vendor), Rd = Mh && (/* @__PURE__ */ /Mobile\/\w+/.test(Rt.userAgent) || Rt.maxTouchPoints > 2);
var re = {
  mac: Rd || /* @__PURE__ */ /Mac/.test(Rt.platform),
  windows: /* @__PURE__ */ /Win/.test(Rt.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Rt.platform),
  ie: Tl,
  ie_version: Ag ? Ah.documentMode || 6 : Eh ? +Eh[1] : Rh ? +Rh[1] : 0,
  gecko: Ad,
  gecko_version: Ad ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Rt.userAgent) || [0, 0])[1] : 0,
  chrome: !!uc,
  chrome_version: uc ? +uc[1] : 0,
  ios: Rd,
  android: /* @__PURE__ */ /Android\b/.test(Rt.userAgent),
  webkit_version: yw ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(Rt.userAgent) || [0, 0])[1] : 0,
  safari: Mh,
  safari_version: Mh ? +(/* @__PURE__ */ /\bVersion\/(\d+(\.\d+)?)/.exec(Rt.userAgent) || [0, 0])[1] : 0,
  tabSize: Ah.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
function so(i) {
  let e;
  return i.nodeType == 11 ? e = i.getSelection ? i : i.ownerDocument : e = i, e.getSelection();
}
function Zh(i, e) {
  return e ? i == e || i.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function xa(i, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return Zh(i, e.anchorNode);
  } catch {
    return !1;
  }
}
function oo(i) {
  return i.nodeType == 3 ? gr(i, 0, i.nodeValue.length).getClientRects() : i.nodeType == 1 ? i.getClientRects() : [];
}
function Gs(i, e, t, n) {
  return t ? Ed(i, e, t, n, -1) || Ed(i, e, t, n, 1) : !1;
}
function mr(i) {
  for (var e = 0; ; e++)
    if (i = i.previousSibling, !i)
      return e;
}
function Na(i) {
  return i.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(i.nodeName);
}
function Ed(i, e, t, n, r) {
  for (; ; ) {
    if (i == t && e == n)
      return !0;
    if (e == (r < 0 ? 0 : Ji(i))) {
      if (i.nodeName == "DIV")
        return !1;
      let s = i.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = mr(i) + (r < 0 ? 0 : 1), i = s;
    } else if (i.nodeType == 1) {
      if (i = i.childNodes[e + (r < 0 ? -1 : 0)], i.nodeType == 1 && i.contentEditable == "false")
        return !1;
      e = r < 0 ? Ji(i) : 0;
    } else
      return !1;
  }
}
function Ji(i) {
  return i.nodeType == 3 ? i.nodeValue.length : i.childNodes.length;
}
function Cl(i, e) {
  let t = e ? i.left : i.right;
  return { left: t, right: t, top: i.top, bottom: i.bottom };
}
function vw(i) {
  let e = i.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: i.innerWidth,
    top: 0,
    bottom: i.innerHeight
  };
}
function Rg(i, e) {
  let t = e.width / i.offsetWidth, n = e.height / i.offsetHeight;
  return (t > 0.995 && t < 1.005 || !isFinite(t) || Math.abs(e.width - i.offsetWidth) < 1) && (t = 1), (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.height - i.offsetHeight) < 1) && (n = 1), { scaleX: t, scaleY: n };
}
function Sw(i, e, t, n, r, s, o, a) {
  let l = i.ownerDocument, c = l.defaultView || window;
  for (let h = i, f = !1; h && !f; )
    if (h.nodeType == 1) {
      let u, d = h == l.body, p = 1, O = 1;
      if (d)
        u = vw(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(h).position) && (f = !0), h.scrollHeight <= h.clientHeight && h.scrollWidth <= h.clientWidth) {
          h = h.assignedSlot || h.parentNode;
          continue;
        }
        let v = h.getBoundingClientRect();
        ({ scaleX: p, scaleY: O } = Rg(h, v)), u = {
          left: v.left,
          right: v.left + h.clientWidth * p,
          top: v.top,
          bottom: v.top + h.clientHeight * O
        };
      }
      let m = 0, g = 0;
      if (r == "nearest")
        e.top < u.top ? (g = e.top - (u.top + o), t > 0 && e.bottom > u.bottom + g && (g = e.bottom - u.bottom + o)) : e.bottom > u.bottom && (g = e.bottom - u.bottom + o, t < 0 && e.top - g < u.top && (g = e.top - (u.top + o)));
      else {
        let v = e.bottom - e.top, S = u.bottom - u.top;
        g = (r == "center" && v <= S ? e.top + v / 2 - S / 2 : r == "start" || r == "center" && t < 0 ? e.top - o : e.bottom - S + o) - u.top;
      }
      if (n == "nearest" ? e.left < u.left ? (m = e.left - (u.left + s), t > 0 && e.right > u.right + m && (m = e.right - u.right + s)) : e.right > u.right && (m = e.right - u.right + s, t < 0 && e.left < u.left + m && (m = e.left - (u.left + s))) : m = (n == "center" ? e.left + (e.right - e.left) / 2 - (u.right - u.left) / 2 : n == "start" == a ? e.left - s : e.right - (u.right - u.left) + s) - u.left, m || g)
        if (d)
          c.scrollBy(m, g);
        else {
          let v = 0, S = 0;
          if (g) {
            let w = h.scrollTop;
            h.scrollTop += g / O, S = (h.scrollTop - w) * O;
          }
          if (m) {
            let w = h.scrollLeft;
            h.scrollLeft += m / p, v = (h.scrollLeft - w) * p;
          }
          e = {
            left: e.left - v,
            top: e.top - S,
            right: e.right - v,
            bottom: e.bottom - S
          }, v && Math.abs(v - m) < 1 && (n = "nearest"), S && Math.abs(S - g) < 1 && (r = "nearest");
        }
      if (d)
        break;
      (e.top < u.top || e.bottom > u.bottom || e.left < u.left || e.right > u.right) && (e = {
        left: Math.max(e.left, u.left),
        right: Math.min(e.right, u.right),
        top: Math.max(e.top, u.top),
        bottom: Math.min(e.bottom, u.bottom)
      }), h = h.assignedSlot || h.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
}
function ww(i) {
  let e = i.ownerDocument, t, n;
  for (let r = i.parentNode; r && !(r == e.body || t && n); )
    if (r.nodeType == 1)
      !n && r.scrollHeight > r.clientHeight && (n = r), !t && r.scrollWidth > r.clientWidth && (t = r), r = r.assignedSlot || r.parentNode;
    else if (r.nodeType == 11)
      r = r.host;
    else
      break;
  return { x: t, y: n };
}
class xw {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: n } = e;
    this.set(t, Math.min(e.anchorOffset, t ? Ji(t) : 0), n, Math.min(e.focusOffset, n ? Ji(n) : 0));
  }
  set(e, t, n, r) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = n, this.focusOffset = r;
  }
}
let er = null;
re.safari && re.safari_version >= 26 && (er = !1);
function Eg(i) {
  if (i.setActive)
    return i.setActive();
  if (er)
    return i.focus(er);
  let e = [];
  for (let t = i; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (i.focus(er == null ? {
    get preventScroll() {
      return er = { preventScroll: !0 }, !0;
    }
  } : void 0), !er) {
    er = !1;
    for (let t = 0; t < e.length; ) {
      let n = e[t++], r = e[t++], s = e[t++];
      n.scrollTop != r && (n.scrollTop = r), n.scrollLeft != s && (n.scrollLeft = s);
    }
  }
}
let Md;
function gr(i, e, t = e) {
  let n = Md || (Md = document.createRange());
  return n.setEnd(i, t), n.setStart(i, e), n;
}
function Br(i, e, t, n) {
  let r = { key: e, code: e, keyCode: t, which: t, cancelable: !0 };
  n && ({ altKey: r.altKey, ctrlKey: r.ctrlKey, shiftKey: r.shiftKey, metaKey: r.metaKey } = n);
  let s = new KeyboardEvent("keydown", r);
  s.synthetic = !0, i.dispatchEvent(s);
  let o = new KeyboardEvent("keyup", r);
  return o.synthetic = !0, i.dispatchEvent(o), s.defaultPrevented || o.defaultPrevented;
}
function kw(i) {
  for (; i; ) {
    if (i && (i.nodeType == 9 || i.nodeType == 11 && i.host))
      return i;
    i = i.assignedSlot || i.parentNode;
  }
  return null;
}
function Mg(i) {
  for (; i.attributes.length; )
    i.removeAttributeNode(i.attributes[0]);
}
function Qw(i, e) {
  let t = e.focusNode, n = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != n)
    return !1;
  for (n = Math.min(n, Ji(t)); ; )
    if (n) {
      if (t.nodeType != 1)
        return !1;
      let r = t.childNodes[n - 1];
      r.contentEditable == "false" ? n-- : (t = r, n = Ji(t));
    } else {
      if (t == i)
        return !0;
      n = mr(t), t = t.parentNode;
    }
}
function Zg(i) {
  return i.scrollTop > Math.max(1, i.scrollHeight - i.clientHeight - 4);
}
function Xg(i, e) {
  for (let t = i, n = e; ; ) {
    if (t.nodeType == 3 && n > 0)
      return { node: t, offset: n };
    if (t.nodeType == 1 && n > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[n - 1], n = Ji(t);
    } else if (t.parentNode && !Na(t))
      n = mr(t), t = t.parentNode;
    else
      return null;
  }
}
function zg(i, e) {
  for (let t = i, n = e; ; ) {
    if (t.nodeType == 3 && n < t.nodeValue.length)
      return { node: t, offset: n };
    if (t.nodeType == 1 && n < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[n], n = 0;
    } else if (t.parentNode && !Na(t))
      n = mr(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
class xt {
  constructor(e, t, n = !0) {
    this.node = e, this.offset = t, this.precise = n;
  }
  static before(e, t) {
    return new xt(e.parentNode, mr(e), t);
  }
  static after(e, t) {
    return new xt(e.parentNode, mr(e) + 1, t);
  }
}
const Yf = [];
class ze {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let n of this.children) {
      if (n == e)
        return t;
      t += n.length + n.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let n = this.dom, r = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = r ? r.nextSibling : n.firstChild)) {
            let a = ze.get(s);
            (!a || !a.parent && a.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, t), o.flags &= -8;
        }
        if (s = r ? r.nextSibling : n.firstChild, t && !t.written && t.node == n && s != o.dom && (t.written = !0), o.dom.parentNode == n)
          for (; s && s != o.dom; )
            s = Zd(s);
        else
          n.insertBefore(o.dom, s);
        r = o.dom;
      }
      for (s = r ? r.nextSibling : n.firstChild, s && t && t.node == n && (t.written = !0); s; )
        s = Zd(s);
    } else if (this.flags & 1)
      for (let n of this.children)
        n.flags & 7 && (n.sync(e, t), n.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let n;
    if (e == this.dom)
      n = this.dom.childNodes[t];
    else {
      let r = Ji(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        r == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? r = -1 : r = 1), e = s;
      }
      r < 0 ? n = e : n = e.nextSibling;
    }
    if (n == this.dom.firstChild)
      return 0;
    for (; n && !ze.get(n); )
      n = n.nextSibling;
    if (!n)
      return this.length;
    for (let r = 0, s = 0; ; r++) {
      let o = this.children[r];
      if (o.dom == n)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, t, n = 0) {
    let r = -1, s = -1, o = -1, a = -1;
    for (let l = 0, c = n, h = n; l < this.children.length; l++) {
      let f = this.children[l], u = c + f.length;
      if (c < e && u > t)
        return f.domBoundsAround(e, t, c);
      if (u >= e && r == -1 && (r = l, s = c), c > t && f.dom.parentNode == this.dom) {
        o = l, a = h;
        break;
      }
      h = u, c = u + f.breakAfter;
    }
    return {
      from: s,
      to: a < 0 ? n + this.length : a,
      startDOM: (r ? this.children[r - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, n = Yf) {
    this.markDirty();
    for (let r = e; r < t; r++) {
      let s = this.children[r];
      s.parent == this && n.indexOf(s) < 0 && s.destroy();
    }
    n.length < 250 ? this.children.splice(e, t - e, ...n) : this.children = [].concat(this.children.slice(0, e), n, this.children.slice(t));
    for (let r = 0; r < n.length; r++)
      n[r].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new Dg(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, n, r, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
ze.prototype.breakAfter = 0;
function Zd(i) {
  let e = i.nextSibling;
  return i.parentNode.removeChild(i), e;
}
class Dg {
  constructor(e, t, n) {
    this.children = e, this.pos = t, this.i = n, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let n = this.children[--this.i];
      this.pos -= n.length + n.breakAfter;
    }
  }
}
function Lg(i, e, t, n, r, s, o, a, l) {
  let { children: c } = i, h = c.length ? c[e] : null, f = s.length ? s[s.length - 1] : null, u = f ? f.breakAfter : o;
  if (!(e == n && h && !o && !u && s.length < 2 && h.merge(t, r, s.length ? f : null, t == 0, a, l))) {
    if (n < c.length) {
      let d = c[n];
      d && (r < d.length || d.breakAfter && f?.breakAfter) ? (e == n && (d = d.split(r), r = 0), !u && f && d.merge(0, r, f, !0, 0, l) ? s[s.length - 1] = d : ((r || d.children.length && !d.children[0].length) && d.merge(0, r, null, !1, 0, l), s.push(d))) : d?.breakAfter && (f ? f.breakAfter = 1 : o = 1), n++;
    }
    for (h && (h.breakAfter = o, t > 0 && (!o && s.length && h.merge(t, h.length, s[0], !1, a, 0) ? h.breakAfter = s.shift().breakAfter : (t < h.length || h.children.length && h.children[h.children.length - 1].length == 0) && h.merge(t, h.length, null, !1, a, 0), e++)); e < n && s.length; )
      if (c[n - 1].become(s[s.length - 1]))
        n--, s.pop(), l = s.length ? 0 : a;
      else if (c[e].become(s[0]))
        e++, s.shift(), a = s.length ? 0 : l;
      else
        break;
    !s.length && e && n < c.length && !c[e - 1].breakAfter && c[n].merge(0, 0, c[e - 1], !1, a, l) && e--, (e < n || s.length) && i.replaceChildren(e, n, s);
  }
}
function Ig(i, e, t, n, r, s) {
  let o = i.childCursor(), { i: a, off: l } = o.findPos(t, 1), { i: c, off: h } = o.findPos(e, -1), f = e - t;
  for (let u of n)
    f += u.length;
  i.length += f, Lg(i, c, h, a, l, n, 0, r, s);
}
const _w = 256;
class ki extends ze {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, n) {
    return this.flags & 8 || n && (!(n instanceof ki) || this.length - (t - e) + n.length > _w || n.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (n ? n.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new ki(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new xt(this.dom, e);
  }
  domBoundsAround(e, t, n) {
    return { from: n, to: n + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return Pw(this.dom, e, t);
  }
}
class xn extends ze {
  constructor(e, t = [], n = 0) {
    super(), this.mark = e, this.children = t, this.length = n;
    for (let r of t)
      r.setParent(this);
  }
  setAttrs(e) {
    if (Mg(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, n, r, s, o) {
    return n && (!(n instanceof xn && n.mark.eq(this.mark)) || e && s <= 0 || t < this.length && o <= 0) ? !1 : (Ig(this, e, t, n ? n.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], n = 0, r = -1, s = 0;
    for (let a of this.children) {
      let l = n + a.length;
      l > e && t.push(n < e ? a.split(e - n) : a), r < 0 && n >= e && (r = s), n = l, s++;
    }
    let o = this.length - e;
    return this.length = e, r > -1 && (this.children.length = r, this.markDirty()), new xn(this.mark, t, o);
  }
  domAtPos(e) {
    return Bg(this, e);
  }
  coordsAt(e, t) {
    return Ng(this, e, t);
  }
}
function Pw(i, e, t) {
  let n = i.nodeValue.length;
  e > n && (e = n);
  let r = e, s = e, o = 0;
  e == 0 && t < 0 || e == n && t >= 0 ? re.chrome || re.gecko || (e ? (r--, o = 1) : s < n && (s++, o = -1)) : t < 0 ? r-- : s < n && s++;
  let a = gr(i, r, s).getClientRects();
  if (!a.length)
    return null;
  let l = a[(o ? o < 0 : t >= 0) ? 0 : a.length - 1];
  return re.safari && !o && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), o ? Cl(l, o < 0) : l || null;
}
class En extends ze {
  static create(e, t, n) {
    return new En(e, t, n);
  }
  constructor(e, t, n) {
    super(), this.widget = e, this.length = t, this.side = n, this.prevWidget = null;
  }
  split(e) {
    let t = En.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, t, n, r, s, o) {
    return n && (!(n instanceof En) || !this.widget.compare(n.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (n ? n.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof En && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Re.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, n = t && t.state.doc, r = this.posAtStart;
    return n ? n.slice(r, r + this.length) : Re.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? xt.before(this.dom) : xt.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let n = this.widget.coordsAt(this.dom, e, t);
    if (n)
      return n;
    let r = this.dom.getClientRects(), s = null;
    if (!r.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let a = o ? r.length - 1 : 0; s = r[a], !(e > 0 ? a == 0 : a == r.length - 1 || s.top < s.bottom); a += o ? -1 : 1)
      ;
    return Cl(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Kr extends ze {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Kr && e.side == this.side;
  }
  split() {
    return new Kr(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? xt.before(this.dom) : xt.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Re.empty;
  }
  get isHidden() {
    return !0;
  }
}
ki.prototype.children = En.prototype.children = Kr.prototype.children = Yf;
function Bg(i, e) {
  let t = i.dom, { children: n } = i, r = 0;
  for (let s = 0; r < n.length; r++) {
    let o = n[r], a = s + o.length;
    if (!(a == s && o.getSide() <= 0)) {
      if (e > s && e < a && o.dom.parentNode == t)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = a;
    }
  }
  for (let s = r; s > 0; s--) {
    let o = n[s - 1];
    if (o.dom.parentNode == t)
      return o.domAtPos(o.length);
  }
  for (let s = r; s < n.length; s++) {
    let o = n[s];
    if (o.dom.parentNode == t)
      return o.domAtPos(0);
  }
  return new xt(t, 0);
}
function Yg(i, e, t) {
  let n, { children: r } = i;
  t > 0 && e instanceof xn && r.length && (n = r[r.length - 1]) instanceof xn && n.mark.eq(e.mark) ? Yg(n, e.children[0], t - 1) : (r.push(e), e.setParent(i)), i.length += e.length;
}
function Ng(i, e, t) {
  let n = null, r = -1, s = null, o = -1;
  function a(c, h) {
    for (let f = 0, u = 0; f < c.children.length && u <= h; f++) {
      let d = c.children[f], p = u + d.length;
      p >= h && (d.children.length ? a(d, h - u) : (!s || s.isHidden && (t > 0 || Tw(s, d))) && (p > h || u == p && d.getSide() > 0) ? (s = d, o = h - u) : (u < h || u == p && d.getSide() < 0 && !d.isHidden) && (n = d, r = h - u)), u = p;
    }
  }
  a(i, e);
  let l = (t < 0 ? n : s) || n || s;
  return l ? l.coordsAt(Math.max(0, l == n ? r : o), t) : $w(i);
}
function $w(i) {
  let e = i.dom.lastChild;
  if (!e)
    return i.dom.getBoundingClientRect();
  let t = oo(e);
  return t[t.length - 1] || null;
}
function Tw(i, e) {
  let t = i.coordsAt(0, 1), n = e.coordsAt(0, 1);
  return t && n && n.top < t.bottom;
}
function Xh(i, e) {
  for (let t in i)
    t == "class" && e.class ? e.class += " " + i.class : t == "style" && e.style ? e.style += ";" + i.style : e[t] = i[t];
  return e;
}
const Xd = /* @__PURE__ */ Object.create(null);
function Va(i, e, t) {
  if (i == e)
    return !0;
  i || (i = Xd), e || (e = Xd);
  let n = Object.keys(i), r = Object.keys(e);
  if (n.length - (t && n.indexOf(t) > -1 ? 1 : 0) != r.length - (t && r.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let s of n)
    if (s != t && (r.indexOf(s) == -1 || i[s] !== e[s]))
      return !1;
  return !0;
}
function zh(i, e, t) {
  let n = !1;
  if (e)
    for (let r in e)
      t && r in t || (n = !0, r == "style" ? i.style.cssText = "" : i.removeAttribute(r));
  if (t)
    for (let r in t)
      e && e[r] == t[r] || (n = !0, r == "style" ? i.style.cssText = t[r] : i.setAttribute(r, t[r]));
  return n;
}
function Cw(i) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < i.attributes.length; t++) {
    let n = i.attributes[t];
    e[n.name] = n.value;
  }
  return e;
}
class Pn {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedâ€”less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, n) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Mt = /* @__PURE__ */ (function(i) {
  return i[i.Text = 0] = "Text", i[i.WidgetBefore = 1] = "WidgetBefore", i[i.WidgetAfter = 2] = "WidgetAfter", i[i.WidgetRange = 3] = "WidgetRange", i;
})(Mt || (Mt = {}));
class pe extends Or {
  constructor(e, t, n, r) {
    super(), this.startSide = e, this.endSide = t, this.widget = n, this.spec = r;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new $o(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), n = !!e.block;
    return t += n && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new Yn(e, t, t, n, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, n, r;
    if (e.isBlockGap)
      n = -5e8, r = 4e8;
    else {
      let { start: s, end: o } = Vg(e, t);
      n = (s ? t ? -3e8 : -1 : 5e8) - 1, r = (o ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new Yn(e, n, r, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new To(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return Te.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
pe.none = Te.empty;
class $o extends pe {
  constructor(e) {
    let { start: t, end: n } = Vg(e);
    super(t ? -1 : 5e8, n ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, n;
    return this == e || e instanceof $o && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((n = e.attrs) === null || n === void 0 ? void 0 : n.class)) && Va(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
$o.prototype.point = !1;
class To extends pe {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof To && this.spec.class == e.spec.class && Va(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
To.prototype.mapMode = Ot.TrackBefore;
To.prototype.point = !0;
class Yn extends pe {
  constructor(e, t, n, r, s, o) {
    super(t, n, s, e), this.block = r, this.isReplace = o, this.mapMode = r ? t <= 0 ? Ot.TrackBefore : Ot.TrackAfter : Ot.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Mt.WidgetRange : this.startSide <= 0 ? Mt.WidgetBefore : Mt.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Yn && Aw(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
Yn.prototype.point = !0;
function Vg(i, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: n } = i;
  return t == null && (t = i.inclusive), n == null && (n = i.inclusive), { start: t ?? e, end: n ?? e };
}
function Aw(i, e) {
  return i == e || !!(i && e && i.compare(e));
}
function ka(i, e, t, n = 0) {
  let r = t.length - 1;
  r >= 0 && t[r] + n >= i ? t[r] = Math.max(t[r], e) : t.push(i, e);
}
class rt extends ze {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, n, r, s, o) {
    if (n) {
      if (!(n instanceof rt))
        return !1;
      this.dom || n.transferDOM(this);
    }
    return r && this.setDeco(n ? n.attrs : null), Ig(this, e, t, n ? n.children.slice() : [], s, o), !0;
  }
  split(e) {
    let t = new rt();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i: n, off: r } = this.childPos(e);
    r && (t.append(this.children[n].split(r), 0), this.children[n].merge(r, this.children[n].length, null, !1, 0, 0), n++);
    for (let s = n; s < this.children.length; s++)
      t.append(this.children[s], 0);
    for (; n > 0 && this.children[n - 1].length == 0; )
      this.children[--n].destroy();
    return this.children.length = n, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Va(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    Yg(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, n = e.spec.class;
    t && (this.attrs = Xh(t, this.attrs || {})), n && (this.attrs = Xh({ class: n }, this.attrs || {}));
  }
  domAtPos(e) {
    return Bg(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var n;
    this.dom ? this.flags & 4 && (Mg(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (zh(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let r = this.dom.lastChild;
    for (; r && ze.get(r) instanceof xn; )
      r = r.lastChild;
    if (!r || !this.length || r.nodeName != "BR" && ((n = ze.get(r)) === null || n === void 0 ? void 0 : n.isEditable) == !1 && (!re.ios || !this.children.some((s) => s instanceof ki))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let n of this.children) {
      if (!(n instanceof ki) || /[^ -~]/.test(n.text))
        return null;
      let r = oo(n.dom);
      if (r.length != 1)
        return null;
      e += r[0].width, t = r[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let n = Ng(this, e, t);
    if (!this.children.length && n && this.parent) {
      let { heightOracle: r } = this.parent.view.viewState, s = n.bottom - n.top;
      if (Math.abs(s - r.lineHeight) < 2 && r.textHeight < s) {
        let o = (s - r.textHeight) / 2;
        return { top: n.top + o, bottom: n.bottom - o, left: n.left, right: n.left };
      }
    }
    return n;
  }
  become(e) {
    return e instanceof rt && this.children.length == 0 && e.children.length == 0 && Va(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, t) {
    for (let n = 0, r = 0; n < e.children.length; n++) {
      let s = e.children[n], o = r + s.length;
      if (o >= t) {
        if (s instanceof rt)
          return s;
        if (o > t)
          break;
      }
      r = o + s.breakAfter;
    }
    return null;
  }
}
class yn extends ze {
  constructor(e, t, n) {
    super(), this.widget = e, this.length = t, this.deco = n, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, n, r, s, o) {
    return n && (!(n instanceof yn) || !this.widget.compare(n.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (n ? n.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? xt.before(this.dom) : xt.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let n = new yn(this.widget, t, this.deco);
    return n.breakAfter = this.breakAfter, n;
  }
  get children() {
    return Yf;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Re.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof yn && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    let n = this.widget.coordsAt(this.dom, e, t);
    return n || (this.widget instanceof Dh ? null : Cl(this.dom.getBoundingClientRect(), this.length ? e == 0 : t <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: t, endSide: n } = this.deco;
    return t == n ? !1 : e < 0 ? t < 0 : n > 0;
  }
}
class Dh extends Pn {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class Fs {
  constructor(e, t, n, r) {
    this.doc = e, this.pos = t, this.end = n, this.disallowBlockEffectsFor = r, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof yn && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new rt()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Wo(new Kr(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof yn) && this.getLine();
  }
  buildText(e, t, n) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: o, lineBreak: a, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (a) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = o, this.textOff = 0;
      }
      let r = Math.min(this.text.length - this.textOff, e), s = Math.min(
        r,
        512
        /* T.Chunk */
      );
      this.flushBuffer(t.slice(t.length - n)), this.getLine().append(Wo(new ki(this.text.slice(this.textOff, this.textOff + s)), t), n), this.atCursorPos = !0, this.textOff += s, e -= s, n = r <= s ? 0 : t.length;
    }
  }
  span(e, t, n, r) {
    this.buildText(t - e, n, r), this.pos = t, this.openStart < 0 && (this.openStart = r);
  }
  point(e, t, n, r, s, o) {
    if (this.disallowBlockEffectsFor[o] && n instanceof Yn) {
      if (n.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = t - e;
    if (n instanceof Yn)
      if (n.block)
        n.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new yn(n.widget || Jr.block, a, n));
      else {
        let l = En.create(n.widget || Jr.inline, a, a ? 0 : n.startSide), c = this.atCursorPos && !l.isEditable && s <= r.length && (e < t || n.startSide > 0), h = !l.isEditable && (e < t || s > r.length || n.startSide <= 0), f = this.getLine();
        this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(r), c && (f.append(Wo(new Kr(1), r), s), s = r.length + Math.max(0, s - r.length)), f.append(Wo(l, r), s), this.atCursorPos = h, this.pendingBuffer = h ? e < t || s > r.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = r.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(n);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, t, n, r, s) {
    let o = new Fs(e, t, n, s);
    return o.openEnd = Te.spans(r, t, n, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function Wo(i, e) {
  for (let t of e)
    i = new xn(t, [i], i.length);
  return i;
}
class Jr extends Pn {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
Jr.inline = /* @__PURE__ */ new Jr("span");
Jr.block = /* @__PURE__ */ new Jr("div");
var We = /* @__PURE__ */ (function(i) {
  return i[i.LTR = 0] = "LTR", i[i.RTL = 1] = "RTL", i;
})(We || (We = {}));
const br = We.LTR, Nf = We.RTL;
function qg(i) {
  let e = [];
  for (let t = 0; t < i.length; t++)
    e.push(1 << +i[t]);
  return e;
}
const Rw = /* @__PURE__ */ qg("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), Ew = /* @__PURE__ */ qg("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Lh = /* @__PURE__ */ Object.create(null), Ri = [];
for (let i of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ i.charCodeAt(0), t = /* @__PURE__ */ i.charCodeAt(1);
  Lh[e] = t, Lh[t] = -e;
}
function Wg(i) {
  return i <= 247 ? Rw[i] : 1424 <= i && i <= 1524 ? 2 : 1536 <= i && i <= 1785 ? Ew[i - 1536] : 1774 <= i && i <= 2220 ? 4 : 8192 <= i && i <= 8204 ? 256 : 64336 <= i && i <= 65023 ? 4 : 1;
}
const Mw = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Mn {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? Nf : br;
  }
  /**
  @internal
  */
  constructor(e, t, n) {
    this.from = e, this.to = t, this.level = n;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, t) {
    return e == (this.dir == t);
  }
  /**
  @internal
  */
  static find(e, t, n, r) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      if (a.from <= t && a.to >= t) {
        if (a.level == n)
          return o;
        (s < 0 || (r != 0 ? r < 0 ? a.from < t : a.to > t : e[s].level > a.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function jg(i, e) {
  if (i.length != e.length)
    return !1;
  for (let t = 0; t < i.length; t++) {
    let n = i[t], r = e[t];
    if (n.from != r.from || n.to != r.to || n.direction != r.direction || !jg(n.inner, r.inner))
      return !1;
  }
  return !0;
}
const Le = [];
function Zw(i, e, t, n, r) {
  for (let s = 0; s <= n.length; s++) {
    let o = s ? n[s - 1].to : e, a = s < n.length ? n[s].from : t, l = s ? 256 : r;
    for (let c = o, h = l, f = l; c < a; c++) {
      let u = Wg(i.charCodeAt(c));
      u == 512 ? u = h : u == 8 && f == 4 && (u = 16), Le[c] = u == 4 ? 2 : u, u & 7 && (f = u), h = u;
    }
    for (let c = o, h = l, f = l; c < a; c++) {
      let u = Le[c];
      if (u == 128)
        c < a - 1 && h == Le[c + 1] && h & 24 ? u = Le[c] = h : Le[c] = 256;
      else if (u == 64) {
        let d = c + 1;
        for (; d < a && Le[d] == 64; )
          d++;
        let p = c && h == 8 || d < t && Le[d] == 8 ? f == 1 ? 1 : 8 : 256;
        for (let O = c; O < d; O++)
          Le[O] = p;
        c = d - 1;
      } else u == 8 && f == 1 && (Le[c] = 1);
      h = u, u & 7 && (f = u);
    }
  }
}
function Xw(i, e, t, n, r) {
  let s = r == 1 ? 2 : 1;
  for (let o = 0, a = 0, l = 0; o <= n.length; o++) {
    let c = o ? n[o - 1].to : e, h = o < n.length ? n[o].from : t;
    for (let f = c, u, d, p; f < h; f++)
      if (d = Lh[u = i.charCodeAt(f)])
        if (d < 0) {
          for (let O = a - 3; O >= 0; O -= 3)
            if (Ri[O + 1] == -d) {
              let m = Ri[O + 2], g = m & 2 ? r : m & 4 ? m & 1 ? s : r : 0;
              g && (Le[f] = Le[Ri[O]] = g), a = O;
              break;
            }
        } else {
          if (Ri.length == 189)
            break;
          Ri[a++] = f, Ri[a++] = u, Ri[a++] = l;
        }
      else if ((p = Le[f]) == 2 || p == 1) {
        let O = p == r;
        l = O ? 0 : 1;
        for (let m = a - 3; m >= 0; m -= 3) {
          let g = Ri[m + 2];
          if (g & 2)
            break;
          if (O)
            Ri[m + 2] |= 2;
          else {
            if (g & 4)
              break;
            Ri[m + 2] |= 4;
          }
        }
      }
  }
}
function zw(i, e, t, n) {
  for (let r = 0, s = n; r <= t.length; r++) {
    let o = r ? t[r - 1].to : i, a = r < t.length ? t[r].from : e;
    for (let l = o; l < a; ) {
      let c = Le[l];
      if (c == 256) {
        let h = l + 1;
        for (; ; )
          if (h == a) {
            if (r == t.length)
              break;
            h = t[r++].to, a = r < t.length ? t[r].from : e;
          } else if (Le[h] == 256)
            h++;
          else
            break;
        let f = s == 1, u = (h < e ? Le[h] : n) == 1, d = f == u ? f ? 1 : 2 : n;
        for (let p = h, O = r, m = O ? t[O - 1].to : i; p > l; )
          p == m && (p = t[--O].from, m = O ? t[O - 1].to : i), Le[--p] = d;
        l = h;
      } else
        s = c, l++;
    }
  }
}
function Ih(i, e, t, n, r, s, o) {
  let a = n % 2 ? 2 : 1;
  if (n % 2 == r % 2)
    for (let l = e, c = 0; l < t; ) {
      let h = !0, f = !1;
      if (c == s.length || l < s[c].from) {
        let O = Le[l];
        O != a && (h = !1, f = O == 16);
      }
      let u = !h && a == 1 ? [] : null, d = h ? n : n + 1, p = l;
      e: for (; ; )
        if (c < s.length && p == s[c].from) {
          if (f)
            break e;
          let O = s[c];
          if (!h)
            for (let m = O.to, g = c + 1; ; ) {
              if (m == t)
                break e;
              if (g < s.length && s[g].from == m)
                m = s[g++].to;
              else {
                if (Le[m] == a)
                  break e;
                break;
              }
            }
          if (c++, u)
            u.push(O);
          else {
            O.from > l && o.push(new Mn(l, O.from, d));
            let m = O.direction == br != !(d % 2);
            Bh(i, m ? n + 1 : n, r, O.inner, O.from, O.to, o), l = O.to;
          }
          p = O.to;
        } else {
          if (p == t || (h ? Le[p] != a : Le[p] == a))
            break;
          p++;
        }
      u ? Ih(i, l, p, n + 1, r, u, o) : l < p && o.push(new Mn(l, p, d)), l = p;
    }
  else
    for (let l = t, c = s.length; l > e; ) {
      let h = !0, f = !1;
      if (!c || l > s[c - 1].to) {
        let O = Le[l - 1];
        O != a && (h = !1, f = O == 16);
      }
      let u = !h && a == 1 ? [] : null, d = h ? n : n + 1, p = l;
      e: for (; ; )
        if (c && p == s[c - 1].to) {
          if (f)
            break e;
          let O = s[--c];
          if (!h)
            for (let m = O.from, g = c; ; ) {
              if (m == e)
                break e;
              if (g && s[g - 1].to == m)
                m = s[--g].from;
              else {
                if (Le[m - 1] == a)
                  break e;
                break;
              }
            }
          if (u)
            u.push(O);
          else {
            O.to < l && o.push(new Mn(O.to, l, d));
            let m = O.direction == br != !(d % 2);
            Bh(i, m ? n + 1 : n, r, O.inner, O.from, O.to, o), l = O.from;
          }
          p = O.from;
        } else {
          if (p == e || (h ? Le[p - 1] != a : Le[p - 1] == a))
            break;
          p--;
        }
      u ? Ih(i, p, l, n + 1, r, u, o) : p < l && o.push(new Mn(p, l, d)), l = p;
    }
}
function Bh(i, e, t, n, r, s, o) {
  let a = e % 2 ? 2 : 1;
  Zw(i, r, s, n, a), Xw(i, r, s, n, a), zw(r, s, n, a), Ih(i, r, s, e, t, n, o);
}
function Dw(i, e, t) {
  if (!i)
    return [new Mn(0, 0, e == Nf ? 1 : 0)];
  if (e == br && !t.length && !Mw.test(i))
    return Ug(i.length);
  if (t.length)
    for (; i.length > Le.length; )
      Le[Le.length] = 256;
  let n = [], r = e == br ? 0 : 1;
  return Bh(i, r, r, t, 0, i.length, n), n;
}
function Ug(i) {
  return [new Mn(0, i, 0)];
}
let Gg = "";
function Lw(i, e, t, n, r) {
  var s;
  let o = n.head - i.from, a = Mn.find(e, o, (s = n.bidiLevel) !== null && s !== void 0 ? s : -1, n.assoc), l = e[a], c = l.side(r, t);
  if (o == c) {
    let u = a += r ? 1 : -1;
    if (u < 0 || u >= e.length)
      return null;
    l = e[a = u], o = l.side(!r, t), c = l.side(r, t);
  }
  let h = gt(i.text, o, l.forward(r, t));
  (h < l.from || h > l.to) && (h = c), Gg = i.text.slice(Math.min(o, h), Math.max(o, h));
  let f = a == (r ? e.length - 1 : 0) ? null : e[a + (r ? 1 : -1)];
  return f && h == c && f.level + (r ? 0 : 1) < l.level ? q.cursor(f.side(!r, t) + i.from, f.forward(r, t) ? 1 : -1, f.level) : q.cursor(h + i.from, l.forward(r, t) ? -1 : 1, l.level);
}
function Iw(i, e, t) {
  for (let n = e; n < t; n++) {
    let r = Wg(i.charCodeAt(n));
    if (r == 1)
      return br;
    if (r == 2 || r == 4)
      return Nf;
  }
  return br;
}
const Fg = /* @__PURE__ */ le.define(), Hg = /* @__PURE__ */ le.define(), Kg = /* @__PURE__ */ le.define(), Jg = /* @__PURE__ */ le.define(), Yh = /* @__PURE__ */ le.define(), e0 = /* @__PURE__ */ le.define(), t0 = /* @__PURE__ */ le.define(), Vf = /* @__PURE__ */ le.define(), qf = /* @__PURE__ */ le.define(), i0 = /* @__PURE__ */ le.define({
  combine: (i) => i.some((e) => e)
}), n0 = /* @__PURE__ */ le.define({
  combine: (i) => i.some((e) => e)
}), r0 = /* @__PURE__ */ le.define();
class Yr {
  constructor(e, t = "nearest", n = "nearest", r = 5, s = 5, o = !1) {
    this.range = e, this.y = t, this.x = n, this.yMargin = r, this.xMargin = s, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new Yr(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new Yr(q.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const jo = /* @__PURE__ */ ge.define({ map: (i, e) => i.map(e) }), s0 = /* @__PURE__ */ ge.define();
function Wt(i, e, t) {
  let n = i.facet(Jg);
  n.length ? n[0](e) : window.onerror && window.onerror(String(e), t, void 0, void 0, e) || (t ? console.error(t + ":", e) : console.error(e));
}
const On = /* @__PURE__ */ le.define({ combine: (i) => i.length ? i[0] : !0 });
let Bw = 0;
const Zr = /* @__PURE__ */ le.define({
  combine(i) {
    return i.filter((e, t) => {
      for (let n = 0; n < t; n++)
        if (i[n].plugin == e.plugin)
          return !1;
      return !0;
    });
  }
});
class ot {
  constructor(e, t, n, r, s) {
    this.id = e, this.create = t, this.domEventHandlers = n, this.domEventObservers = r, this.baseExtensions = s(this), this.extension = this.baseExtensions.concat(Zr.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(e) {
    return this.baseExtensions.concat(Zr.of({ plugin: this, arg: e }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: n, eventObservers: r, provide: s, decorations: o } = t || {};
    return new ot(Bw++, e, n, r, (a) => {
      let l = [];
      return o && l.push(ao.of((c) => {
        let h = c.plugin(a);
        return h ? o(h) : pe.none;
      })), s && l.push(s(a)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return ot.define((n, r) => new e(n, r), t);
  }
}
class dc {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (n) {
            if (Wt(t.state, n, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(e, this.spec.arg);
      } catch (t) {
        Wt(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (n) {
        Wt(e.state, n, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const o0 = /* @__PURE__ */ le.define(), Wf = /* @__PURE__ */ le.define(), ao = /* @__PURE__ */ le.define(), a0 = /* @__PURE__ */ le.define(), Co = /* @__PURE__ */ le.define(), l0 = /* @__PURE__ */ le.define();
function zd(i, e) {
  let t = i.state.facet(l0);
  if (!t.length)
    return t;
  let n = t.map((s) => s instanceof Function ? s(i) : s), r = [];
  return Te.spans(n, e.from, e.to, {
    point() {
    },
    span(s, o, a, l) {
      let c = s - e.from, h = o - e.from, f = r;
      for (let u = a.length - 1; u >= 0; u--, l--) {
        let d = a[u].spec.bidiIsolate, p;
        if (d == null && (d = Iw(e.text, c, h)), l > 0 && f.length && (p = f[f.length - 1]).to == c && p.direction == d)
          p.to = h, f = p.inner;
        else {
          let O = { from: c, to: h, direction: d, inner: [] };
          f.push(O), f = O.inner;
        }
      }
    }
  }), r;
}
const c0 = /* @__PURE__ */ le.define();
function jf(i) {
  let e = 0, t = 0, n = 0, r = 0;
  for (let s of i.state.facet(c0)) {
    let o = s(i);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (t = Math.max(t, o.right)), o.top != null && (n = Math.max(n, o.top)), o.bottom != null && (r = Math.max(r, o.bottom)));
  }
  return { left: e, right: t, top: n, bottom: r };
}
const Is = /* @__PURE__ */ le.define();
class ui {
  constructor(e, t, n, r) {
    this.fromA = e, this.toA = t, this.fromB = n, this.toB = r;
  }
  join(e) {
    return new ui(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, n = this;
    for (; t > 0; t--) {
      let r = e[t - 1];
      if (!(r.fromA > n.toA)) {
        if (r.toA < n.fromA)
          break;
        n = n.join(r), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, n), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let n = [];
    for (let r = 0, s = 0, o = 0, a = 0; ; r++) {
      let l = r == e.length ? null : e[r], c = o - a, h = l ? l.fromB : 1e9;
      for (; s < t.length && t[s] < h; ) {
        let f = t[s], u = t[s + 1], d = Math.max(a, f), p = Math.min(h, u);
        if (d <= p && new ui(d + c, p + c, d, p).addToSet(n), u > h)
          break;
        s += 2;
      }
      if (!l)
        return n;
      new ui(l.fromA, l.toA, l.fromB, l.toB).addToSet(n), o = l.toA, a = l.toB;
    }
  }
}
class qa {
  constructor(e, t, n) {
    this.view = e, this.state = t, this.transactions = n, this.flags = 0, this.startState = e.state, this.changes = lt.empty(this.startState.doc.length);
    for (let s of n)
      this.changes = this.changes.compose(s.changes);
    let r = [];
    this.changes.iterChangedRanges((s, o, a, l) => r.push(new ui(s, o, a, l))), this.changedRanges = r;
  }
  /**
  @internal
  */
  static create(e, t, n) {
    return new qa(e, t, n);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class Dd extends ze {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = pe.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new rt()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new ui(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var t;
    let n = e.changedRanges;
    this.minWidth > 0 && n.length && (n.every(({ fromA: c, toA: h }) => h < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let r = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((t = this.domChanged) === null || t === void 0) && t.newSel ? r = this.domChanged.newSel.head : !Uw(e.changes, this.hasComposition) && !e.selectionSet && (r = e.state.selection.main.head));
    let s = r > -1 ? Nw(this.view, e.changes, r) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: h } = this.hasComposition;
      n = new ui(c, h, e.changes.mapPos(c, -1), e.changes.mapPos(h, 1)).addToSet(n.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (re.ie || re.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, a = this.updateDeco(), l = Ww(o, a, e.changes);
    return n = ui.extendWithRanges(n, l), !(this.flags & 7) && n.length == 0 ? !1 : (this.updateInner(n, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t, n) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, n);
    let { observer: r } = this.view;
    r.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = re.chrome || re.ios ? { node: r.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || r.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof yn && o.widget instanceof Dh && s.push(o.dom);
    r.updateGaps(s);
  }
  updateChildren(e, t, n) {
    let r = n ? n.range.addToSet(e.slice()) : e, s = this.childCursor(t);
    for (let o = r.length - 1; ; o--) {
      let a = o >= 0 ? r[o] : null;
      if (!a)
        break;
      let { fromA: l, toA: c, fromB: h, toB: f } = a, u, d, p, O;
      if (n && n.range.fromB < f && n.range.toB > h) {
        let w = Fs.build(this.view.state.doc, h, n.range.fromB, this.decorations, this.dynamicDecorationMap), x = Fs.build(this.view.state.doc, n.range.toB, f, this.decorations, this.dynamicDecorationMap);
        d = w.breakAtStart, p = w.openStart, O = x.openEnd;
        let P = this.compositionView(n);
        x.breakAtStart ? P.breakAfter = 1 : x.content.length && P.merge(P.length, P.length, x.content[0], !1, x.openStart, 0) && (P.breakAfter = x.content[0].breakAfter, x.content.shift()), w.content.length && P.merge(0, 0, w.content[w.content.length - 1], !0, 0, w.openEnd) && w.content.pop(), u = w.content.concat(P).concat(x.content);
      } else
        ({ content: u, breakAtStart: d, openStart: p, openEnd: O } = Fs.build(this.view.state.doc, h, f, this.decorations, this.dynamicDecorationMap));
      let { i: m, off: g } = s.findPos(c, 1), { i: v, off: S } = s.findPos(l, -1);
      Lg(this, v, S, m, g, u, d, p, O);
    }
    n && this.fixCompositionDOM(n);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let t of e.transactions)
      for (let n of t.effects)
        n.is(s0) && (this.editContextFormatting = n.value);
  }
  compositionView(e) {
    let t = new ki(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: r } of e.marks)
      t = new xn(r, [t], t.length);
    let n = new rt();
    return n.append(t, 0), n;
  }
  fixCompositionDOM(e) {
    let t = (s, o) => {
      o.flags |= 8 | (o.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let a = ze.get(s);
      a && a != o && (a.dom = null), o.setDOM(s);
    }, n = this.childPos(e.range.fromB, 1), r = this.children[n.i];
    t(e.line, r);
    for (let s = e.marks.length - 1; s >= -1; s--)
      n = r.childPos(n.off, 1), r = r.children[n.i], t(s >= 0 ? e.marks[s].node : e.text, r);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let n = this.view.root.activeElement, r = n == this.dom, s = !r && !(this.view.state.facet(On) || this.dom.tabIndex > -1) && xa(this.dom, this.view.observer.selectionRange) && !(n && this.dom.contains(n));
    if (!(r || t || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (re.gecko && a.empty && !this.hasComposition && Yw(l)) {
      let f = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(f, l.node.childNodes[l.offset] || null)), l = c = new xt(f, 0), o = !0;
    }
    let h = this.view.observer.selectionRange;
    (o || !h.focusNode || (!Gs(l.node, l.offset, h.anchorNode, h.anchorOffset) || !Gs(c.node, c.offset, h.focusNode, h.focusOffset)) && !this.suppressWidgetCursorChange(h, a)) && (this.view.observer.ignore(() => {
      re.android && re.chrome && this.dom.contains(h.focusNode) && jw(h.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let f = so(this.view.root);
      if (f) if (a.empty) {
        if (re.gecko) {
          let u = Vw(l.node, l.offset);
          if (u && u != 3) {
            let d = (u == 1 ? Xg : zg)(l.node, l.offset);
            d && (l = new xt(d.node, d.offset));
          }
        }
        f.collapse(l.node, l.offset), a.bidiLevel != null && f.caretBidiLevel !== void 0 && (f.caretBidiLevel = a.bidiLevel);
      } else if (f.extend) {
        f.collapse(l.node, l.offset);
        try {
          f.extend(c.node, c.offset);
        } catch {
        }
      } else {
        let u = document.createRange();
        a.anchor > a.head && ([l, c] = [c, l]), u.setEnd(c.node, c.offset), u.setStart(l.node, l.offset), f.removeAllRanges(), f.addRange(u);
      }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), n && n.focus());
    }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new xt(h.anchorNode, h.anchorOffset), this.impreciseHead = c.precise ? null : new xt(h.focusNode, h.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, t) {
    return this.hasComposition && t.empty && Gs(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == t.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, n = so(e.root), { anchorNode: r, anchorOffset: s } = e.observer.selectionRange;
    if (!n || !t.empty || !t.assoc || !n.modify)
      return;
    let o = rt.find(this, t.head);
    if (!o)
      return;
    let a = o.posAtStart;
    if (t.head == a || t.head == a + o.length)
      return;
    let l = this.coordsAt(t.head, -1), c = this.coordsAt(t.head, 1);
    if (!l || !c || l.bottom > c.top)
      return;
    let h = this.domAtPos(t.head + t.assoc);
    n.collapse(h.node, h.offset), n.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let f = e.observer.selectionRange;
    e.docView.posFromDOM(f.anchorNode, f.anchorOffset) != t.from && n.collapse(r, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let t = this.dom, n;
    if (e.node != t)
      return e;
    for (let r = e.offset; !n && r < t.childNodes.length; r++) {
      let s = ze.get(t.childNodes[r]);
      s instanceof rt && (n = s.domAtPos(0));
    }
    for (let r = e.offset - 1; !n && r >= 0; r--) {
      let s = ze.get(t.childNodes[r]);
      s instanceof rt && (n = s.domAtPos(s.length));
    }
    return n ? new xt(n.node, n.offset, !0) : e;
  }
  nearest(e) {
    for (let t = e; t; ) {
      let n = ze.get(t);
      if (n && n.rootView == this)
        return n;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let n = this.nearest(e);
    if (!n)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return n.localPosFromDOM(e, t) + n.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: n } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let r = this.children[t];
      if (n < r.length || r instanceof rt)
        break;
      t++, n = 0;
    }
    return this.children[t].domAtPos(n);
  }
  coordsAt(e, t) {
    let n = null, r = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let a = this.children[o], l = s - a.breakAfter, c = l - a.length;
      if (l < e)
        break;
      if (c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!n || a instanceof rt && !(n instanceof rt && t >= 0)))
        n = a, r = c;
      else if (n && c == e && l == e && a instanceof yn && Math.abs(t) < 2) {
        if (a.deco.startSide < 0)
          break;
        o && (n = null);
      }
      s = c;
    }
    return n ? n.coordsAt(e - r, t) : null;
  }
  coordsForChar(e) {
    let { i: t, off: n } = this.childPos(e, 1), r = this.children[t];
    if (!(r instanceof rt))
      return null;
    for (; r.children.length; ) {
      let { i: a, off: l } = r.childPos(n, 1);
      for (; ; a++) {
        if (a == r.children.length)
          return null;
        if ((r = r.children[a]).length)
          break;
      }
      n = l;
    }
    if (!(r instanceof ki))
      return null;
    let s = gt(r.text, n);
    if (s == n)
      return null;
    let o = gr(r.dom, n, s).getClientRects();
    for (let a = 0; a < o.length; a++) {
      let l = o[a];
      if (a == o.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: n, to: r } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == We.LTR;
    for (let c = 0, h = 0; h < this.children.length; h++) {
      let f = this.children[h], u = c + f.length;
      if (u > r)
        break;
      if (c >= n) {
        let d = f.dom.getBoundingClientRect();
        if (t.push(d.height), o) {
          let p = f.dom.lastChild, O = p ? oo(p) : [];
          if (O.length) {
            let m = O[O.length - 1], g = l ? m.right - d.left : d.right - m.left;
            g > a && (a = g, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = u);
          }
        }
      }
      c = u + f.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? We.RTL : We.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof rt) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), t, n, r;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = oo(e.firstChild)[0];
      t = e.getBoundingClientRect().height, n = s ? s.width / 27 : 7, r = s ? s.height : t, e.remove();
    }), { lineHeight: t, charWidth: n, textHeight: r };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new Dg(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let n = 0, r = 0; ; r++) {
      let s = r == t.viewports.length ? null : t.viewports[r], o = s ? s.from - 1 : this.length;
      if (o > n) {
        let a = (t.lineBlockAt(o).bottom - t.lineBlockAt(n).top) / this.view.scaleY;
        e.push(pe.replace({
          widget: new Dh(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(n, o));
      }
      if (!s)
        break;
      n = s.to + 1;
    }
    return pe.set(e);
  }
  updateDeco() {
    let e = 1, t = this.view.state.facet(ao).map((s) => (this.dynamicDecorationMap[e++] = typeof s == "function") ? s(this.view) : s), n = !1, r = this.view.state.facet(a0).map((s, o) => {
      let a = typeof s == "function";
      return a && (n = !0), a ? s(this.view) : s;
    });
    for (r.length && (this.dynamicDecorationMap[e++] = n, t.push(Te.join(r))), this.decorations = [
      this.editContextFormatting,
      ...t,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let c of this.view.state.facet(r0))
      try {
        if (c(this.view, e.range, e))
          return !0;
      } catch (h) {
        Wt(this.view.state, h, "scroll handler");
      }
    let { range: t } = e, n = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), r;
    if (!n)
      return;
    !t.empty && (r = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (n = {
      left: Math.min(n.left, r.left),
      top: Math.min(n.top, r.top),
      right: Math.max(n.right, r.right),
      bottom: Math.max(n.bottom, r.bottom)
    });
    let s = jf(this.view), o = {
      left: n.left - s.left,
      top: n.top - s.top,
      right: n.right + s.right,
      bottom: n.bottom + s.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    Sw(this.view.scrollDOM, o, t.head < t.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == We.LTR);
  }
}
function Yw(i) {
  return i.node.nodeType == 1 && i.node.firstChild && (i.offset == 0 || i.node.childNodes[i.offset - 1].contentEditable == "false") && (i.offset == i.node.childNodes.length || i.node.childNodes[i.offset].contentEditable == "false");
}
function h0(i, e) {
  let t = i.observer.selectionRange;
  if (!t.focusNode)
    return null;
  let n = Xg(t.focusNode, t.focusOffset), r = zg(t.focusNode, t.focusOffset), s = n || r;
  if (r && n && r.node != n.node) {
    let a = ze.get(r.node);
    if (!a || a instanceof ki && a.text != r.node.nodeValue)
      s = r;
    else if (i.docView.lastCompositionAfterCursor) {
      let l = ze.get(n.node);
      !l || l instanceof ki && l.text != n.node.nodeValue || (s = r);
    }
  }
  if (i.docView.lastCompositionAfterCursor = s != n, !s)
    return null;
  let o = e - s.offset;
  return { from: o, to: o + s.node.nodeValue.length, node: s.node };
}
function Nw(i, e, t) {
  let n = h0(i, t);
  if (!n)
    return null;
  let { node: r, from: s, to: o } = n, a = r.nodeValue;
  if (/[\n\r]/.test(a) || i.state.doc.sliceString(n.from, n.to) != a)
    return null;
  let l = e.invertedDesc, c = new ui(l.mapPos(s), l.mapPos(o), s, o), h = [];
  for (let f = r.parentNode; ; f = f.parentNode) {
    let u = ze.get(f);
    if (u instanceof xn)
      h.push({ node: f, deco: u.mark });
    else {
      if (u instanceof rt || f.nodeName == "DIV" && f.parentNode == i.contentDOM)
        return { range: c, text: r, marks: h, line: f };
      if (f != i.contentDOM)
        h.push({ node: f, deco: new $o({
          inclusive: !0,
          attributes: Cw(f),
          tagName: f.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function Vw(i, e) {
  return i.nodeType != 1 ? 0 : (e && i.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < i.childNodes.length && i.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let qw = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    ka(e, t, this.changes);
  }
  comparePoint(e, t) {
    ka(e, t, this.changes);
  }
  boundChange(e) {
    ka(e, e, this.changes);
  }
};
function Ww(i, e, t) {
  let n = new qw();
  return Te.compare(i, e, t, n), n.changes;
}
function jw(i, e) {
  for (let t = i; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function Uw(i, e) {
  let t = !1;
  return e && i.iterChangedRanges((n, r) => {
    n < e.to && r > e.from && (t = !0);
  }), t;
}
function Gw(i, e, t = 1) {
  let n = i.charCategorizer(e), r = i.doc.lineAt(e), s = e - r.from;
  if (r.length == 0)
    return q.cursor(e);
  s == 0 ? t = 1 : s == r.length && (t = -1);
  let o = s, a = s;
  t < 0 ? o = gt(r.text, s, !1) : a = gt(r.text, s);
  let l = n(r.text.slice(o, a));
  for (; o > 0; ) {
    let c = gt(r.text, o, !1);
    if (n(r.text.slice(c, o)) != l)
      break;
    o = c;
  }
  for (; a < r.length; ) {
    let c = gt(r.text, a);
    if (n(r.text.slice(a, c)) != l)
      break;
    a = c;
  }
  return q.range(o + r.from, a + r.from);
}
function Fw(i, e) {
  return e.left > i ? e.left - i : Math.max(0, i - e.right);
}
function Hw(i, e) {
  return e.top > i ? e.top - i : Math.max(0, i - e.bottom);
}
function pc(i, e) {
  return i.top < e.bottom - 1 && i.bottom > e.top + 1;
}
function Ld(i, e) {
  return e < i.top ? { top: e, left: i.left, right: i.right, bottom: i.bottom } : i;
}
function Id(i, e) {
  return e > i.bottom ? { top: i.top, left: i.left, right: i.right, bottom: e } : i;
}
function Nh(i, e, t) {
  let n, r, s, o, a = !1, l, c, h, f;
  for (let p = i.firstChild; p; p = p.nextSibling) {
    let O = oo(p);
    for (let m = 0; m < O.length; m++) {
      let g = O[m];
      r && pc(r, g) && (g = Ld(Id(g, r.bottom), r.top));
      let v = Fw(e, g), S = Hw(t, g);
      if (v == 0 && S == 0)
        return p.nodeType == 3 ? Bd(p, e, t) : Nh(p, e, t);
      (!n || o > S || o == S && s > v) && (n = p, r = g, s = v, o = S, a = v ? e < g.left ? m > 0 : m < O.length - 1 : !0), v == 0 ? t > g.bottom && (!h || h.bottom < g.bottom) ? (l = p, h = g) : t < g.top && (!f || f.top > g.top) && (c = p, f = g) : h && pc(h, g) ? h = Id(h, g.bottom) : f && pc(f, g) && (f = Ld(f, g.top));
    }
  }
  if (h && h.bottom >= t ? (n = l, r = h) : f && f.top <= t && (n = c, r = f), !n)
    return { node: i, offset: 0 };
  let u = Math.max(r.left, Math.min(r.right, e));
  if (n.nodeType == 3)
    return Bd(n, u, t);
  if (a && n.contentEditable != "false")
    return Nh(n, u, t);
  let d = Array.prototype.indexOf.call(i.childNodes, n) + (e >= (r.left + r.right) / 2 ? 1 : 0);
  return { node: i, offset: d };
}
function Bd(i, e, t) {
  let n = i.nodeValue.length, r = -1, s = 1e9, o = 0;
  for (let a = 0; a < n; a++) {
    let l = gr(i, a, a + 1).getClientRects();
    for (let c = 0; c < l.length; c++) {
      let h = l[c];
      if (h.top == h.bottom)
        continue;
      o || (o = e - h.left);
      let f = (h.top > t ? h.top - t : t - h.bottom) - 1;
      if (h.left - 1 <= e && h.right + 1 >= e && f < s) {
        let u = e >= (h.left + h.right) / 2, d = u;
        if ((re.chrome || re.gecko) && gr(i, a).getBoundingClientRect().left == h.right && (d = !u), f <= 0)
          return { node: i, offset: a + (d ? 1 : 0) };
        r = a + (d ? 1 : 0), s = f;
      }
    }
  }
  return { node: i, offset: r > -1 ? r : o > 0 ? i.nodeValue.length : 0 };
}
function f0(i, e, t, n = -1) {
  var r, s;
  let o = i.contentDOM.getBoundingClientRect(), a = o.top + i.viewState.paddingTop, l, { docHeight: c } = i.viewState, { x: h, y: f } = e, u = f - a;
  if (u < 0)
    return 0;
  if (u > c)
    return i.state.doc.length;
  for (let w = i.viewState.heightOracle.textHeight / 2, x = !1; l = i.elementAtHeight(u), l.type != Mt.Text; )
    for (; u = n > 0 ? l.bottom + w : l.top - w, !(u >= 0 && u <= c); ) {
      if (x)
        return t ? null : 0;
      x = !0, n = -n;
    }
  f = a + u;
  let d = l.from;
  if (d < i.viewport.from)
    return i.viewport.from == 0 ? 0 : t ? null : Yd(i, o, l, h, f);
  if (d > i.viewport.to)
    return i.viewport.to == i.state.doc.length ? i.state.doc.length : t ? null : Yd(i, o, l, h, f);
  let p = i.dom.ownerDocument, O = i.root.elementFromPoint ? i.root : p, m = O.elementFromPoint(h, f);
  m && !i.contentDOM.contains(m) && (m = null), m || (h = Math.max(o.left + 1, Math.min(o.right - 1, h)), m = O.elementFromPoint(h, f), m && !i.contentDOM.contains(m) && (m = null));
  let g, v = -1;
  if (m && ((r = i.docView.nearest(m)) === null || r === void 0 ? void 0 : r.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let w = p.caretPositionFromPoint(h, f);
      w && ({ offsetNode: g, offset: v } = w);
    } else if (p.caretRangeFromPoint) {
      let w = p.caretRangeFromPoint(h, f);
      w && ({ startContainer: g, startOffset: v } = w);
    }
    g && (!i.contentDOM.contains(g) || re.safari && Kw(g, v, h) || re.chrome && Jw(g, v, h)) && (g = void 0), g && (v = Math.min(Ji(g), v));
  }
  if (!g || !i.docView.dom.contains(g)) {
    let w = rt.find(i.docView, d);
    if (!w)
      return u > l.top + l.height / 2 ? l.to : l.from;
    ({ node: g, offset: v } = Nh(w.dom, h, f));
  }
  let S = i.docView.nearest(g);
  if (!S)
    return null;
  if (S.isWidget && ((s = S.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let w = S.dom.getBoundingClientRect();
    return e.y < w.top || e.y <= w.bottom && e.x <= (w.left + w.right) / 2 ? S.posAtStart : S.posAtEnd;
  } else
    return S.localPosFromDOM(g, v) + S.posAtStart;
}
function Yd(i, e, t, n, r) {
  let s = Math.round((n - e.left) * i.defaultCharacterWidth);
  if (i.lineWrapping && t.height > i.defaultLineHeight * 1.5) {
    let a = i.viewState.heightOracle.textHeight, l = Math.floor((r - t.top - (i.defaultLineHeight - a) * 0.5) / a);
    s += l * i.viewState.heightOracle.lineLength;
  }
  let o = i.state.sliceDoc(t.from, t.to);
  return t.from + $h(o, s, i.state.tabSize);
}
function u0(i, e, t) {
  let n, r = i;
  if (i.nodeType != 3 || e != (n = i.nodeValue.length))
    return !1;
  for (; ; ) {
    let s = r.nextSibling;
    if (s) {
      if (s.nodeName == "BR")
        break;
      return !1;
    } else {
      let o = r.parentNode;
      if (!o || o.nodeName == "DIV")
        break;
      r = o;
    }
  }
  return gr(i, n - 1, n).getBoundingClientRect().right > t;
}
function Kw(i, e, t) {
  return u0(i, e, t);
}
function Jw(i, e, t) {
  if (e != 0)
    return u0(i, e, t);
  for (let r = i; ; ) {
    let s = r.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != r)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    r = s;
  }
  let n = i.nodeType == 1 ? i.getBoundingClientRect() : gr(i, 0, Math.max(i.nodeValue.length, 1)).getBoundingClientRect();
  return t - n.left > 5;
}
function Vh(i, e, t) {
  let n = i.lineBlockAt(e);
  if (Array.isArray(n.type)) {
    let r;
    for (let s of n.type) {
      if (s.from > e)
        break;
      if (!(s.to < e)) {
        if (s.from < e && s.to > e)
          return s;
        (!r || s.type == Mt.Text && (r.type != s.type || (t < 0 ? s.from < e : s.to > e))) && (r = s);
      }
    }
    return r || n;
  }
  return n;
}
function ex(i, e, t, n) {
  let r = Vh(i, e.head, e.assoc || -1), s = !n || r.type != Mt.Text || !(i.lineWrapping || r.widgetLineBreaks) ? null : i.coordsAtPos(e.assoc < 0 && e.head > r.from ? e.head - 1 : e.head);
  if (s) {
    let o = i.dom.getBoundingClientRect(), a = i.textDirectionAt(r.from), l = i.posAtCoords({
      x: t == (a == We.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (l != null)
      return q.cursor(l, t ? -1 : 1);
  }
  return q.cursor(t ? r.to : r.from, t ? -1 : 1);
}
function Nd(i, e, t, n) {
  let r = i.state.doc.lineAt(e.head), s = i.bidiSpans(r), o = i.textDirectionAt(r.from);
  for (let a = e, l = null; ; ) {
    let c = Lw(r, s, o, a, t), h = Gg;
    if (!c) {
      if (r.number == (t ? i.state.doc.lines : 1))
        return a;
      h = `
`, r = i.state.doc.line(r.number + (t ? 1 : -1)), s = i.bidiSpans(r), c = i.visualLineSide(r, !t);
    }
    if (l) {
      if (!l(h))
        return a;
    } else {
      if (!n)
        return c;
      l = n(h);
    }
    a = c;
  }
}
function tx(i, e, t) {
  let n = i.state.charCategorizer(e), r = n(t);
  return (s) => {
    let o = n(s);
    return r == Fe.Space && (r = o), r == o;
  };
}
function ix(i, e, t, n) {
  let r = e.head, s = t ? 1 : -1;
  if (r == (t ? i.state.doc.length : 0))
    return q.cursor(r, e.assoc);
  let o = e.goalColumn, a, l = i.contentDOM.getBoundingClientRect(), c = i.coordsAtPos(r, e.assoc || -1), h = i.documentTop;
  if (c)
    o == null && (o = c.left - l.left), a = s < 0 ? c.top : c.bottom;
  else {
    let d = i.viewState.lineBlockAt(r);
    o == null && (o = Math.min(l.right - l.left, i.defaultCharacterWidth * (r - d.from))), a = (s < 0 ? d.top : d.bottom) + h;
  }
  let f = l.left + o, u = n ?? i.viewState.heightOracle.textHeight >> 1;
  for (let d = 0; ; d += 10) {
    let p = a + (u + d) * s, O = f0(i, { x: f, y: p }, !1, s);
    if (p < l.top || p > l.bottom || (s < 0 ? O < r : O > r)) {
      let m = i.docView.coordsForChar(O), g = !m || p < m.top ? -1 : 1;
      return q.cursor(O, g, void 0, o);
    }
  }
}
function Hs(i, e, t) {
  for (; ; ) {
    let n = 0;
    for (let r of i)
      r.between(e - 1, e + 1, (s, o, a) => {
        if (e > s && e < o) {
          let l = n || t || (e - s < o - e ? -1 : 1);
          e = l < 0 ? s : o, n = l;
        }
      });
    if (!n)
      return e;
  }
}
function d0(i, e) {
  let t = null;
  for (let n = 0; n < e.ranges.length; n++) {
    let r = e.ranges[n], s = null;
    if (r.empty) {
      let o = Hs(i, r.from, 0);
      o != r.from && (s = q.cursor(o, -1));
    } else {
      let o = Hs(i, r.from, -1), a = Hs(i, r.to, 1);
      (o != r.from || a != r.to) && (s = q.range(r.from == r.anchor ? o : a, r.from == r.head ? o : a));
    }
    s && (t || (t = e.ranges.slice()), t[n] = s);
  }
  return t ? q.create(t, e.mainIndex) : e;
}
function Oc(i, e, t) {
  let n = Hs(i.state.facet(Co).map((r) => r(i)), t.from, e.head > t.from ? -1 : 1);
  return n == t.from ? t : q.cursor(n, n < t.from ? 1 : -1);
}
const Bs = "ï¿¿";
class nx {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet($e.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Bs;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let n = e.parentNode;
    for (let r = e; ; ) {
      this.findPointBefore(n, r);
      let s = this.text.length;
      this.readNode(r);
      let o = r.nextSibling;
      if (o == t)
        break;
      let a = ze.get(r), l = ze.get(o);
      (a && l ? a.breakAfter : (a ? a.breakAfter : Na(r)) || Na(o) && (r.nodeName != "BR" || r.cmIgnore) && this.text.length > s) && !sx(o, t) && this.lineBreak(), r = o;
    }
    return this.findPointBefore(n, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let n of this.points)
      n.node == e && (n.pos = this.text.length + Math.min(n.offset, t.length));
    for (let n = 0, r = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, a;
      if (this.lineSeparator ? (s = t.indexOf(this.lineSeparator, n), o = this.lineSeparator.length) : (a = r.exec(t)) && (s = a.index, o = a[0].length), this.append(t.slice(n, s < 0 ? t.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= o - 1);
      n = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = ze.get(e), n = t && t.overrideDOMText;
    if (n != null) {
      this.findPointInside(e, n.length);
      for (let r = n.iter(); !r.next().done; )
        r.lineBreak ? this.lineBreak() : this.append(r.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let n of this.points)
      n.node == e && e.childNodes[n.offset] == t && (n.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let n of this.points)
      (e.nodeType == 3 ? n.node == e : e.contains(n.node)) && (n.pos = this.text.length + (rx(e, n.node, n.offset) ? t : 0));
  }
}
function rx(i, e, t) {
  for (; ; ) {
    if (!e || t < Ji(e))
      return !1;
    if (e == i)
      return !0;
    t = mr(e) + 1, e = e.parentNode;
  }
}
function sx(i, e) {
  let t;
  for (; !(i == e || !i); i = i.nextSibling) {
    let n = ze.get(i);
    if (!(n?.isWidget || i.cmIgnore))
      return !1;
    n && (t || (t = [])).push(n);
  }
  if (t)
    for (let n of t) {
      let r = n.overrideDOMText;
      if (r?.length)
        return !1;
    }
  return !0;
}
class Vd {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class ox {
  constructor(e, t, n, r) {
    this.typeOver = r, this.bounds = null, this.text = "", this.domChanged = t > -1;
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, n, 0))) {
      let a = s || o ? [] : lx(e), l = new nx(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = cx(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = s && s.node == a.focusNode && s.offset == a.focusOffset || !Zh(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = o && o.node == a.anchorNode && o.offset == a.anchorOffset || !Zh(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), h = e.viewport;
      if ((re.ios || re.chrome) && e.state.selection.main.empty && l != c && (h.from > 0 || h.to < e.state.doc.length)) {
        let f = Math.min(l, c), u = Math.max(l, c), d = h.from - f, p = h.to - u;
        (d == 0 || d == 1 || f == 0) && (p == 0 || p == -1 || u == e.state.doc.length) && (l = 0, c = e.state.doc.length);
      }
      this.newSel = q.single(c, l);
    }
  }
}
function p0(i, e) {
  let t, { newSel: n } = e, r = i.state.selection.main, s = i.inputState.lastKeyTime > Date.now() - 100 ? i.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: a } = e.bounds, l = r.from, c = null;
    (s === 8 || re.android && e.text.length < a - o) && (l = r.to, c = "end");
    let h = O0(i.state.doc.sliceString(o, a, Bs), e.text, l - o, c);
    h && (re.chrome && s == 13 && h.toB == h.from + 2 && e.text.slice(h.from, h.toB) == Bs + Bs && h.toB--, t = {
      from: o + h.from,
      to: o + h.toA,
      insert: Re.of(e.text.slice(h.from, h.toB).split(Bs))
    });
  } else n && (!i.hasFocus && i.state.facet(On) || n.main.eq(r)) && (n = null);
  if (!t && !n)
    return !1;
  if (!t && e.typeOver && !r.empty && n && n.main.empty ? t = { from: r.from, to: r.to, insert: i.state.doc.slice(r.from, r.to) } : (re.mac || re.android) && t && t.from == t.to && t.from == r.head - 1 && /^\. ?$/.test(t.insert.toString()) && i.contentDOM.getAttribute("autocorrect") == "off" ? (n && t.insert.length == 2 && (n = q.single(n.main.anchor - 1, n.main.head - 1)), t = { from: t.from, to: t.to, insert: Re.of([t.insert.toString().replace(".", " ")]) }) : t && t.from >= r.from && t.to <= r.to && (t.from != r.from || t.to != r.to) && r.to - r.from - (t.to - t.from) <= 4 ? t = {
    from: r.from,
    to: r.to,
    insert: i.state.doc.slice(r.from, t.from).append(t.insert).append(i.state.doc.slice(t.to, r.to))
  } : re.chrome && t && t.from == t.to && t.from == r.head && t.insert.toString() == `
 ` && i.lineWrapping && (n && (n = q.single(n.main.anchor - 1, n.main.head - 1)), t = { from: r.from, to: r.to, insert: Re.of([" "]) }), t)
    return Uf(i, t, n, s);
  if (n && !n.main.eq(r)) {
    let o = !1, a = "select";
    return i.inputState.lastSelectionTime > Date.now() - 50 && (i.inputState.lastSelectionOrigin == "select" && (o = !0), a = i.inputState.lastSelectionOrigin, a == "select.pointer" && (n = d0(i.state.facet(Co).map((l) => l(i)), n))), i.dispatch({ selection: n, scrollIntoView: o, userEvent: a }), !0;
  } else
    return !1;
}
function Uf(i, e, t, n = -1) {
  if (re.ios && i.inputState.flushIOSKey(e))
    return !0;
  let r = i.state.selection.main;
  if (re.android && (e.to == r.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == r.from || e.from == r.from - 1 && i.state.sliceDoc(e.from, r.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && Br(i.contentDOM, "Enter", 13) || (e.from == r.from - 1 && e.to == r.to && e.insert.length == 0 || n == 8 && e.insert.length < e.to - e.from && e.to > r.head) && Br(i.contentDOM, "Backspace", 8) || e.from == r.from && e.to == r.to + 1 && e.insert.length == 0 && Br(i.contentDOM, "Delete", 46)))
    return !0;
  let s = e.insert.toString();
  i.inputState.composing >= 0 && i.inputState.composing++;
  let o, a = () => o || (o = ax(i, e, t));
  return i.state.facet(e0).some((l) => l(i, e.from, e.to, s, a)) || i.dispatch(a()), !0;
}
function ax(i, e, t) {
  let n, r = i.state, s = r.selection.main, o = -1;
  if (e.from == e.to && e.from < s.from || e.from > s.to) {
    let l = e.from < s.from ? -1 : 1, c = l < 0 ? s.from : s.to, h = Hs(r.facet(Co).map((f) => f(i)), c, l);
    e.from == h && (o = h);
  }
  if (o > -1)
    n = {
      changes: e,
      selection: q.cursor(e.from + e.insert.length, -1)
    };
  else if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!t || t.main.empty && t.main.from == e.from + e.insert.length) && i.inputState.composing < 0) {
    let l = s.from < e.from ? r.sliceDoc(s.from, e.from) : "", c = s.to > e.to ? r.sliceDoc(e.to, s.to) : "";
    n = r.replaceSelection(i.state.toText(l + e.insert.sliceString(0, void 0, i.state.lineBreak) + c));
  } else {
    let l = r.changes(e), c = t && t.main.to <= l.newLength ? t.main : void 0;
    if (r.selection.ranges.length > 1 && i.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let h = i.state.sliceDoc(e.from, e.to), f, u = t && h0(i, t.main.head);
      if (u) {
        let O = e.insert.length - (e.to - e.from);
        f = { from: u.from, to: u.to - O };
      } else
        f = i.state.doc.lineAt(s.head);
      let d = s.to - e.to, p = s.to - s.from;
      n = r.changeByRange((O) => {
        if (O.from == s.from && O.to == s.to)
          return { changes: l, range: c || O.map(l) };
        let m = O.to - d, g = m - h.length;
        if (O.to - O.from != p || i.state.sliceDoc(g, m) != h || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        O.to >= f.from && O.from <= f.to)
          return { range: O };
        let v = r.changes({ from: g, to: m, insert: e.insert }), S = O.to - s.to;
        return {
          changes: v,
          range: c ? q.range(Math.max(0, c.anchor + S), Math.max(0, c.head + S)) : O.map(v)
        };
      });
    } else
      n = {
        changes: l,
        selection: c && r.selection.replaceRange(c)
      };
  }
  let a = "input.type";
  return (i.composing || i.inputState.compositionPendingChange && i.inputState.compositionEndedAt > Date.now() - 50) && (i.inputState.compositionPendingChange = !1, a += ".compose", i.inputState.compositionFirstChange && (a += ".start", i.inputState.compositionFirstChange = !1)), r.update(n, { userEvent: a, scrollIntoView: !0 });
}
function O0(i, e, t, n) {
  let r = Math.min(i.length, e.length), s = 0;
  for (; s < r && i.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == r && i.length == e.length)
    return null;
  let o = i.length, a = e.length;
  for (; o > 0 && a > 0 && i.charCodeAt(o - 1) == e.charCodeAt(a - 1); )
    o--, a--;
  if (n == "end") {
    let l = Math.max(0, s - Math.min(o, a));
    t -= o + l - s;
  }
  if (o < s && i.length < e.length) {
    let l = t <= s && t >= o ? s - t : 0;
    s -= l, a = s + (a - o), o = s;
  } else if (a < s) {
    let l = t <= s && t >= a ? s - t : 0;
    s -= l, o = s + (o - a), a = s;
  }
  return { from: s, toA: o, toB: a };
}
function lx(i) {
  let e = [];
  if (i.root.activeElement != i.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: n, focusNode: r, focusOffset: s } = i.observer.selectionRange;
  return t && (e.push(new Vd(t, n)), (r != t || s != n) && e.push(new Vd(r, s))), e;
}
function cx(i, e) {
  if (i.length == 0)
    return null;
  let t = i[0].pos, n = i.length == 2 ? i[1].pos : t;
  return t > -1 && n > -1 ? q.single(t + e, n + e) : null;
}
class hx {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, re.safari && e.contentDOM.addEventListener("input", () => null), re.gecko && _x(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !bx(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
  }
  runHandlers(e, t) {
    let n = this.handlers[e];
    if (n) {
      for (let r of n.observers)
        r(this.view, t);
      for (let r of n.handlers) {
        if (t.defaultPrevented)
          break;
        if (r(this.view, t)) {
          t.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let t = fx(e), n = this.handlers, r = this.view.contentDOM;
    for (let s in t)
      if (s != "scroll") {
        let o = !t[s].handlers.length, a = n[s];
        a && o != !a.handlers.length && (r.removeEventListener(s, this.handleEvent), a = null), a || r.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in n)
      s != "scroll" && !t[s] && r.removeEventListener(s, this.handleEvent);
    this.handlers = t;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && g0.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), re.android && re.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let t;
    return re.ios && !e.synthetic && !e.altKey && !e.metaKey && ((t = m0.find((n) => n.keyCode == e.keyCode)) && !e.ctrlKey || ux.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return !t || t.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, Br(this.view.contentDOM, t.key, t.keyCode, t instanceof KeyboardEvent ? t : void 0));
  }
  ignoreDuringComposition(e) {
    return !/^key/.test(e.type) || e.synthetic ? !1 : this.composing > 0 ? !0 : re.safari && !re.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function qd(i, e) {
  return (t, n) => {
    try {
      return e.call(i, n, t);
    } catch (r) {
      Wt(t.state, r);
    }
  };
}
function fx(i) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(n) {
    return e[n] || (e[n] = { observers: [], handlers: [] });
  }
  for (let n of i) {
    let r = n.spec, s = r && r.plugin.domEventHandlers, o = r && r.plugin.domEventObservers;
    if (s)
      for (let a in s) {
        let l = s[a];
        l && t(a).handlers.push(qd(n.value, l));
      }
    if (o)
      for (let a in o) {
        let l = o[a];
        l && t(a).observers.push(qd(n.value, l));
      }
  }
  for (let n in Qi)
    t(n).handlers.push(Qi[n]);
  for (let n in Oi)
    t(n).observers.push(Oi[n]);
  return e;
}
const m0 = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], ux = "dthko", g0 = [16, 17, 18, 20, 91, 92, 224, 225], Uo = 6;
function Go(i) {
  return Math.max(0, i) * 0.7 + 8;
}
function dx(i, e) {
  return Math.max(Math.abs(i.clientX - e.clientX), Math.abs(i.clientY - e.clientY));
}
class px {
  constructor(e, t, n, r) {
    this.view = e, this.startEvent = t, this.style = n, this.mustSelect = r, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParents = ww(e.contentDOM), this.atoms = e.state.facet(Co).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet($e.allowMultipleSelections) && Ox(e, t), this.dragging = gx(e, t) && v0(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && dx(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let t = 0, n = 0, r = 0, s = 0, o = this.view.win.innerWidth, a = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: r, right: o } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: s, bottom: a } = this.scrollParents.y.getBoundingClientRect());
    let l = jf(this.view);
    e.clientX - l.left <= r + Uo ? t = -Go(r - e.clientX) : e.clientX + l.right >= o - Uo && (t = Go(e.clientX - o)), e.clientY - l.top <= s + Uo ? n = -Go(s - e.clientY) : e.clientY + l.bottom >= a - Uo && (n = Go(e.clientY - a)), this.setScrollSpeed(t, n);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: t } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), t && this.scrollParents.y && (this.scrollParents.y.scrollTop += t, t = 0), (e || t) && this.view.win.scrollBy(e, t), this.dragging === !1 && this.select(this.lastEvent);
  }
  select(e) {
    let { view: t } = this, n = d0(this.atoms, this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !n.eq(t.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: n,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((t) => t.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function Ox(i, e) {
  let t = i.state.facet(Fg);
  return t.length ? t[0](e) : re.mac ? e.metaKey : e.ctrlKey;
}
function mx(i, e) {
  let t = i.state.facet(Hg);
  return t.length ? t[0](e) : re.mac ? !e.altKey : !e.ctrlKey;
}
function gx(i, e) {
  let { main: t } = i.state.selection;
  if (t.empty)
    return !1;
  let n = so(i.root);
  if (!n || n.rangeCount == 0)
    return !0;
  let r = n.getRangeAt(0).getClientRects();
  for (let s = 0; s < r.length; s++) {
    let o = r[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function bx(i, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, n; t != i.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (n = ze.get(t)) && n.ignoreEvent(e))
      return !1;
  return !0;
}
const Qi = /* @__PURE__ */ Object.create(null), Oi = /* @__PURE__ */ Object.create(null), b0 = re.ie && re.ie_version < 15 || re.ios && re.webkit_version < 604;
function yx(i) {
  let e = i.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    i.focus(), t.remove(), y0(i, t.value);
  }, 50);
}
function Al(i, e, t) {
  for (let n of i.facet(e))
    t = n(t, i);
  return t;
}
function y0(i, e) {
  e = Al(i.state, Vf, e);
  let { state: t } = i, n, r = 1, s = t.toText(e), o = s.lines == t.selection.ranges.length;
  if (qh != null && t.selection.ranges.every((l) => l.empty) && qh == s.toString()) {
    let l = -1;
    n = t.changeByRange((c) => {
      let h = t.doc.lineAt(c.from);
      if (h.from == l)
        return { range: c };
      l = h.from;
      let f = t.toText((o ? s.line(r++).text : e) + t.lineBreak);
      return {
        changes: { from: h.from, insert: f },
        range: q.cursor(c.from + f.length)
      };
    });
  } else o ? n = t.changeByRange((l) => {
    let c = s.line(r++);
    return {
      changes: { from: l.from, to: l.to, insert: c.text },
      range: q.cursor(l.from + c.length)
    };
  }) : n = t.replaceSelection(s);
  i.dispatch(n, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Oi.scroll = (i) => {
  i.inputState.lastScrollTop = i.scrollDOM.scrollTop, i.inputState.lastScrollLeft = i.scrollDOM.scrollLeft;
};
Qi.keydown = (i, e) => (i.inputState.setSelectionOrigin("select"), e.keyCode == 27 && i.inputState.tabFocusMode != 0 && (i.inputState.tabFocusMode = Date.now() + 2e3), !1);
Oi.touchstart = (i, e) => {
  i.inputState.lastTouchTime = Date.now(), i.inputState.setSelectionOrigin("select.pointer");
};
Oi.touchmove = (i) => {
  i.inputState.setSelectionOrigin("select.pointer");
};
Qi.mousedown = (i, e) => {
  if (i.observer.flush(), i.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let t = null;
  for (let n of i.state.facet(Kg))
    if (t = n(i, e), t)
      break;
  if (!t && e.button == 0 && (t = wx(i, e)), t) {
    let n = !i.hasFocus;
    i.inputState.startMouseSelection(new px(i, e, t, n)), n && i.observer.ignore(() => {
      Eg(i.contentDOM);
      let s = i.root.activeElement;
      s && !s.contains(i.contentDOM) && s.blur();
    });
    let r = i.inputState.mouseSelection;
    if (r)
      return r.start(e), r.dragging === !1;
  } else
    i.inputState.setSelectionOrigin("select.pointer");
  return !1;
};
function Wd(i, e, t, n) {
  if (n == 1)
    return q.cursor(e, t);
  if (n == 2)
    return Gw(i.state, e, t);
  {
    let r = rt.find(i.docView, e), s = i.state.doc.lineAt(r ? r.posAtEnd : e), o = r ? r.posAtStart : s.from, a = r ? r.posAtEnd : s.to;
    return a < i.state.doc.length && a == s.to && a++, q.range(o, a);
  }
}
let jd = (i, e, t) => e >= t.top && e <= t.bottom && i >= t.left && i <= t.right;
function vx(i, e, t, n) {
  let r = rt.find(i.docView, e);
  if (!r)
    return 1;
  let s = e - r.posAtStart;
  if (s == 0)
    return 1;
  if (s == r.length)
    return -1;
  let o = r.coordsAt(s, -1);
  if (o && jd(t, n, o))
    return -1;
  let a = r.coordsAt(s, 1);
  return a && jd(t, n, a) ? 1 : o && o.bottom >= n ? -1 : 1;
}
function Ud(i, e) {
  let t = i.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: vx(i, t, e.clientX, e.clientY) };
}
const Sx = re.ie && re.ie_version <= 11;
let Gd = null, Fd = 0, Hd = 0;
function v0(i) {
  if (!Sx)
    return i.detail;
  let e = Gd, t = Hd;
  return Gd = i, Hd = Date.now(), Fd = !e || t > Date.now() - 400 && Math.abs(e.clientX - i.clientX) < 2 && Math.abs(e.clientY - i.clientY) < 2 ? (Fd + 1) % 3 : 1;
}
function wx(i, e) {
  let t = Ud(i, e), n = v0(e), r = i.state.selection;
  return {
    update(s) {
      s.docChanged && (t.pos = s.changes.mapPos(t.pos), r = r.map(s.changes));
    },
    get(s, o, a) {
      let l = Ud(i, s), c, h = Wd(i, l.pos, l.bias, n);
      if (t.pos != l.pos && !o) {
        let f = Wd(i, t.pos, t.bias, n), u = Math.min(f.from, h.from), d = Math.max(f.to, h.to);
        h = u < h.from ? q.range(u, d) : q.range(d, u);
      }
      return o ? r.replaceRange(r.main.extend(h.from, h.to)) : a && n == 1 && r.ranges.length > 1 && (c = xx(r, l.pos)) ? c : a ? r.addRange(h) : q.create([h]);
    }
  };
}
function xx(i, e) {
  for (let t = 0; t < i.ranges.length; t++) {
    let { from: n, to: r } = i.ranges[t];
    if (n <= e && r >= e)
      return q.create(i.ranges.slice(0, t).concat(i.ranges.slice(t + 1)), i.mainIndex == t ? 0 : i.mainIndex - (i.mainIndex > t ? 1 : 0));
  }
  return null;
}
Qi.dragstart = (i, e) => {
  let { selection: { main: t } } = i.state;
  if (e.target.draggable) {
    let r = i.docView.nearest(e.target);
    if (r && r.isWidget) {
      let s = r.posAtStart, o = s + r.length;
      (s >= t.to || o <= t.from) && (t = q.range(s, o));
    }
  }
  let { inputState: n } = i;
  return n.mouseSelection && (n.mouseSelection.dragging = !0), n.draggedContent = t, e.dataTransfer && (e.dataTransfer.setData("Text", Al(i.state, qf, i.state.sliceDoc(t.from, t.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
Qi.dragend = (i) => (i.inputState.draggedContent = null, !1);
function Kd(i, e, t, n) {
  if (t = Al(i.state, Vf, t), !t)
    return;
  let r = i.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = i.inputState, o = n && s && mx(i, e) ? { from: s.from, to: s.to } : null, a = { from: r, insert: t }, l = i.state.changes(o ? [o, a] : a);
  i.focus(), i.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(r, -1), head: l.mapPos(r, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), i.inputState.draggedContent = null;
}
Qi.drop = (i, e) => {
  if (!e.dataTransfer)
    return !1;
  if (i.state.readOnly)
    return !0;
  let t = e.dataTransfer.files;
  if (t && t.length) {
    let n = Array(t.length), r = 0, s = () => {
      ++r == t.length && Kd(i, e, n.filter((o) => o != null).join(i.state.lineBreak), !1);
    };
    for (let o = 0; o < t.length; o++) {
      let a = new FileReader();
      a.onerror = s, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (n[o] = a.result), s();
      }, a.readAsText(t[o]);
    }
    return !0;
  } else {
    let n = e.dataTransfer.getData("Text");
    if (n)
      return Kd(i, e, n, !0), !0;
  }
  return !1;
};
Qi.paste = (i, e) => {
  if (i.state.readOnly)
    return !0;
  i.observer.flush();
  let t = b0 ? null : e.clipboardData;
  return t ? (y0(i, t.getData("text/plain") || t.getData("text/uri-list")), !0) : (yx(i), !1);
};
function kx(i, e) {
  let t = i.dom.parentNode;
  if (!t)
    return;
  let n = t.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.value = e, n.focus(), n.selectionEnd = e.length, n.selectionStart = 0, setTimeout(() => {
    n.remove(), i.focus();
  }, 50);
}
function Qx(i) {
  let e = [], t = [], n = !1;
  for (let r of i.selection.ranges)
    r.empty || (e.push(i.sliceDoc(r.from, r.to)), t.push(r));
  if (!e.length) {
    let r = -1;
    for (let { from: s } of i.selection.ranges) {
      let o = i.doc.lineAt(s);
      o.number > r && (e.push(o.text), t.push({ from: o.from, to: Math.min(i.doc.length, o.to + 1) })), r = o.number;
    }
    n = !0;
  }
  return { text: Al(i, qf, e.join(i.lineBreak)), ranges: t, linewise: n };
}
let qh = null;
Qi.copy = Qi.cut = (i, e) => {
  let { text: t, ranges: n, linewise: r } = Qx(i.state);
  if (!t && !r)
    return !1;
  qh = r ? t : null, e.type == "cut" && !i.state.readOnly && i.dispatch({
    changes: n,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = b0 ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", t), !0) : (kx(i, t), !1);
};
const S0 = /* @__PURE__ */ _n.define();
function w0(i, e) {
  let t = [];
  for (let n of i.facet(t0)) {
    let r = n(i, e);
    r && t.push(r);
  }
  return t.length ? i.update({ effects: t, annotations: S0.of(!0) }) : null;
}
function x0(i) {
  setTimeout(() => {
    let e = i.hasFocus;
    if (e != i.inputState.notifiedFocused) {
      let t = w0(i.state, e);
      t ? i.dispatch(t) : i.update([]);
    }
  }, 10);
}
Oi.focus = (i) => {
  i.inputState.lastFocusTime = Date.now(), !i.scrollDOM.scrollTop && (i.inputState.lastScrollTop || i.inputState.lastScrollLeft) && (i.scrollDOM.scrollTop = i.inputState.lastScrollTop, i.scrollDOM.scrollLeft = i.inputState.lastScrollLeft), x0(i);
};
Oi.blur = (i) => {
  i.observer.clearSelectionRange(), x0(i);
};
Oi.compositionstart = Oi.compositionupdate = (i) => {
  i.observer.editContext || (i.inputState.compositionFirstChange == null && (i.inputState.compositionFirstChange = !0), i.inputState.composing < 0 && (i.inputState.composing = 0));
};
Oi.compositionend = (i) => {
  i.observer.editContext || (i.inputState.composing = -1, i.inputState.compositionEndedAt = Date.now(), i.inputState.compositionPendingKey = !0, i.inputState.compositionPendingChange = i.observer.pendingRecords().length > 0, i.inputState.compositionFirstChange = null, re.chrome && re.android ? i.observer.flushSoon() : i.inputState.compositionPendingChange ? Promise.resolve().then(() => i.observer.flush()) : setTimeout(() => {
    i.inputState.composing < 0 && i.docView.hasComposition && i.update([]);
  }, 50));
};
Oi.contextmenu = (i) => {
  i.inputState.lastContextMenu = Date.now();
};
Qi.beforeinput = (i, e) => {
  var t, n;
  if (e.inputType == "insertReplacementText" && i.observer.editContext) {
    let s = (t = e.dataTransfer) === null || t === void 0 ? void 0 : t.getData("text/plain"), o = e.getTargetRanges();
    if (s && o.length) {
      let a = o[0], l = i.posAtDOM(a.startContainer, a.startOffset), c = i.posAtDOM(a.endContainer, a.endOffset);
      return Uf(i, { from: l, to: c, insert: i.state.toText(s) }, null), !0;
    }
  }
  let r;
  if (re.chrome && re.android && (r = m0.find((s) => s.inputType == e.inputType)) && (i.observer.delayAndroidKey(r.key, r.keyCode), r.key == "Backspace" || r.key == "Delete")) {
    let s = ((n = window.visualViewport) === null || n === void 0 ? void 0 : n.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > s + 10 && i.hasFocus && (i.contentDOM.blur(), i.focus());
    }, 100);
  }
  return re.ios && e.inputType == "deleteContentForward" && i.observer.flushSoon(), re.safari && e.inputType == "insertText" && i.inputState.composing >= 0 && setTimeout(() => Oi.compositionend(i, e), 20), !1;
};
const Jd = /* @__PURE__ */ new Set();
function _x(i) {
  Jd.has(i) || (Jd.add(i), i.addEventListener("copy", () => {
  }), i.addEventListener("cut", () => {
  }));
}
const ep = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let es = !1;
function tp() {
  es = !1;
}
class Px {
  constructor(e) {
    this.lineWrapping = e, this.doc = Re.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, t) {
    let n = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (n += Math.max(0, Math.ceil((t - e - n * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * n;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return ep.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let n = 0; n < e.length; n++) {
      let r = e[n];
      r < 0 ? n++ : this.heightSamples[Math.floor(r * 10)] || (t = !0, this.heightSamples[Math.floor(r * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, n, r, s, o) {
    let a = ep.indexOf(e) > -1, l = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = t, this.charWidth = n, this.textHeight = r, this.lineLength = s, l) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let h = o[c];
        h < 0 ? c++ : this.heightSamples[Math.floor(h * 10)] = !0;
      }
    }
    return l;
  }
}
class $x {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Yi {
  /**
  @internal
  */
  constructor(e, t, n, r, s) {
    this.from = e, this.length = t, this.top = n, this.height = r, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Mt.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Yn ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new Yi(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var Ve = /* @__PURE__ */ (function(i) {
  return i[i.ByPos = 0] = "ByPos", i[i.ByHeight = 1] = "ByHeight", i[i.ByPosNoHeight = 2] = "ByPosNoHeight", i;
})(Ve || (Ve = {}));
const Qa = 1e-3;
class Zt {
  constructor(e, t, n = 2) {
    this.length = e, this.height = t, this.flags = n;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > Qa && (es = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, n) {
    return Zt.of(n);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, n, r) {
    let s = this, o = n.doc;
    for (let a = r.length - 1; a >= 0; a--) {
      let { fromA: l, toA: c, fromB: h, toB: f } = r[a], u = s.lineAt(l, Ve.ByPosNoHeight, n.setDoc(t), 0, 0), d = u.to >= c ? u : s.lineAt(c, Ve.ByPosNoHeight, n, 0, 0);
      for (f += d.to - c, c = d.to; a > 0 && u.from <= r[a - 1].toA; )
        l = r[a - 1].fromA, h = r[a - 1].fromB, a--, l < u.from && (u = s.lineAt(l, Ve.ByPosNoHeight, n, 0, 0));
      h += u.from - l, l = u.from;
      let p = Gf.build(n.setDoc(o), e, h, f);
      s = Wa(s, s.replace(l, c, p));
    }
    return s.updateHeight(n, 0);
  }
  static empty() {
    return new Jt(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, n = e.length, r = 0, s = 0;
    for (; ; )
      if (t == n)
        if (r > s * 2) {
          let a = e[t - 1];
          a.break ? e.splice(--t, 1, a.left, null, a.right) : e.splice(--t, 1, a.left, a.right), n += 1 + a.break, r -= a.size;
        } else if (s > r * 2) {
          let a = e[n];
          a.break ? e.splice(n, 1, a.left, null, a.right) : e.splice(n, 1, a.left, a.right), n += 2 + a.break, s -= a.size;
        } else
          break;
      else if (r < s) {
        let a = e[t++];
        a && (r += a.size);
      } else {
        let a = e[--n];
        a && (s += a.size);
      }
    let o = 0;
    return e[t - 1] == null ? (o = 1, t--) : e[t] == null && (o = 1, n++), new Tx(Zt.of(e.slice(0, t)), o, Zt.of(e.slice(n)));
  }
}
function Wa(i, e) {
  return i == e ? i : (i.constructor != e.constructor && (es = !0), e);
}
Zt.prototype.size = 1;
class k0 extends Zt {
  constructor(e, t, n) {
    super(e, t), this.deco = n;
  }
  blockAt(e, t, n, r) {
    return new Yi(r, this.length, n, this.height, this.deco || 0);
  }
  lineAt(e, t, n, r, s) {
    return this.blockAt(0, n, r, s);
  }
  forEachLine(e, t, n, r, s, o) {
    e <= s + this.length && t >= s && o(this.blockAt(0, n, r, s));
  }
  updateHeight(e, t = 0, n = !1, r) {
    return r && r.from <= t && r.more && this.setHeight(r.heights[r.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Jt extends k0 {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, n, r) {
    return new Yi(r, this.length, n, this.height, this.breaks);
  }
  replace(e, t, n) {
    let r = n[0];
    return n.length == 1 && (r instanceof Jt || r instanceof dt && r.flags & 4) && Math.abs(this.length - r.length) < 10 ? (r instanceof dt ? r = new Jt(r.length, this.height) : r.height = this.height, this.outdated || (r.outdated = !1), r) : Zt.of(n);
  }
  updateHeight(e, t = 0, n = !1, r) {
    return r && r.from <= t && r.more ? this.setHeight(r.heights[r.index++]) : (n || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class dt extends Zt {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let n = e.doc.lineAt(t).number, r = e.doc.lineAt(t + this.length).number, s = r - n + 1, o, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * s);
      o = l / s, this.length > s + 1 && (a = (this.height - l) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: n, lastLine: r, perLine: o, perChar: a };
  }
  blockAt(e, t, n, r) {
    let { firstLine: s, lastLine: o, perLine: a, perChar: l } = this.heightMetrics(t, r);
    if (t.lineWrapping) {
      let c = r + (e < t.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - n) / this.height)) * this.length)), h = t.doc.lineAt(c), f = a + h.length * l, u = Math.max(n, e - f / 2);
      return new Yi(h.from, h.length, u, f, 0);
    } else {
      let c = Math.max(0, Math.min(o - s, Math.floor((e - n) / a))), { from: h, length: f } = t.doc.line(s + c);
      return new Yi(h, f, n + a * c, a, 0);
    }
  }
  lineAt(e, t, n, r, s) {
    if (t == Ve.ByHeight)
      return this.blockAt(e, n, r, s);
    if (t == Ve.ByPosNoHeight) {
      let { from: d, to: p } = n.doc.lineAt(e);
      return new Yi(d, p - d, 0, 0, 0);
    }
    let { firstLine: o, perLine: a, perChar: l } = this.heightMetrics(n, s), c = n.doc.lineAt(e), h = a + c.length * l, f = c.number - o, u = r + a * f + l * (c.from - s - f);
    return new Yi(c.from, c.length, Math.max(r, Math.min(u, r + this.height - h)), h, 0);
  }
  forEachLine(e, t, n, r, s, o) {
    e = Math.max(e, s), t = Math.min(t, s + this.length);
    let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(n, s);
    for (let h = e, f = r; h <= t; ) {
      let u = n.doc.lineAt(h);
      if (h == e) {
        let p = u.number - a;
        f += l * p + c * (e - s - p);
      }
      let d = l + c * u.length;
      o(new Yi(u.from, u.length, f, d, 0)), f += d, h = u.to + 1;
    }
  }
  replace(e, t, n) {
    let r = this.length - t;
    if (r > 0) {
      let s = n[n.length - 1];
      s instanceof dt ? n[n.length - 1] = new dt(s.length + r) : n.push(null, new dt(r - 1));
    }
    if (e > 0) {
      let s = n[0];
      s instanceof dt ? n[0] = new dt(e + s.length) : n.unshift(new dt(e - 1), null);
    }
    return Zt.of(n);
  }
  decomposeLeft(e, t) {
    t.push(new dt(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new dt(this.length - e - 1));
  }
  updateHeight(e, t = 0, n = !1, r) {
    let s = t + this.length;
    if (r && r.from <= t + this.length && r.more) {
      let o = [], a = Math.max(t, r.from), l = -1;
      for (r.from > t && o.push(new dt(r.from - t - 1).updateHeight(e, t)); a <= s && r.more; ) {
        let h = e.doc.lineAt(a).length;
        o.length && o.push(null);
        let f = r.heights[r.index++];
        l == -1 ? l = f : Math.abs(f - l) >= Qa && (l = -2);
        let u = new Jt(h, f);
        u.outdated = !1, o.push(u), a += h + 1;
      }
      a <= s && o.push(null, new dt(s - a).updateHeight(e, a));
      let c = Zt.of(o);
      return (l < 0 || Math.abs(c.height - this.height) >= Qa || Math.abs(l - this.heightMetrics(e, t).perLine) >= Qa) && (es = !0), Wa(this, c);
    } else (n || this.outdated) && (this.setHeight(e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class Tx extends Zt {
  constructor(e, t, n) {
    super(e.length + t + n.length, e.height + n.height, t | (e.outdated || n.outdated ? 2 : 0)), this.left = e, this.right = n, this.size = e.size + n.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, n, r) {
    let s = n + this.left.height;
    return e < s ? this.left.blockAt(e, t, n, r) : this.right.blockAt(e, t, s, r + this.left.length + this.break);
  }
  lineAt(e, t, n, r, s) {
    let o = r + this.left.height, a = s + this.left.length + this.break, l = t == Ve.ByHeight ? e < o : e < a, c = l ? this.left.lineAt(e, t, n, r, s) : this.right.lineAt(e, t, n, o, a);
    if (this.break || (l ? c.to < a : c.from > a))
      return c;
    let h = t == Ve.ByPosNoHeight ? Ve.ByPosNoHeight : Ve.ByPos;
    return l ? c.join(this.right.lineAt(a, h, n, o, a)) : this.left.lineAt(a, h, n, r, s).join(c);
  }
  forEachLine(e, t, n, r, s, o) {
    let a = r + this.left.height, l = s + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, t, n, r, s, o), t >= l && this.right.forEachLine(e, t, n, a, l, o);
    else {
      let c = this.lineAt(l, Ve.ByPos, n, r, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, n, r, s, o), c.to >= e && c.from <= t && o(c), t > c.to && this.right.forEachLine(c.to + 1, t, n, a, l, o);
    }
  }
  replace(e, t, n) {
    let r = this.left.length + this.break;
    if (t < r)
      return this.balanced(this.left.replace(e, t, n), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - r, t - r, n));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let a of n)
      s.push(a);
    if (e > 0 && ip(s, o - 1), t < this.length) {
      let a = s.length;
      this.decomposeRight(t, s), ip(s, a);
    }
    return Zt.of(s);
  }
  decomposeLeft(e, t) {
    let n = this.left.length;
    if (e <= n)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (n++, e >= n && t.push(null)), e > n && this.right.decomposeLeft(e - n, t);
  }
  decomposeRight(e, t) {
    let n = this.left.length, r = n + this.break;
    if (e >= r)
      return this.right.decomposeRight(e - r, t);
    e < n && this.left.decomposeRight(e, t), this.break && e < r && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? Zt.of(this.break ? [e, null, t] : [e, t]) : (this.left = Wa(this.left, e), this.right = Wa(this.right, t), this.setHeight(e.height + t.height), this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, n = !1, r) {
    let { left: s, right: o } = this, a = t + s.length + this.break, l = null;
    return r && r.from <= t + s.length && r.more ? l = s = s.updateHeight(e, t, n, r) : s.updateHeight(e, t, n), r && r.from <= a + o.length && r.more ? l = o = o.updateHeight(e, a, n, r) : o.updateHeight(e, a, n), l ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function ip(i, e) {
  let t, n;
  i[e] == null && (t = i[e - 1]) instanceof dt && (n = i[e + 1]) instanceof dt && i.splice(e - 1, 3, new dt(t.length + 1 + n.length));
}
const Cx = 5;
class Gf {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let n = Math.min(t, this.lineEnd), r = this.nodes[this.nodes.length - 1];
      r instanceof Jt ? r.length += n - this.pos : (n > this.pos || !this.isCovered) && this.nodes.push(new Jt(n - this.pos, -1)), this.writtenTo = n, t > n && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, n) {
    if (e < t || n.heightRelevant) {
      let r = n.widget ? n.widget.estimatedHeight : 0, s = n.widget ? n.widget.lineBreaks : 0;
      r < 0 && (r = this.oracle.lineHeight);
      let o = t - e;
      n.block ? this.addBlock(new k0(o, r, n)) : (o || s || r >= Cx) && this.addLineDeco(r, s, o);
    } else t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Jt(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let n = new dt(t - e);
    return this.oracle.doc.lineAt(e).to == t && (n.flags |= 4), n;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Jt)
      return e;
    let t = new Jt(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine();
    let t = e.deco;
    t && t.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, t && t.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, t, n) {
    let r = this.ensureLine();
    r.length += n, r.collapsed += n, r.widgetHeight = Math.max(r.widgetHeight, e), r.breaks += t, this.writtenTo = this.pos = this.pos + n;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof Jt) && !this.isCovered ? this.nodes.push(new Jt(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let n = e;
    for (let r of this.nodes)
      r instanceof Jt && r.updateHeight(this.oracle, n), n += r ? r.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, n, r) {
    let s = new Gf(n, e);
    return Te.spans(t, n, r, s, 0), s.finish(n);
  }
}
function Ax(i, e, t) {
  let n = new Rx();
  return Te.compare(i, e, t, n, 0), n.changes;
}
class Rx {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, n, r) {
    (e < t || n && n.heightRelevant || r && r.heightRelevant) && ka(e, t, this.changes, 5);
  }
}
function Ex(i, e) {
  let t = i.getBoundingClientRect(), n = i.ownerDocument, r = n.defaultView || window, s = Math.max(0, t.left), o = Math.min(r.innerWidth, t.right), a = Math.max(0, t.top), l = Math.min(r.innerHeight, t.bottom);
  for (let c = i.parentNode; c && c != n.body; )
    if (c.nodeType == 1) {
      let h = c, f = window.getComputedStyle(h);
      if ((h.scrollHeight > h.clientHeight || h.scrollWidth > h.clientWidth) && f.overflow != "visible") {
        let u = h.getBoundingClientRect();
        s = Math.max(s, u.left), o = Math.min(o, u.right), a = Math.max(a, u.top), l = Math.min(c == i.parentNode ? r.innerHeight : l, u.bottom);
      }
      c = f.position == "absolute" || f.position == "fixed" ? h.offsetParent : h.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: s - t.left,
    right: Math.max(s, o) - t.left,
    top: a - (t.top + e),
    bottom: Math.max(a, l) - (t.top + e)
  };
}
function Mx(i) {
  let e = i.getBoundingClientRect(), t = i.ownerDocument.defaultView || window;
  return e.left < t.innerWidth && e.right > 0 && e.top < t.innerHeight && e.bottom > 0;
}
function Zx(i, e) {
  let t = i.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class mc {
  constructor(e, t, n, r) {
    this.from = e, this.to = t, this.size = n, this.displaySize = r;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let n = 0; n < e.length; n++) {
      let r = e[n], s = t[n];
      if (r.from != s.from || r.to != s.to || r.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, t) {
    return pe.replace({
      widget: new Xx(this.displaySize * (t ? e.scaleY : e.scaleX), t)
    }).range(this.from, this.to);
  }
}
class Xx extends Pn {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class np {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = rp, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = We.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(Wf).some((n) => typeof n != "function" && n.class == "cm-lineWrapping");
    this.heightOracle = new Px(t), this.stateDeco = e.facet(ao).filter((n) => typeof n != "function"), this.heightMap = Zt.empty().applyChanges(this.stateDeco, Re.empty, this.heightOracle.setDoc(e.doc), [new ui(0, 0, 0, e.doc.length)]);
    for (let n = 0; n < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); n++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = pe.set(this.lineGaps.map((n) => n.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let n = 0; n <= 1; n++) {
      let r = n ? t.head : t.anchor;
      if (!e.some(({ from: s, to: o }) => r >= s && r <= o)) {
        let { from: s, to: o } = this.lineBlockAt(r);
        e.push(new Fo(s, o));
      }
    }
    return this.viewports = e.sort((n, r) => n.from - r.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? rp : new Ff(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(Ys(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let n = this.stateDeco;
    this.stateDeco = this.state.facet(ao).filter((h) => typeof h != "function");
    let r = e.changedRanges, s = ui.extendWithRanges(r, Ax(n, this.stateDeco, e ? e.changes : lt.empty(this.state.doc.length))), o = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    tp(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), (this.heightMap.height != o || es) && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = o);
    let l = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < l.from || t.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, t));
    let c = l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(n0) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, n = window.getComputedStyle(t), r = this.heightOracle, s = n.whiteSpace;
    this.defaultTextDirection = n.direction == "rtl" ? We.RTL : We.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), a = t.getBoundingClientRect(), l = o || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let c = 0, h = 0;
    if (a.width && a.height) {
      let { scaleX: w, scaleY: x } = Rg(t, a);
      (w > 5e-3 && Math.abs(this.scaleX - w) > 5e-3 || x > 5e-3 && Math.abs(this.scaleY - x) > 5e-3) && (this.scaleX = w, this.scaleY = x, c |= 16, o = l = !0);
    }
    let f = (parseInt(n.paddingTop) || 0) * this.scaleY, u = (parseInt(n.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != f || this.paddingBottom != u) && (this.paddingTop = f, this.paddingBottom = u, c |= 18), this.editorWidth != e.scrollDOM.clientWidth && (r.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 16);
    let d = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != d && (this.scrollAnchorHeight = -1, this.scrollTop = d), this.scrolledToBottom = Zg(e.scrollDOM);
    let p = (this.printing ? Zx : Ex)(t, this.paddingTop), O = p.top - this.pixelViewport.top, m = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let g = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (g != this.inView && (this.inView = g, g && (l = !0)), !this.inView && !this.scrollTarget && !Mx(e.dom))
      return 0;
    let v = a.width;
    if ((this.contentDOMWidth != v || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 16), l) {
      let w = e.docView.measureVisibleLineHeights(this.viewport);
      if (r.mustRefreshForHeights(w) && (o = !0), o || r.lineWrapping && Math.abs(v - this.contentDOMWidth) > r.charWidth) {
        let { lineHeight: x, charWidth: P, textHeight: k } = e.docView.measureTextSize();
        o = x > 0 && r.refresh(s, x, P, k, Math.max(5, v / P), w), o && (e.docView.minWidth = 0, c |= 16);
      }
      O > 0 && m > 0 ? h = Math.max(O, m) : O < 0 && m < 0 && (h = Math.min(O, m)), tp();
      for (let x of this.viewports) {
        let P = x.from == this.viewport.from ? w : e.docView.measureVisibleLineHeights(x);
        this.heightMap = (o ? Zt.empty().applyChanges(this.stateDeco, Re.empty, this.heightOracle, [new ui(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(r, 0, o, new $x(x.from, P));
      }
      es && (c |= 2);
    }
    let S = !this.viewportIsAppropriate(this.viewport, h) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return S && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(h, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || S) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let n = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), r = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: a } = this, l = new Fo(r.lineAt(o - n * 1e3, Ve.ByHeight, s, 0, 0).from, r.lineAt(a + (1 - n) * 1e3, Ve.ByHeight, s, 0, 0).to);
    if (t) {
      let { head: c } = t.range;
      if (c < l.from || c > l.to) {
        let h = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), f = r.lineAt(c, Ve.ByPos, s, 0, 0), u;
        t.y == "center" ? u = (f.top + f.bottom) / 2 - h / 2 : t.y == "start" || t.y == "nearest" && c < l.from ? u = f.top : u = f.bottom - h, l = new Fo(r.lineAt(u - 1e3 / 2, Ve.ByHeight, s, 0, 0).from, r.lineAt(u + h + 1e3 / 2, Ve.ByHeight, s, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, t) {
    let n = t.mapPos(e.from, -1), r = t.mapPos(e.to, 1);
    return new Fo(this.heightMap.lineAt(n, Ve.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(r, Ve.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, n = 0) {
    if (!this.inView)
      return !0;
    let { top: r } = this.heightMap.lineAt(e, Ve.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(t, Ve.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: a } = this;
    return (e == 0 || r <= o - Math.max(10, Math.min(
      -n,
      250
      /* VP.MaxCoverMargin */
    ))) && (t == this.state.doc.length || s >= a + Math.max(10, Math.min(
      n,
      250
      /* VP.MaxCoverMargin */
    ))) && r > o - 2 * 1e3 && s < a + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let n = [];
    for (let r of e)
      t.touchesRange(r.from, r.to) || n.push(new mc(t.mapPos(r.from), t.mapPos(r.to), r.size, r.displaySize));
    return n;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let n = this.heightOracle.lineWrapping, r = n ? 1e4 : 2e3, s = r >> 1, o = r << 1;
    if (this.defaultTextDirection != We.LTR && !n)
      return [];
    let a = [], l = (h, f, u, d) => {
      if (f - h < s)
        return;
      let p = this.state.selection.main, O = [p.from];
      p.empty || O.push(p.to);
      for (let g of O)
        if (g > h && g < f) {
          l(h, g - 10, u, d), l(g + 10, f, u, d);
          return;
        }
      let m = Dx(e, (g) => g.from >= u.from && g.to <= u.to && Math.abs(g.from - h) < s && Math.abs(g.to - f) < s && !O.some((v) => g.from < v && g.to > v));
      if (!m) {
        if (f < u.to && t && n && t.visibleRanges.some((S) => S.from <= f && S.to >= f)) {
          let S = t.moveToLineBoundary(q.cursor(f), !1, !0).head;
          S > h && (f = S);
        }
        let g = this.gapSize(u, h, f, d), v = n || g < 2e6 ? g : 2e6;
        m = new mc(h, f, g, v);
      }
      a.push(m);
    }, c = (h) => {
      if (h.length < o || h.type != Mt.Text)
        return;
      let f = zx(h.from, h.to, this.stateDeco);
      if (f.total < o)
        return;
      let u = this.scrollTarget ? this.scrollTarget.range.head : null, d, p;
      if (n) {
        let O = r / this.heightOracle.lineLength * this.heightOracle.lineHeight, m, g;
        if (u != null) {
          let v = Ko(f, u), S = ((this.visibleBottom - this.visibleTop) / 2 + O) / h.height;
          m = v - S, g = v + S;
        } else
          m = (this.visibleTop - h.top - O) / h.height, g = (this.visibleBottom - h.top + O) / h.height;
        d = Ho(f, m), p = Ho(f, g);
      } else {
        let O = f.total * this.heightOracle.charWidth, m = r * this.heightOracle.charWidth, g = 0;
        if (O > 2e6)
          for (let P of e)
            P.from >= h.from && P.from < h.to && P.size != P.displaySize && P.from * this.heightOracle.charWidth + g < this.pixelViewport.left && (g = P.size - P.displaySize);
        let v = this.pixelViewport.left + g, S = this.pixelViewport.right + g, w, x;
        if (u != null) {
          let P = Ko(f, u), k = ((S - v) / 2 + m) / O;
          w = P - k, x = P + k;
        } else
          w = (v - m) / O, x = (S + m) / O;
        d = Ho(f, w), p = Ho(f, x);
      }
      d > h.from && l(h.from, d, h, f), p < h.to && l(p, h.to, h, f);
    };
    for (let h of this.viewportLines)
      Array.isArray(h.type) ? h.type.forEach(c) : c(h);
    return a;
  }
  gapSize(e, t, n, r) {
    let s = Ko(r, n) - Ko(r, t);
    return this.heightOracle.lineWrapping ? e.height * s : r.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    mc.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = pe.set(e.map((t) => t.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let t = this.stateDeco;
    this.lineGaps.length && (t = t.concat(this.lineGapDeco));
    let n = [];
    Te.spans(t, this.viewport.from, this.viewport.to, {
      span(s, o) {
        n.push({ from: s, to: o });
      },
      point() {
      }
    }, 20);
    let r = 0;
    if (n.length != this.visibleRanges.length)
      r = 12;
    else
      for (let s = 0; s < n.length && !(r & 8); s++) {
        let o = this.visibleRanges[s], a = n[s];
        (o.from != a.from || o.to != a.to) && (r |= 4, e && e.mapPos(o.from, -1) == a.from && e.mapPos(o.to, 1) == a.to || (r |= 8));
      }
    return this.visibleRanges = n, r;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || Ys(this.heightMap.lineAt(e, Ve.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((t) => t.top <= e && t.bottom >= e) || Ys(this.heightMap.lineAt(this.scaler.fromDOM(e), Ve.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return Ys(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Fo {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function zx(i, e, t) {
  let n = [], r = i, s = 0;
  return Te.spans(t, i, e, {
    span() {
    },
    point(o, a) {
      o > r && (n.push({ from: r, to: o }), s += o - r), r = a;
    }
  }, 20), r < e && (n.push({ from: r, to: e }), s += e - r), { total: s, ranges: n };
}
function Ho({ total: i, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let n = Math.floor(i * t);
  for (let r = 0; ; r++) {
    let { from: s, to: o } = e[r], a = o - s;
    if (n <= a)
      return s + n;
    n -= a;
  }
}
function Ko(i, e) {
  let t = 0;
  for (let { from: n, to: r } of i.ranges) {
    if (e <= r) {
      t += e - n;
      break;
    }
    t += r - n;
  }
  return t / i.total;
}
function Dx(i, e) {
  for (let t of i)
    if (e(t))
      return t;
}
const rp = {
  toDOM(i) {
    return i;
  },
  fromDOM(i) {
    return i;
  },
  scale: 1,
  eq(i) {
    return i == this;
  }
};
class Ff {
  constructor(e, t, n) {
    let r = 0, s = 0, o = 0;
    this.viewports = n.map(({ from: a, to: l }) => {
      let c = t.lineAt(a, Ve.ByPos, e, 0, 0).top, h = t.lineAt(l, Ve.ByPos, e, 0, 0).bottom;
      return r += h - c, { from: a, to: l, top: c, bottom: h, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - r) / (t.height - r);
    for (let a of this.viewports)
      a.domTop = o + (a.top - s) * this.scale, o = a.domBottom = a.domTop + (a.bottom - a.top), s = a.bottom;
  }
  toDOM(e) {
    for (let t = 0, n = 0, r = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.top)
        return r + (e - n) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      n = s.bottom, r = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, n = 0, r = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.domTop)
        return n + (e - r) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      n = s.bottom, r = s.domBottom;
    }
  }
  eq(e) {
    return e instanceof Ff ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((t, n) => t.from == e.viewports[n].from && t.to == e.viewports[n].to) : !1;
  }
}
function Ys(i, e) {
  if (e.scale == 1)
    return i;
  let t = e.toDOM(i.top), n = e.toDOM(i.bottom);
  return new Yi(i.from, i.length, t, n - t, Array.isArray(i._content) ? i._content.map((r) => Ys(r, e)) : i._content);
}
const Jo = /* @__PURE__ */ le.define({ combine: (i) => i.join(" ") }), Wh = /* @__PURE__ */ le.define({ combine: (i) => i.indexOf(!0) > -1 }), jh = /* @__PURE__ */ In.newName(), Q0 = /* @__PURE__ */ In.newName(), _0 = /* @__PURE__ */ In.newName(), P0 = { "&light": "." + Q0, "&dark": "." + _0 };
function Uh(i, e, t) {
  return new In(e, {
    finish(n) {
      return /&/.test(n) ? n.replace(/&\w*/, (r) => {
        if (r == "&")
          return i;
        if (!t || !t[r])
          throw new RangeError(`Unsupported selector: ${r}`);
        return t[r];
      }) : i + " " + n;
    }
  });
}
const Lx = /* @__PURE__ */ Uh("." + jh, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, P0), Ix = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, gc = re.ie && re.ie_version <= 11;
class Bx {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new xw(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let n of t)
        this.queue.push(n);
      (re.ie && re.ie_version <= 11 || re.ios && e.composing) && t.some((n) => n.type == "childList" && n.removedNodes.length || n.type == "characterData" && n.oldValue.length > n.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && re.android && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(re.chrome && re.chrome_version < 126) && (this.editContext = new Nx(e), e.state.facet(On) && (e.contentDOM.editContext = this.editContext.editContext)), gc && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, n) => t != e[n]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: n } = this, r = this.selectionRange;
    if (n.state.facet(On) ? n.root.activeElement != this.dom : !xa(this.dom, r))
      return;
    let s = r.anchorNode && n.docView.nearest(r.anchorNode);
    if (s && s.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (re.ie && re.ie_version <= 11 || re.android && re.chrome) && !n.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    r.focusNode && Gs(r.focusNode, r.focusOffset, r.anchorNode, r.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = so(e.root);
    if (!t)
      return !1;
    let n = re.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && Yx(this.view, t) || t;
    if (!n || this.selectionRange.eq(n))
      return !1;
    let r = xa(this.dom, n);
    return r && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && Qw(this.dom, n) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(n), r && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let n = this.dom; n; )
      if (n.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == n ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(n), n = n.assignedSlot || n.parentNode;
      else if (n.nodeType == 11)
        n = n.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let n of this.scrollTargets)
        n.removeEventListener("scroll", this.onScroll);
      for (let n of this.scrollTargets = t)
        n.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, Ix), gc && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), gc && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var n;
    if (!this.delayedAndroidKey) {
      let r = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && Br(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(r);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((n = this.delayedAndroidKey) === null || n === void 0) && n.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, n = -1, r = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      o && (o.typeOver && (r = !0), t == -1 ? { from: t, to: n } = o : (t = Math.min(o.from, t), n = Math.max(o.to, n)));
    }
    return { from: t, to: n, typeOver: r };
  }
  readChange() {
    let { from: e, to: t, typeOver: n } = this.processRecords(), r = this.selectionChanged && xa(this.dom, this.selectionRange);
    if (e < 0 && !r)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new ox(this.view, e, t, n);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return this.view.requestMeasure(), !1;
    let n = this.view.state, r = p0(this.view, t);
    return this.view.state == n && (t.domChanged || t.newSel && !t.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), r;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let n = sp(t, e.previousSibling || e.target.previousSibling, -1), r = sp(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: n ? t.posAfter(n) : t.posAtStart,
        to: r ? t.posBefore(r) : t.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(On) != e.state.facet(On) && (e.view.contentDOM.editContext = e.state.facet(On) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, t, n;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (n = this.resizeScroll) === null || n === void 0 || n.disconnect();
    for (let r of this.scrollTargets)
      r.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function sp(i, e, t) {
  for (; e; ) {
    let n = ze.get(e);
    if (n && n.parent == i)
      return n;
    let r = e.parentNode;
    e = r != i.dom ? r : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function op(i, e) {
  let t = e.startContainer, n = e.startOffset, r = e.endContainer, s = e.endOffset, o = i.docView.domAtPos(i.state.selection.main.anchor);
  return Gs(o.node, o.offset, r, s) && ([t, n, r, s] = [r, s, t, n]), { anchorNode: t, anchorOffset: n, focusNode: r, focusOffset: s };
}
function Yx(i, e) {
  if (e.getComposedRanges) {
    let r = e.getComposedRanges(i.root)[0];
    if (r)
      return op(i, r);
  }
  let t = null;
  function n(r) {
    r.preventDefault(), r.stopImmediatePropagation(), t = r.getTargetRanges()[0];
  }
  return i.contentDOM.addEventListener("beforeinput", n, !0), i.dom.ownerDocument.execCommand("indent"), i.contentDOM.removeEventListener("beforeinput", n, !0), t ? op(i, t) : null;
}
class Nx {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let t = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (n) => {
      let r = e.state.selection.main, { anchor: s, head: o } = r, a = this.toEditorPos(n.updateRangeStart), l = this.toEditorPos(n.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: n.updateRangeStart, editorBase: a, drifted: !1 });
      let c = l - a > n.text.length;
      a == this.from && s < this.from ? a = s : l == this.to && s > this.to && (l = s);
      let h = O0(e.state.sliceDoc(a, l), n.text, (c ? r.from : r.to) - a, c ? "end" : null);
      if (!h) {
        let u = q.single(this.toEditorPos(n.selectionStart), this.toEditorPos(n.selectionEnd));
        u.main.eq(r) || e.dispatch({ selection: u, userEvent: "select" });
        return;
      }
      let f = {
        from: h.from + a,
        to: h.toA + a,
        insert: Re.of(n.text.slice(h.from, h.toB).split(`
`))
      };
      if ((re.mac || re.android) && f.from == o - 1 && /^\. ?$/.test(n.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (f = { from: a, to: l, insert: Re.of([n.text.replace(".", " ")]) }), this.pendingContextChange = f, !e.state.readOnly) {
        let u = this.to - this.from + (f.to - f.from + f.insert.length);
        Uf(e, f, q.single(this.toEditorPos(n.selectionStart, u), this.toEditorPos(n.selectionEnd, u)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state)), f.from < f.to && !f.insert.length && e.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(t.text.slice(Math.max(0, n.updateRangeStart - 1), Math.min(t.text.length, n.updateRangeStart + 1))) && this.handlers.compositionend(n);
    }, this.handlers.characterboundsupdate = (n) => {
      let r = [], s = null;
      for (let o = this.toEditorPos(n.rangeStart), a = this.toEditorPos(n.rangeEnd); o < a; o++) {
        let l = e.coordsForChar(o);
        s = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || s || new DOMRect(), r.push(s);
      }
      t.updateCharacterBounds(n.rangeStart, r);
    }, this.handlers.textformatupdate = (n) => {
      let r = [];
      for (let s of n.getTextFormats()) {
        let o = s.underlineStyle, a = s.underlineThickness;
        if (!/none/i.test(o) && !/none/i.test(a)) {
          let l = this.toEditorPos(s.rangeStart), c = this.toEditorPos(s.rangeEnd);
          if (l < c) {
            let h = `text-decoration: underline ${/^[a-z]/.test(o) ? o + " " : o == "Dashed" ? "dashed " : o == "Squiggle" ? "wavy " : ""}${/thin/i.test(a) ? 1 : 2}px`;
            r.push(pe.mark({ attributes: { style: h } }).range(l, c));
          }
        }
      }
      e.dispatch({ effects: s0.of(pe.set(r)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: n } = this.composing;
        this.composing = null, n && this.reset(e.state);
      }
    };
    for (let n in this.handlers)
      t.addEventListener(n, this.handlers[n]);
    this.measureReq = { read: (n) => {
      this.editContext.updateControlBounds(n.contentDOM.getBoundingClientRect());
      let r = so(n.root);
      r && r.rangeCount && this.editContext.updateSelectionBounds(r.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let t = 0, n = !1, r = this.pendingContextChange;
    return e.changes.iterChanges((s, o, a, l, c) => {
      if (n)
        return;
      let h = c.length - (o - s);
      if (r && o >= r.to)
        if (r.from == s && r.to == o && r.insert.eq(c)) {
          r = this.pendingContextChange = null, t += h, this.to += h;
          return;
        } else
          r = null, this.revertPending(e.state);
      if (s += t, o += t, o <= this.from)
        this.from += h, this.to += h;
      else if (s < this.to) {
        if (s < this.from || o > this.to || this.to - this.from + c.length > 3e4) {
          n = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(s), this.toContextPos(o), c.toString()), this.to += h;
      }
      t += h;
    }), r && !n && this.revertPending(e.state), !n;
  }
  update(e) {
    let t = this.pendingContextChange, n = e.startState.selection.main;
    this.composing && (this.composing.drifted || !e.changes.touchesRange(n.from, n.to) && e.transactions.some((r) => !r.isUserEvent("input.type") && r.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || t) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: t } = e.selection.main;
    this.from = Math.max(
      0,
      t - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      t + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let t = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(t.from), this.toContextPos(t.from + t.insert.length), e.doc.sliceString(t.from, t.to));
  }
  setSelection(e) {
    let { main: t } = e.selection, n = this.toContextPos(Math.max(this.from, Math.min(this.to, t.anchor))), r = this.toContextPos(t.head);
    (this.editContext.selectionStart != n || this.editContext.selectionEnd != r) && this.editContext.updateSelection(n, r);
  }
  rangeIsValid(e) {
    let { head: t } = e.selection.main;
    return !(this.from > 0 && t - this.from < 500 || this.to < e.doc.length && this.to - t < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, t = this.to - this.from) {
    e = Math.min(e, t);
    let n = this.composing;
    return n && n.drifted ? n.editorBase + (e - n.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let t = this.composing;
    return t && t.drifted ? t.contextBase + (e - t.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
class ae {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var t;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: n } = e;
    this.dispatchTransactions = e.dispatchTransactions || n && ((r) => r.forEach((s) => n(s, this))) || ((r) => this.update(r)), this.dispatch = this.dispatch.bind(this), this._root = e.root || kw(e.parent) || document, this.viewState = new np(e.state || $e.create(e)), e.scrollTo && e.scrollTo.is(jo) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Zr).map((r) => new dc(r));
    for (let r of this.plugins)
      r.update(this);
    this.observer = new Bx(this), this.inputState = new hx(this), this.inputState.ensureHandlers(this.plugins), this.docView = new Dd(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((t = document.fonts) === null || t === void 0) && t.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof st ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, n = !1, r, s = this.state;
    for (let u of e) {
      if (u.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = u.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, a = 0, l = null;
    e.some((u) => u.annotation(S0)) ? (this.inputState.notifiedFocused = o, a = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, l = w0(s, o), l || (a = 1));
    let c = this.observer.delayedAndroidKey, h = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), h = this.observer.readChange(), (h && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (h = null)) : this.observer.clear(), s.facet($e.phrases) != this.state.facet($e.phrases))
      return this.setState(s);
    r = qa.create(this, s, e), r.flags |= a;
    let f = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let u of e) {
        if (f && (f = f.map(u.changes)), u.scrollIntoView) {
          let { main: d } = u.state.selection;
          f = new Yr(d.empty ? d : q.cursor(d.head, d.head > d.anchor ? -1 : 1));
        }
        for (let d of u.effects)
          d.is(jo) && (f = d.value.clip(this.state));
      }
      this.viewState.update(r, f), this.bidiCache = ja.update(this.bidiCache, r.changes), r.empty || (this.updatePlugins(r), this.inputState.update(r)), t = this.docView.update(r), this.state.facet(Is) != this.styleModules && this.mountStyles(), n = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((u) => u.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (r.startState.facet(Jo) != r.state.facet(Jo) && (this.viewState.mustMeasureContent = !0), (t || n || f || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), t && this.docViewUpdate(), !r.empty)
      for (let u of this.state.facet(Yh))
        try {
          u(r);
        } catch (d) {
          Wt(this.state, d, "update listener");
        }
    (l || h) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), h && !p0(this, h) && c.force && Br(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let n of this.plugins)
        n.destroy(this);
      this.viewState = new np(e), this.plugins = e.facet(Zr).map((n) => new dc(n)), this.pluginMap.clear();
      for (let n of this.plugins)
        n.update(this);
      this.docView.destroy(), this.docView = new Dd(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(Zr), n = e.state.facet(Zr);
    if (t != n) {
      let r = [];
      for (let s of n) {
        let o = t.indexOf(s);
        if (o < 0)
          r.push(new dc(s));
        else {
          let a = this.plugins[o];
          a.mustUpdate = e, r.push(a);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = r, this.pluginMap.clear();
    } else
      for (let r of this.plugins)
        r.mustUpdate = e;
    for (let r = 0; r < this.plugins.length; r++)
      this.plugins[r].update(this);
    t != n && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let t = e.value;
      if (t && t.docViewUpdate)
        try {
          t.docViewUpdate(this);
        } catch (n) {
          Wt(this.state, n, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, n = this.scrollDOM, r = n.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(r - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (o < 0)
          if (Zg(n))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let d = this.viewState.scrollAnchorAt(r);
            s = d.from, o = d.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let h = c.map((d) => {
          try {
            return d.read(this);
          } catch (p) {
            return Wt(this.state, p), ap;
          }
        }), f = qa.create(this, this.state, []), u = !1;
        f.flags |= l, t ? t.flags |= l : t = f, this.updateState = 2, f.empty || (this.updatePlugins(f), this.inputState.update(f), this.updateAttrs(), u = this.docView.update(f), u && this.docViewUpdate());
        for (let d = 0; d < c.length; d++)
          if (h[d] != ap)
            try {
              let p = c[d];
              p.write && p.write(h[d], this);
            } catch (p) {
              Wt(this.state, p);
            }
        if (u && this.docView.updateSelection(!0), !f.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let p = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (p > 1 || p < -1) {
                r = r + p, n.scrollTop = r / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let a of this.state.facet(Yh))
        a(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return jh + " " + (this.state.facet(Wh) ? _0 : Q0) + " " + this.state.facet(Jo);
  }
  updateAttrs() {
    let e = lp(this, o0, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(On) ? "true" : "false",
      class: "cm-content",
      style: `${re.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), lp(this, Wf, t);
    let n = this.observer.ignore(() => {
      let r = zh(this.contentDOM, this.contentAttrs, t), s = zh(this.dom, this.editorAttrs, e);
      return r || s;
    });
    return this.editorAttrs = e, this.contentAttrs = t, n;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let n of e)
      for (let r of n.effects)
        if (r.is(ae.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = r.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Is);
    let e = this.state.facet(ae.cspNonce);
    In.mount(this.root, this.styleModules.concat(Lx).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.plugin != e) && this.pluginMap.set(e, t = this.plugins.find((n) => n.plugin == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, n) {
    return Oc(this, e, Nd(this, e, t, n));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return Oc(this, e, Nd(this, e, t, (n) => tx(this, e.head, n)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, t) {
    let n = this.bidiSpans(e), r = this.textDirectionAt(e.from), s = n[t ? n.length - 1 : 0];
    return q.cursor(s.side(t, r) + e.from, s.forward(!t, r) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, n = !0) {
    return ex(this, e, t, n);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, n) {
    return Oc(this, e, ix(this, e, t, n));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), f0(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let n = this.docView.coordsAt(e, t);
    if (!n || n.left == n.right)
      return n;
    let r = this.state.doc.lineAt(e), s = this.bidiSpans(r), o = s[Mn.find(s, e - r.from, -1, t)];
    return Cl(n, o.dir == We.LTR == t > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(i0) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)â€”if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > Vx)
      return Ug(e.length);
    let t = this.textDirectionAt(e.from), n;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == t && (s.fresh || jg(s.isolates, n = zd(this, e))))
        return s.order;
    n || (n = zd(this, e));
    let r = Dw(e.text, t, n);
    return this.bidiCache.push(new ja(e.from, e.to, t, n, !0, r)), r;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || re.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      Eg(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return jo.of(new Yr(typeof e == "number" ? q.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: t } = this.scrollDOM, n = this.viewState.scrollAnchorAt(e);
    return jo.of(new Yr(q.cursor(n.from), "start", "start", n.top - e, t, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return ot.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return ot.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)â€”to which the scope class will be
  addedâ€”need to be explicitly differentiated by adding an `&` to
  the selector for that elementâ€”for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let n = In.newName(), r = [Jo.of(n), Is.of(Uh(`.${n}`, e))];
    return t && t.dark && r.push(Wh.of(!0)), r;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return Wn.lowest(Is.of(Uh("." + jh, e, P0)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let n = e.querySelector(".cm-content"), r = n && ze.get(n) || ze.get(e);
    return ((t = r?.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
ae.styleModule = Is;
ae.inputHandler = e0;
ae.clipboardInputFilter = Vf;
ae.clipboardOutputFilter = qf;
ae.scrollHandler = r0;
ae.focusChangeEffect = t0;
ae.perLineTextDirection = i0;
ae.exceptionSink = Jg;
ae.updateListener = Yh;
ae.editable = On;
ae.mouseSelectionStyle = Kg;
ae.dragMovesSelection = Hg;
ae.clickAddsSelectionRange = Fg;
ae.decorations = ao;
ae.outerDecorations = a0;
ae.atomicRanges = Co;
ae.bidiIsolatedRanges = l0;
ae.scrollMargins = c0;
ae.darkTheme = Wh;
ae.cspNonce = /* @__PURE__ */ le.define({ combine: (i) => i.length ? i[0] : "" });
ae.contentAttributes = Wf;
ae.editorAttributes = o0;
ae.lineWrapping = /* @__PURE__ */ ae.contentAttributes.of({ class: "cm-lineWrapping" });
ae.announce = /* @__PURE__ */ ge.define();
const Vx = 4096, ap = {};
class ja {
  constructor(e, t, n, r, s, o) {
    this.from = e, this.to = t, this.dir = n, this.isolates = r, this.fresh = s, this.order = o;
  }
  static update(e, t) {
    if (t.empty && !e.some((s) => s.fresh))
      return e;
    let n = [], r = e.length ? e[e.length - 1].dir : We.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == r && !t.touchesRange(o.from, o.to) && n.push(new ja(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return n;
  }
}
function lp(i, e, t) {
  for (let n = i.state.facet(e), r = n.length - 1; r >= 0; r--) {
    let s = n[r], o = typeof s == "function" ? s(i) : s;
    o && Xh(o, t);
  }
  return t;
}
const qx = re.mac ? "mac" : re.windows ? "win" : re.linux ? "linux" : "key";
function Wx(i, e) {
  const t = i.split(/-(?!$)/);
  let n = t[t.length - 1];
  n == "Space" && (n = " ");
  let r, s, o, a;
  for (let l = 0; l < t.length - 1; ++l) {
    const c = t[l];
    if (/^(cmd|meta|m)$/i.test(c))
      a = !0;
    else if (/^a(lt)?$/i.test(c))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? a = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return r && (n = "Alt-" + n), s && (n = "Ctrl-" + n), a && (n = "Meta-" + n), o && (n = "Shift-" + n), n;
}
function ea(i, e, t) {
  return e.altKey && (i = "Alt-" + i), e.ctrlKey && (i = "Ctrl-" + i), e.metaKey && (i = "Meta-" + i), t !== !1 && e.shiftKey && (i = "Shift-" + i), i;
}
const jx = /* @__PURE__ */ Wn.default(/* @__PURE__ */ ae.domEventHandlers({
  keydown(i, e) {
    return T0($0(e.state), i, e, "editor");
  }
})), gs = /* @__PURE__ */ le.define({ enables: jx }), cp = /* @__PURE__ */ new WeakMap();
function $0(i) {
  let e = i.facet(gs), t = cp.get(e);
  return t || cp.set(e, t = Fx(e.reduce((n, r) => n.concat(r), []))), t;
}
function Ux(i, e, t) {
  return T0($0(i.state), e, i, t);
}
let An = null;
const Gx = 4e3;
function Fx(i, e = qx) {
  let t = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), r = (o, a) => {
    let l = n[o];
    if (l == null)
      n[o] = a;
    else if (l != a)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, a, l, c, h) => {
    var f, u;
    let d = t[o] || (t[o] = /* @__PURE__ */ Object.create(null)), p = a.split(/ (?!$)/).map((g) => Wx(g, e));
    for (let g = 1; g < p.length; g++) {
      let v = p.slice(0, g).join(" ");
      r(v, !0), d[v] || (d[v] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(S) => {
          let w = An = { view: S, prefix: v, scope: o };
          return setTimeout(() => {
            An == w && (An = null);
          }, Gx), !0;
        }]
      });
    }
    let O = p.join(" ");
    r(O, !1);
    let m = d[O] || (d[O] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((u = (f = d._any) === null || f === void 0 ? void 0 : f.run) === null || u === void 0 ? void 0 : u.slice()) || []
    });
    l && m.run.push(l), c && (m.preventDefault = !0), h && (m.stopPropagation = !0);
  };
  for (let o of i) {
    let a = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of a) {
        let h = t[c] || (t[c] = /* @__PURE__ */ Object.create(null));
        h._any || (h._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: f } = o;
        for (let u in h)
          h[u].run.push((d) => f(d, Gh));
      }
    let l = o[e] || o.key;
    if (l)
      for (let c of a)
        s(c, l, o.run, o.preventDefault, o.stopPropagation), o.shift && s(c, "Shift-" + l, o.shift, o.preventDefault, o.stopPropagation);
  }
  return t;
}
let Gh = null;
function T0(i, e, t, n) {
  Gh = e;
  let r = bw(e), s = Yt(r, 0), o = Bi(s) == r.length && r != " ", a = "", l = !1, c = !1, h = !1;
  An && An.view == t && An.scope == n && (a = An.prefix + " ", g0.indexOf(e.keyCode) < 0 && (c = !0, An = null));
  let f = /* @__PURE__ */ new Set(), u = (m) => {
    if (m) {
      for (let g of m.run)
        if (!f.has(g) && (f.add(g), g(t)))
          return m.stopPropagation && (h = !0), !0;
      m.preventDefault && (m.stopPropagation && (h = !0), c = !0);
    }
    return !1;
  }, d = i[n], p, O;
  return d && (u(d[a + ea(r, e, !o)]) ? l = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(re.windows && e.ctrlKey && e.altKey) && // Alt-combinations on macOS tend to be typed characters
  !(re.mac && e.altKey && !(e.ctrlKey || e.metaKey)) && (p = Bn[e.keyCode]) && p != r ? (u(d[a + ea(p, e, !0)]) || e.shiftKey && (O = ro[e.keyCode]) != r && O != p && u(d[a + ea(O, e, !1)])) && (l = !0) : o && e.shiftKey && u(d[a + ea(r, e, !0)]) && (l = !0), !l && u(d._any) && (l = !0)), c && (l = !0), l && h && e.stopPropagation(), Gh = null, l;
}
class Ao {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, n, r, s) {
    this.className = e, this.left = t, this.top = n, this.width = r, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, n) {
    if (n.empty) {
      let r = e.coordsAtPos(n.head, n.assoc || 1);
      if (!r)
        return [];
      let s = C0(e);
      return [new Ao(t, r.left - s.left, r.top - s.top, null, r.bottom - r.top)];
    } else
      return Hx(e, t, n);
  }
}
function C0(i) {
  let e = i.scrollDOM.getBoundingClientRect();
  return { left: (i.textDirection == We.LTR ? e.left : e.right - i.scrollDOM.clientWidth * i.scaleX) - i.scrollDOM.scrollLeft * i.scaleX, top: e.top - i.scrollDOM.scrollTop * i.scaleY };
}
function hp(i, e, t, n) {
  let r = i.coordsAtPos(e, t * 2);
  if (!r)
    return n;
  let s = i.dom.getBoundingClientRect(), o = (r.top + r.bottom) / 2, a = i.posAtCoords({ x: s.left + 1, y: o }), l = i.posAtCoords({ x: s.right - 1, y: o });
  return a == null || l == null ? n : { from: Math.max(n.from, Math.min(a, l)), to: Math.min(n.to, Math.max(a, l)) };
}
function Hx(i, e, t) {
  if (t.to <= i.viewport.from || t.from >= i.viewport.to)
    return [];
  let n = Math.max(t.from, i.viewport.from), r = Math.min(t.to, i.viewport.to), s = i.textDirection == We.LTR, o = i.contentDOM, a = o.getBoundingClientRect(), l = C0(i), c = o.querySelector(".cm-line"), h = c && window.getComputedStyle(c), f = a.left + (h ? parseInt(h.paddingLeft) + Math.min(0, parseInt(h.textIndent)) : 0), u = a.right - (h ? parseInt(h.paddingRight) : 0), d = Vh(i, n, 1), p = Vh(i, r, -1), O = d.type == Mt.Text ? d : null, m = p.type == Mt.Text ? p : null;
  if (O && (i.lineWrapping || d.widgetLineBreaks) && (O = hp(i, n, 1, O)), m && (i.lineWrapping || p.widgetLineBreaks) && (m = hp(i, r, -1, m)), O && m && O.from == m.from && O.to == m.to)
    return v(S(t.from, t.to, O));
  {
    let x = O ? S(t.from, null, O) : w(d, !1), P = m ? S(null, t.to, m) : w(p, !0), k = [];
    return (O || d).to < (m || p).from - (O && m ? 1 : 0) || d.widgetLineBreaks > 1 && x.bottom + i.defaultLineHeight / 2 < P.top ? k.push(g(f, x.bottom, u, P.top)) : x.bottom < P.top && i.elementAtHeight((x.bottom + P.top) / 2).type == Mt.Text && (x.bottom = P.top = (x.bottom + P.top) / 2), v(x).concat(k).concat(v(P));
  }
  function g(x, P, k, A) {
    return new Ao(e, x - l.left, P - l.top, k - x, A - P);
  }
  function v({ top: x, bottom: P, horizontal: k }) {
    let A = [];
    for (let C = 0; C < k.length; C += 2)
      A.push(g(k[C], x, k[C + 1], P));
    return A;
  }
  function S(x, P, k) {
    let A = 1e9, C = -1e9, Z = [];
    function I(y, L, se, V, fe) {
      let W = i.coordsAtPos(y, y == k.to ? -2 : 2), ce = i.coordsAtPos(se, se == k.from ? 2 : -2);
      !W || !ce || (A = Math.min(W.top, ce.top, A), C = Math.max(W.bottom, ce.bottom, C), fe == We.LTR ? Z.push(s && L ? f : W.left, s && V ? u : ce.right) : Z.push(!s && V ? f : ce.left, !s && L ? u : W.right));
    }
    let Q = x ?? k.from, E = P ?? k.to;
    for (let y of i.visibleRanges)
      if (y.to > Q && y.from < E)
        for (let L = Math.max(y.from, Q), se = Math.min(y.to, E); ; ) {
          let V = i.state.doc.lineAt(L);
          for (let fe of i.bidiSpans(V)) {
            let W = fe.from + V.from, ce = fe.to + V.from;
            if (W >= se)
              break;
            ce > L && I(Math.max(W, L), x == null && W <= Q, Math.min(ce, se), P == null && ce >= E, fe.dir);
          }
          if (L = V.to + 1, L >= se)
            break;
        }
    return Z.length == 0 && I(Q, x == null, E, P == null, i.textDirection), { top: A, bottom: C, horizontal: Z };
  }
  function w(x, P) {
    let k = a.top + (P ? x.top : x.bottom);
    return { top: k, bottom: k, horizontal: [] };
  }
}
function Kx(i, e) {
  return i.constructor == e.constructor && i.eq(e);
}
class Jx {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(_a) != e.state.facet(_a) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, n = e.facet(_a);
    for (; t < n.length && n[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: t } = this.view;
    (e != this.scaleX || t != this.scaleY) && (this.scaleX = e, this.scaleY = t, this.dom.style.transform = `scale(${1 / e}, ${1 / t})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, n) => !Kx(t, this.drawn[n]))) {
      let t = this.dom.firstChild, n = 0;
      for (let r of e)
        r.update && t && r.constructor && this.drawn[n].constructor && r.update(t, this.drawn[n]) ? (t = t.nextSibling, n++) : this.dom.insertBefore(r.draw(), t);
      for (; t; ) {
        let r = t.nextSibling;
        t.remove(), t = r;
      }
      this.drawn = e, re.safari && re.safari_version >= 26 && (this.dom.style.display = this.dom.firstChild ? "" : "none");
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const _a = /* @__PURE__ */ le.define();
function A0(i) {
  return [
    ot.define((e) => new Jx(e, i)),
    _a.of(i)
  ];
}
const lo = /* @__PURE__ */ le.define({
  combine(i) {
    return sn(i, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function R0(i = {}) {
  return [
    lo.of(i),
    ek,
    tk,
    ik,
    n0.of(!0)
  ];
}
function E0(i) {
  return i.startState.facet(lo) != i.state.facet(lo);
}
const ek = /* @__PURE__ */ A0({
  above: !0,
  markers(i) {
    let { state: e } = i, t = e.facet(lo), n = [];
    for (let r of e.selection.ranges) {
      let s = r == e.selection.main;
      if (r.empty || t.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = r.empty ? r : q.cursor(r.head, r.head > r.anchor ? -1 : 1);
        for (let l of Ao.forRange(i, o, a))
          n.push(l);
      }
    }
    return n;
  },
  update(i, e) {
    i.transactions.some((n) => n.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = E0(i);
    return t && fp(i.state, e), i.docChanged || i.selectionSet || t;
  },
  mount(i, e) {
    fp(e.state, i);
  },
  class: "cm-cursorLayer"
});
function fp(i, e) {
  e.style.animationDuration = i.facet(lo).cursorBlinkRate + "ms";
}
const tk = /* @__PURE__ */ A0({
  above: !1,
  markers(i) {
    return i.state.selection.ranges.map((e) => e.empty ? [] : Ao.forRange(i, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(i, e) {
    return i.docChanged || i.selectionSet || i.viewportChanged || E0(i);
  },
  class: "cm-selectionLayer"
}), ik = /* @__PURE__ */ Wn.highest(/* @__PURE__ */ ae.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), M0 = /* @__PURE__ */ ge.define({
  map(i, e) {
    return i == null ? null : e.mapPos(i);
  }
}), Ns = /* @__PURE__ */ ft.define({
  create() {
    return null;
  },
  update(i, e) {
    return i != null && (i = e.changes.mapPos(i)), e.effects.reduce((t, n) => n.is(M0) ? n.value : t, i);
  }
}), nk = /* @__PURE__ */ ot.fromClass(class {
  constructor(i) {
    this.view = i, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(i) {
    var e;
    let t = i.state.field(Ns);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (i.startState.field(Ns) != t || i.docChanged || i.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: i } = this, e = i.state.field(Ns), t = e != null && i.coordsAtPos(e);
    if (!t)
      return null;
    let n = i.scrollDOM.getBoundingClientRect();
    return {
      left: t.left - n.left + i.scrollDOM.scrollLeft * i.scaleX,
      top: t.top - n.top + i.scrollDOM.scrollTop * i.scaleY,
      height: t.bottom - t.top
    };
  }
  drawCursor(i) {
    if (this.cursor) {
      let { scaleX: e, scaleY: t } = this.view;
      i ? (this.cursor.style.left = i.left / e + "px", this.cursor.style.top = i.top / t + "px", this.cursor.style.height = i.height / t + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(i) {
    this.view.state.field(Ns) != i && this.view.dispatch({ effects: M0.of(i) });
  }
}, {
  eventObservers: {
    dragover(i) {
      this.setDropPos(this.view.posAtCoords({ x: i.clientX, y: i.clientY }));
    },
    dragleave(i) {
      (i.target == this.view.contentDOM || !this.view.contentDOM.contains(i.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function rk() {
  return [Ns, nk];
}
function up(i, e, t, n, r) {
  e.lastIndex = 0;
  for (let s = i.iterRange(t, n), o = t, a; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; a = e.exec(s.value); )
        r(o + a.index, a);
}
function sk(i, e) {
  let t = i.visibleRanges;
  if (t.length == 1 && t[0].from == i.viewport.from && t[0].to == i.viewport.to)
    return t;
  let n = [];
  for (let { from: r, to: s } of t)
    r = Math.max(i.state.doc.lineAt(r).from, r - e), s = Math.min(i.state.doc.lineAt(s).to, s + e), n.length && n[n.length - 1].to >= r ? n[n.length - 1].to = s : n.push({ from: r, to: s });
  return n;
}
class ok {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: n, decorate: r, boundary: s, maxLength: o = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, r)
      this.addMatch = (a, l, c, h) => r(h, c, c + a[0].length, a, l);
    else if (typeof n == "function")
      this.addMatch = (a, l, c, h) => {
        let f = n(a, l, c);
        f && h(c, c + a[0].length, f);
      };
    else if (n)
      this.addMatch = (a, l, c, h) => h(c, c + a[0].length, n);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new wn(), n = t.add.bind(t);
    for (let { from: r, to: s } of sk(e, this.maxLength))
      up(e.state.doc, this.regexp, r, s, (o, a) => this.addMatch(a, e, o, n));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let n = 1e9, r = -1;
    return e.docChanged && e.changes.iterChanges((s, o, a, l) => {
      l >= e.view.viewport.from && a <= e.view.viewport.to && (n = Math.min(a, n), r = Math.max(l, r));
    }), e.viewportMoved || r - n > 1e3 ? this.createDeco(e.view) : r > -1 ? this.updateRange(e.view, t.map(e.changes), n, r) : t;
  }
  updateRange(e, t, n, r) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, n), a = Math.min(s.to, r);
      if (a >= o) {
        let l = e.state.doc.lineAt(o), c = l.to < a ? e.state.doc.lineAt(a) : l, h = Math.max(s.from, l.from), f = Math.min(s.to, c.to);
        if (this.boundary) {
          for (; o > l.from; o--)
            if (this.boundary.test(l.text[o - 1 - l.from])) {
              h = o;
              break;
            }
          for (; a < c.to; a++)
            if (this.boundary.test(c.text[a - c.from])) {
              f = a;
              break;
            }
        }
        let u = [], d, p = (O, m, g) => u.push(g.range(O, m));
        if (l == c)
          for (this.regexp.lastIndex = h - l.from; (d = this.regexp.exec(l.text)) && d.index < f - l.from; )
            this.addMatch(d, e, d.index + l.from, p);
        else
          up(e.state.doc, this.regexp, h, f, (O, m) => this.addMatch(m, e, O, p));
        t = t.update({ filterFrom: h, filterTo: f, filter: (O, m) => O < h || m > f, add: u });
      }
    }
    return t;
  }
}
const Fh = /x/.unicode != null ? "gu" : "g", ak = /* @__PURE__ */ new RegExp(`[\0-\b
--ÂŸÂ­Øœâ€‹â€Žâ€\u2028\u2029â€­â€®â¦â§â©\uFEFFï¿¹-ï¿¼]`, Fh), lk = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let bc = null;
function ck() {
  var i;
  if (bc == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    bc = ((i = e.tabSize) !== null && i !== void 0 ? i : e.MozTabSize) != null;
  }
  return bc || !1;
}
const Pa = /* @__PURE__ */ le.define({
  combine(i) {
    let e = sn(i, {
      render: null,
      specialChars: ak,
      addSpecialChars: null
    });
    return (e.replaceTabs = !ck()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, Fh)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, Fh)), e;
  }
});
function Z0(i = {}) {
  return [Pa.of(i), hk()];
}
let dp = null;
function hk() {
  return dp || (dp = ot.fromClass(class {
    constructor(i) {
      this.view = i, this.decorations = pe.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(i.state.facet(Pa)), this.decorations = this.decorator.createDeco(i);
    }
    makeDecorator(i) {
      return new ok({
        regexp: i.specialChars,
        decoration: (e, t, n) => {
          let { doc: r } = t.state, s = Yt(e[0], 0);
          if (s == 9) {
            let o = r.lineAt(n), a = t.state.tabSize, l = ms(o.text, a, n - o.from);
            return pe.replace({
              widget: new pk((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = pe.replace({ widget: new dk(i, s) }));
        },
        boundary: i.replaceTabs ? void 0 : /[^]/
      });
    }
    update(i) {
      let e = i.state.facet(Pa);
      i.startState.facet(Pa) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(i.view)) : this.decorations = this.decorator.updateDeco(i, this.decorations);
    }
  }, {
    decorations: (i) => i.decorations
  }));
}
const fk = "â€¢";
function uk(i) {
  return i >= 32 ? fk : i == 10 ? "â¤" : String.fromCharCode(9216 + i);
}
class dk extends Pn {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = uk(this.code), n = e.state.phrase("Control character") + " " + (lk[this.code] || "0x" + this.code.toString(16)), r = this.options.render && this.options.render(this.code, n, t);
    if (r)
      return r;
    let s = document.createElement("span");
    return s.textContent = t, s.title = n, s.setAttribute("aria-label", n), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class pk extends Pn {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function Ok() {
  return gk;
}
const mk = /* @__PURE__ */ pe.line({ class: "cm-activeLine" }), gk = /* @__PURE__ */ ot.fromClass(class {
  constructor(i) {
    this.decorations = this.getDeco(i);
  }
  update(i) {
    (i.docChanged || i.selectionSet) && (this.decorations = this.getDeco(i.view));
  }
  getDeco(i) {
    let e = -1, t = [];
    for (let n of i.state.selection.ranges) {
      let r = i.lineBlockAt(n.head);
      r.from > e && (t.push(mk.range(r.from)), e = r.from);
    }
    return pe.set(t);
  }
}, {
  decorations: (i) => i.decorations
}), Hh = 2e3;
function bk(i, e, t) {
  let n = Math.min(e.line, t.line), r = Math.max(e.line, t.line), s = [];
  if (e.off > Hh || t.off > Hh || e.col < 0 || t.col < 0) {
    let o = Math.min(e.off, t.off), a = Math.max(e.off, t.off);
    for (let l = n; l <= r; l++) {
      let c = i.doc.line(l);
      c.length <= a && s.push(q.range(c.from + o, c.to + a));
    }
  } else {
    let o = Math.min(e.col, t.col), a = Math.max(e.col, t.col);
    for (let l = n; l <= r; l++) {
      let c = i.doc.line(l), h = $h(c.text, o, i.tabSize, !0);
      if (h < 0)
        s.push(q.cursor(c.to));
      else {
        let f = $h(c.text, a, i.tabSize);
        s.push(q.range(c.from + h, c.from + f));
      }
    }
  }
  return s;
}
function yk(i, e) {
  let t = i.coordsAtPos(i.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / i.defaultCharacterWidth)) : -1;
}
function pp(i, e) {
  let t = i.posAtCoords({ x: e.clientX, y: e.clientY }, !1), n = i.state.doc.lineAt(t), r = t - n.from, s = r > Hh ? -1 : r == n.length ? yk(i, e.clientX) : ms(n.text, i.state.tabSize, t - n.from);
  return { line: n.number, col: s, off: r };
}
function vk(i, e) {
  let t = pp(i, e), n = i.state.selection;
  return t ? {
    update(r) {
      if (r.docChanged) {
        let s = r.changes.mapPos(r.startState.doc.line(t.line).from), o = r.state.doc.lineAt(s);
        t = { line: o.number, col: t.col, off: Math.min(t.off, o.length) }, n = n.map(r.changes);
      }
    },
    get(r, s, o) {
      let a = pp(i, r);
      if (!a)
        return n;
      let l = bk(i.state, t, a);
      return l.length ? o ? q.create(l.concat(n.ranges)) : q.create(l) : n;
    }
  } : null;
}
function Sk(i) {
  let e = ((t) => t.altKey && t.button == 0);
  return ae.mouseSelectionStyle.of((t, n) => e(n) ? vk(t, n) : null);
}
const wk = {
  Alt: [18, (i) => !!i.altKey],
  Control: [17, (i) => !!i.ctrlKey],
  Shift: [16, (i) => !!i.shiftKey],
  Meta: [91, (i) => !!i.metaKey]
}, xk = { style: "cursor: crosshair" };
function kk(i = {}) {
  let [e, t] = wk[i.key || "Alt"], n = ot.fromClass(class {
    constructor(r) {
      this.view = r, this.isDown = !1;
    }
    set(r) {
      this.isDown != r && (this.isDown = r, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(r) {
        this.set(r.keyCode == e || t(r));
      },
      keyup(r) {
        (r.keyCode == e || !t(r)) && this.set(!1);
      },
      mousemove(r) {
        this.set(t(r));
      }
    }
  });
  return [
    n,
    ae.contentAttributes.of((r) => {
      var s;
      return !((s = r.plugin(n)) === null || s === void 0) && s.isDown ? xk : null;
    })
  ];
}
const Es = "-10000px";
class X0 {
  constructor(e, t, n, r) {
    this.facet = t, this.createTooltipView = n, this.removeTooltipView = r, this.input = e.state.facet(t), this.tooltips = this.input.filter((o) => o);
    let s = null;
    this.tooltipViews = this.tooltips.map((o) => s = n(o, s));
  }
  update(e, t) {
    var n;
    let r = e.state.facet(this.facet), s = r.filter((l) => l);
    if (r === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return !1;
    }
    let o = [], a = t ? [] : null;
    for (let l = 0; l < s.length; l++) {
      let c = s[l], h = -1;
      if (c) {
        for (let f = 0; f < this.tooltips.length; f++) {
          let u = this.tooltips[f];
          u && u.create == c.create && (h = f);
        }
        if (h < 0)
          o[l] = this.createTooltipView(c, l ? o[l - 1] : null), a && (a[l] = !!c.above);
        else {
          let f = o[l] = this.tooltipViews[h];
          a && (a[l] = t[h]), f.update && f.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      o.indexOf(l) < 0 && (this.removeTooltipView(l), (n = l.destroy) === null || n === void 0 || n.call(l));
    return t && (a.forEach((l, c) => t[c] = l), t.length = a.length), this.input = r, this.tooltips = s, this.tooltipViews = o, !0;
  }
}
function Qk(i) {
  let e = i.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: e.clientHeight, right: e.clientWidth };
}
const yc = /* @__PURE__ */ le.define({
  combine: (i) => {
    var e, t, n;
    return {
      position: re.ios ? "absolute" : ((e = i.find((r) => r.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = i.find((r) => r.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((n = i.find((r) => r.tooltipSpace)) === null || n === void 0 ? void 0 : n.tooltipSpace) || Qk
    };
  }
}), Op = /* @__PURE__ */ new WeakMap(), Hf = /* @__PURE__ */ ot.fromClass(class {
  constructor(i) {
    this.view = i, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = i.state.facet(yc);
    this.position = e.position, this.parent = e.parent, this.classes = i.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new X0(i, Kf, (t, n) => this.createTooltip(t, n), (t) => {
      this.resizeObserver && this.resizeObserver.unobserve(t.dom), t.dom.remove();
    }), this.above = this.manager.tooltips.map((t) => !!t.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), i.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let i of this.manager.tooltipViews)
        this.intersectionObserver.observe(i.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(i) {
    i.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(i, this.above);
    e && this.observeIntersection();
    let t = e || i.geometryChanged, n = i.state.facet(yc);
    if (n.position != this.position && !this.madeAbsolute) {
      this.position = n.position;
      for (let r of this.manager.tooltipViews)
        r.dom.style.position = this.position;
      t = !0;
    }
    if (n.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = n.parent, this.createContainer();
      for (let r of this.manager.tooltipViews)
        this.container.appendChild(r.dom);
      t = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(i, e) {
    let t = i.create(this.view), n = e ? e.dom : null;
    if (t.dom.classList.add("cm-tooltip"), i.arrow && !t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let r = document.createElement("div");
      r.className = "cm-tooltip-arrow", t.dom.appendChild(r);
    }
    return t.dom.style.position = this.position, t.dom.style.top = Es, t.dom.style.left = "0px", this.container.insertBefore(t.dom, n), t.mount && t.mount(this.view), this.resizeObserver && this.resizeObserver.observe(t.dom), t;
  }
  destroy() {
    var i, e, t;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let n of this.manager.tooltipViews)
      n.dom.remove(), (i = n.destroy) === null || i === void 0 || i.call(n);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (t = this.intersectionObserver) === null || t === void 0 || t.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let i = 1, e = 1, t = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: s } = this.manager.tooltipViews[0];
      if (re.gecko)
        t = s.offsetParent != this.container.ownerDocument.body;
      else if (s.style.top == Es && s.style.left == "0px") {
        let o = s.getBoundingClientRect();
        t = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (t || this.position == "absolute")
      if (this.parent) {
        let s = this.parent.getBoundingClientRect();
        s.width && s.height && (i = s.width / this.parent.offsetWidth, e = s.height / this.parent.offsetHeight);
      } else
        ({ scaleX: i, scaleY: e } = this.view.viewState);
    let n = this.view.scrollDOM.getBoundingClientRect(), r = jf(this.view);
    return {
      visible: {
        left: n.left + r.left,
        top: n.top + r.top,
        right: n.right - r.right,
        bottom: n.bottom - r.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((s, o) => {
        let a = this.manager.tooltipViews[o];
        return a.getCoords ? a.getCoords(s.pos) : this.view.coordsAtPos(s.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: s }) => s.getBoundingClientRect()),
      space: this.view.state.facet(yc).tooltipSpace(this.view),
      scaleX: i,
      scaleY: e,
      makeAbsolute: t
    };
  }
  writeMeasure(i) {
    var e;
    if (i.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { visible: t, space: n, scaleX: r, scaleY: s } = i, o = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: h } = c, f = i.pos[a], u = i.size[a];
      if (!f || l.clip !== !1 && (f.bottom <= Math.max(t.top, n.top) || f.top >= Math.min(t.bottom, n.bottom) || f.right < Math.max(t.left, n.left) - 0.1 || f.left > Math.min(t.right, n.right) + 0.1)) {
        h.style.top = Es;
        continue;
      }
      let d = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, p = d ? 7 : 0, O = u.right - u.left, m = (e = Op.get(c)) !== null && e !== void 0 ? e : u.bottom - u.top, g = c.offset || Pk, v = this.view.textDirection == We.LTR, S = u.width > n.right - n.left ? v ? n.left : n.right - u.width : v ? Math.max(n.left, Math.min(f.left - (d ? 14 : 0) + g.x, n.right - O)) : Math.min(Math.max(n.left, f.left - O + (d ? 14 : 0) - g.x), n.right - O), w = this.above[a];
      !l.strictSide && (w ? f.top - m - p - g.y < n.top : f.bottom + m + p + g.y > n.bottom) && w == n.bottom - f.bottom > f.top - n.top && (w = this.above[a] = !w);
      let x = (w ? f.top - n.top : n.bottom - f.bottom) - p;
      if (x < m && c.resize !== !1) {
        if (x < this.view.defaultLineHeight) {
          h.style.top = Es;
          continue;
        }
        Op.set(c, m), h.style.height = (m = x) / s + "px";
      } else h.style.height && (h.style.height = "");
      let P = w ? f.top - m - p - g.y : f.bottom + p + g.y, k = S + O;
      if (c.overlap !== !0)
        for (let A of o)
          A.left < k && A.right > S && A.top < P + m && A.bottom > P && (P = w ? A.top - m - 2 - p : A.bottom + p + 2);
      if (this.position == "absolute" ? (h.style.top = (P - i.parent.top) / s + "px", mp(h, (S - i.parent.left) / r)) : (h.style.top = P / s + "px", mp(h, S / r)), d) {
        let A = f.left + (v ? g.x : -g.x) - (S + 14 - 7);
        d.style.left = A / r + "px";
      }
      c.overlap !== !0 && o.push({ left: S, top: P, right: k, bottom: P + m }), h.classList.toggle("cm-tooltip-above", w), h.classList.toggle("cm-tooltip-below", !w), c.positioned && c.positioned(i.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let i of this.manager.tooltipViews)
        i.dom.style.top = Es;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function mp(i, e) {
  let t = parseInt(i.style.left, 10);
  (isNaN(t) || Math.abs(e - t) > 1) && (i.style.left = e + "px");
}
const _k = /* @__PURE__ */ ae.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: "14px",
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), Pk = { x: 0, y: 0 }, Kf = /* @__PURE__ */ le.define({
  enables: [Hf, _k]
}), Ua = /* @__PURE__ */ le.define({
  combine: (i) => i.reduce((e, t) => e.concat(t), [])
});
class Rl {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Rl(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new X0(e, Ua, (t, n) => this.createHostedView(t, n), (t) => t.dom.remove());
  }
  createHostedView(e, t) {
    let n = e.create(this.view);
    return n.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(n.dom, t ? t.dom.nextSibling : this.dom.firstChild), this.mounted && n.mount && n.mount(this.view), n;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
  passProp(e) {
    let t;
    for (let n of this.manager.tooltipViews) {
      let r = n[e];
      if (r !== void 0) {
        if (t === void 0)
          t = r;
        else if (t !== r)
          return;
      }
    }
    return t;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const $k = /* @__PURE__ */ Kf.compute([Ua], (i) => {
  let e = i.facet(Ua);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.map((t) => {
      var n;
      return (n = t.end) !== null && n !== void 0 ? n : t.pos;
    })),
    create: Rl.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class Tk {
  constructor(e, t, n, r, s) {
    this.view = e, this.source = t, this.field = n, this.setHover = r, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: t } = this, n = e.docView.nearest(t.target);
    if (!n)
      return;
    let r, s = 1;
    if (n instanceof En)
      r = n.posAtStart;
    else {
      if (r = e.posAtCoords(t), r == null)
        return;
      let a = e.coordsAtPos(r);
      if (!a || t.y < a.top || t.y > a.bottom || t.x < a.left - e.defaultCharacterWidth || t.x > a.right + e.defaultCharacterWidth)
        return;
      let l = e.bidiSpans(e.state.doc.lineAt(r)).find((h) => h.from <= r && h.to >= r), c = l && l.dir == We.RTL ? -1 : 1;
      s = t.x < a.left ? -c : c;
    }
    let o = this.source(e, r, s);
    if (o?.then) {
      let a = this.pending = { pos: r };
      o.then((l) => {
        this.pending == a && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(l) ? l : [l]) }));
      }, (l) => Wt(e.state, l, "hover tooltip"));
    } else o && !(Array.isArray(o) && !o.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) });
  }
  get tooltip() {
    let e = this.view.plugin(Hf), t = e ? e.manager.tooltips.findIndex((n) => n.create == Rl.create) : -1;
    return t > -1 ? e.manager.tooltipViews[t] : null;
  }
  mousemove(e) {
    var t, n;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: r, tooltip: s } = this;
    if (r.length && s && !Ck(s.dom, e) || this.pending) {
      let { pos: o } = r[0] || this.pending, a = (n = (t = r[0]) === null || t === void 0 ? void 0 : t.end) !== null && n !== void 0 ? n : o;
      (o == a ? this.view.posAtCoords(this.lastMove) != o : !Ak(this.view, o, a, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: t } = this;
    if (t.length) {
      let { tooltip: n } = this;
      n && n.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(n.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let t = (n) => {
      e.removeEventListener("mouseleave", t), this.active.length && !this.view.dom.contains(n.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", t);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const ta = 4;
function Ck(i, e) {
  let { left: t, right: n, top: r, bottom: s } = i.getBoundingClientRect(), o;
  if (o = i.querySelector(".cm-tooltip-arrow")) {
    let a = o.getBoundingClientRect();
    r = Math.min(a.top, r), s = Math.max(a.bottom, s);
  }
  return e.clientX >= t - ta && e.clientX <= n + ta && e.clientY >= r - ta && e.clientY <= s + ta;
}
function Ak(i, e, t, n, r, s) {
  let o = i.scrollDOM.getBoundingClientRect(), a = i.documentTop + i.documentPadding.top + i.contentHeight;
  if (o.left > n || o.right < n || o.top > r || Math.min(o.bottom, a) < r)
    return !1;
  let l = i.posAtCoords({ x: n, y: r }, !1);
  return l >= e && l <= t;
}
function Rk(i, e = {}) {
  let t = ge.define(), n = ft.define({
    create() {
      return [];
    },
    update(r, s) {
      if (r.length && (e.hideOnChange && (s.docChanged || s.selection) ? r = [] : e.hideOn && (r = r.filter((o) => !e.hideOn(s, o))), s.docChanged)) {
        let o = [];
        for (let a of r) {
          let l = s.changes.mapPos(a.pos, -1, Ot.TrackDel);
          if (l != null) {
            let c = Object.assign(/* @__PURE__ */ Object.create(null), a);
            c.pos = l, c.end != null && (c.end = s.changes.mapPos(c.end)), o.push(c);
          }
        }
        r = o;
      }
      for (let o of s.effects)
        o.is(t) && (r = o.value), o.is(Ek) && (r = []);
      return r;
    },
    provide: (r) => Ua.from(r)
  });
  return {
    active: n,
    extension: [
      n,
      ot.define((r) => new Tk(
        r,
        i,
        n,
        t,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      $k
    ]
  };
}
function z0(i, e) {
  let t = i.plugin(Hf);
  if (!t)
    return null;
  let n = t.manager.tooltips.indexOf(e);
  return n < 0 ? null : t.manager.tooltipViews[n];
}
const Ek = /* @__PURE__ */ ge.define(), gp = /* @__PURE__ */ le.define({
  combine(i) {
    let e, t;
    for (let n of i)
      e = e || n.topContainer, t = t || n.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function co(i, e) {
  let t = i.plugin(D0), n = t ? t.specs.indexOf(e) : -1;
  return n > -1 ? t.panels[n] : null;
}
const D0 = /* @__PURE__ */ ot.fromClass(class {
  constructor(i) {
    this.input = i.state.facet(ho), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(i));
    let e = i.state.facet(gp);
    this.top = new ia(i, !0, e.topContainer), this.bottom = new ia(i, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(i) {
    let e = i.state.facet(gp);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new ia(i.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new ia(i.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = i.state.facet(ho);
    if (t != this.input) {
      let n = t.filter((l) => l), r = [], s = [], o = [], a = [];
      for (let l of n) {
        let c = this.specs.indexOf(l), h;
        c < 0 ? (h = l(i.view), a.push(h)) : (h = this.panels[c], h.update && h.update(i)), r.push(h), (h.top ? s : o).push(h);
      }
      this.specs = n, this.panels = r, this.top.sync(s), this.bottom.sync(o);
      for (let l of a)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let n of this.panels)
        n.update && n.update(i);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (i) => ae.scrollMargins.of((e) => {
    let t = e.plugin(i);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class ia {
  constructor(e, t, n) {
    this.view = e, this.top = t, this.container = n, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = bp(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = bp(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function bp(i) {
  let e = i.nextSibling;
  return i.remove(), e;
}
const ho = /* @__PURE__ */ le.define({
  enables: D0
});
class kn extends Or {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
kn.prototype.elementClass = "";
kn.prototype.toDOM = void 0;
kn.prototype.mapMode = Ot.TrackBefore;
kn.prototype.startSide = kn.prototype.endSide = -1;
kn.prototype.point = !0;
const $a = /* @__PURE__ */ le.define(), Mk = /* @__PURE__ */ le.define(), Zk = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Te.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {},
  side: "before"
}, Ks = /* @__PURE__ */ le.define();
function Xk(i) {
  return [L0(), Ks.of({ ...Zk, ...i })];
}
const yp = /* @__PURE__ */ le.define({
  combine: (i) => i.some((e) => e)
});
function L0(i) {
  return [
    zk
  ];
}
const zk = /* @__PURE__ */ ot.fromClass(class {
  constructor(i) {
    this.view = i, this.domAfter = null, this.prevViewport = i.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters cm-gutters-before", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = i.state.facet(Ks).map((e) => new Sp(i, e)), this.fixed = !i.state.facet(yp);
    for (let e of this.gutters)
      e.config.side == "after" ? this.getDOMAfter().appendChild(e.dom) : this.dom.appendChild(e.dom);
    this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), i.scrollDOM.insertBefore(this.dom, i.contentDOM);
  }
  getDOMAfter() {
    return this.domAfter || (this.domAfter = document.createElement("div"), this.domAfter.className = "cm-gutters cm-gutters-after", this.domAfter.setAttribute("aria-hidden", "true"), this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.domAfter.style.position = this.fixed ? "sticky" : "", this.view.scrollDOM.appendChild(this.domAfter)), this.domAfter;
  }
  update(i) {
    if (this.updateGutters(i)) {
      let e = this.prevViewport, t = i.view.viewport, n = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(n < (t.to - t.from) * 0.8);
    }
    if (i.geometryChanged) {
      let e = this.view.contentHeight / this.view.scaleY + "px";
      this.dom.style.minHeight = e, this.domAfter && (this.domAfter.style.minHeight = e);
    }
    this.view.state.facet(yp) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : "", this.domAfter && (this.domAfter.style.position = this.fixed ? "sticky" : "")), this.prevViewport = i.view.viewport;
  }
  syncGutters(i) {
    let e = this.dom.nextSibling;
    i && (this.dom.remove(), this.domAfter && this.domAfter.remove());
    let t = Te.iter(this.view.state.facet($a), this.view.viewport.from), n = [], r = this.gutters.map((s) => new Dk(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (n.length && (n = []), Array.isArray(s.type)) {
        let o = !0;
        for (let a of s.type)
          if (a.type == Mt.Text && o) {
            Kh(t, n, a.from);
            for (let l of r)
              l.line(this.view, a, n);
            o = !1;
          } else if (a.widget)
            for (let l of r)
              l.widget(this.view, a);
      } else if (s.type == Mt.Text) {
        Kh(t, n, s.from);
        for (let o of r)
          o.line(this.view, s, n);
      } else if (s.widget)
        for (let o of r)
          o.widget(this.view, s);
    for (let s of r)
      s.finish();
    i && (this.view.scrollDOM.insertBefore(this.dom, e), this.domAfter && this.view.scrollDOM.appendChild(this.domAfter));
  }
  updateGutters(i) {
    let e = i.startState.facet(Ks), t = i.state.facet(Ks), n = i.docChanged || i.heightChanged || i.viewportChanged || !Te.eq(i.startState.facet($a), i.state.facet($a), i.view.viewport.from, i.view.viewport.to);
    if (e == t)
      for (let r of this.gutters)
        r.update(i) && (n = !0);
    else {
      n = !0;
      let r = [];
      for (let s of t) {
        let o = e.indexOf(s);
        o < 0 ? r.push(new Sp(this.view, s)) : (this.gutters[o].update(i), r.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), r.indexOf(s) < 0 && s.destroy();
      for (let s of r)
        s.config.side == "after" ? this.getDOMAfter().appendChild(s.dom) : this.dom.appendChild(s.dom);
      this.gutters = r;
    }
    return n;
  }
  destroy() {
    for (let i of this.gutters)
      i.destroy();
    this.dom.remove(), this.domAfter && this.domAfter.remove();
  }
}, {
  provide: (i) => ae.scrollMargins.of((e) => {
    let t = e.plugin(i);
    if (!t || t.gutters.length == 0 || !t.fixed)
      return null;
    let n = t.dom.offsetWidth * e.scaleX, r = t.domAfter ? t.domAfter.offsetWidth * e.scaleX : 0;
    return e.textDirection == We.LTR ? { left: n, right: r } : { right: n, left: r };
  })
});
function vp(i) {
  return Array.isArray(i) ? i : [i];
}
function Kh(i, e, t) {
  for (; i.value && i.from <= t; )
    i.from == t && e.push(i.value), i.next();
}
class Dk {
  constructor(e, t, n) {
    this.gutter = e, this.height = n, this.i = 0, this.cursor = Te.iter(e.markers, t.from);
  }
  addElement(e, t, n) {
    let { gutter: r } = this, s = (t.top - this.height) / e.scaleY, o = t.height / e.scaleY;
    if (this.i == r.elements.length) {
      let a = new I0(e, o, s, n);
      r.elements.push(a), r.dom.appendChild(a.dom);
    } else
      r.elements[this.i].update(e, o, s, n);
    this.height = t.bottom, this.i++;
  }
  line(e, t, n) {
    let r = [];
    Kh(this.cursor, r, t.from), n.length && (r = r.concat(n));
    let s = this.gutter.config.lineMarker(e, t, r);
    s && r.unshift(s);
    let o = this.gutter;
    r.length == 0 && !o.config.renderEmptyElements || this.addElement(e, t, r);
  }
  widget(e, t) {
    let n = this.gutter.config.widgetMarker(e, t.widget, t), r = n ? [n] : null;
    for (let s of e.state.facet(Mk)) {
      let o = s(e, t.widget, t);
      o && (r || (r = [])).push(o);
    }
    r && this.addElement(e, t, r);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class Sp {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let n in t.domEventHandlers)
      this.dom.addEventListener(n, (r) => {
        let s = r.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let l = s.getBoundingClientRect();
          o = (l.top + l.bottom) / 2;
        } else
          o = r.clientY;
        let a = e.lineBlockAtHeight(o - e.documentTop);
        t.domEventHandlers[n](e, a, r) && r.preventDefault();
      });
    this.markers = vp(t.markers(e)), t.initialSpacer && (this.spacer = new I0(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = vp(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let r = this.config.updateSpacer(this.spacer.markers[0], e);
      r != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [r]);
    }
    let n = e.view.viewport;
    return !Te.eq(this.markers, t, n.from, n.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class I0 {
  constructor(e, t, n, r) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, n, r);
  }
  update(e, t, n, r) {
    this.height != t && (this.height = t, this.dom.style.height = t + "px"), this.above != n && (this.dom.style.marginTop = (this.above = n) ? n + "px" : ""), Lk(this.markers, r) || this.setMarkers(e, r);
  }
  setMarkers(e, t) {
    let n = "cm-gutterElement", r = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let a = o, l = s < t.length ? t[s++] : null, c = !1;
      if (l) {
        let h = l.elementClass;
        h && (n += " " + h);
        for (let f = o; f < this.markers.length; f++)
          if (this.markers[f].compare(l)) {
            a = f, c = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; o < a; ) {
        let h = this.markers[o++];
        if (h.toDOM) {
          h.destroy(r);
          let f = r.nextSibling;
          r.remove(), r = f;
        }
      }
      if (!l)
        break;
      l.toDOM && (c ? r = r.nextSibling : this.dom.insertBefore(l.toDOM(e), r)), c && o++;
    }
    this.dom.className = n, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function Lk(i, e) {
  if (i.length != e.length)
    return !1;
  for (let t = 0; t < i.length; t++)
    if (!i[t].compare(e[t]))
      return !1;
  return !0;
}
const Ik = /* @__PURE__ */ le.define(), Bk = /* @__PURE__ */ le.define(), Xr = /* @__PURE__ */ le.define({
  combine(i) {
    return sn(i, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let n = Object.assign({}, e);
        for (let r in t) {
          let s = n[r], o = t[r];
          n[r] = s ? (a, l, c) => s(a, l, c) || o(a, l, c) : o;
        }
        return n;
      }
    });
  }
});
class vc extends kn {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function Sc(i, e) {
  return i.state.facet(Xr).formatNumber(e, i.state);
}
const Yk = /* @__PURE__ */ Ks.compute([Xr], (i) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(Ik);
  },
  lineMarker(e, t, n) {
    return n.some((r) => r.toDOM) ? null : new vc(Sc(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: (e, t, n) => {
    for (let r of e.state.facet(Bk)) {
      let s = r(e, t, n);
      if (s)
        return s;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(Xr) != e.state.facet(Xr),
  initialSpacer(e) {
    return new vc(Sc(e, wp(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let n = Sc(t.view, wp(t.view.state.doc.lines));
    return n == e.number ? e : new vc(n);
  },
  domEventHandlers: i.facet(Xr).domEventHandlers,
  side: "before"
}));
function Nk(i = {}) {
  return [
    Xr.of(i),
    L0(),
    Yk
  ];
}
function wp(i) {
  let e = 9;
  for (; e < i; )
    e = e * 10 + 9;
  return e;
}
const Vk = /* @__PURE__ */ new class extends kn {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), qk = /* @__PURE__ */ $a.compute(["selection"], (i) => {
  let e = [], t = -1;
  for (let n of i.selection.ranges) {
    let r = i.doc.lineAt(n.head).from;
    r > t && (t = r, e.push(Vk.range(r)));
  }
  return Te.of(e);
});
function Wk() {
  return qk;
}
const B0 = 1024;
let jk = 0;
class ci {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
class Se {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = jk++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    }), this.combine = e.combine || null;
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Dt.match(e)), (t) => {
      let n = e(t);
      return n === void 0 ? null : [this, n];
    };
  }
}
Se.closedBy = new Se({ deserialize: (i) => i.split(" ") });
Se.openedBy = new Se({ deserialize: (i) => i.split(" ") });
Se.group = new Se({ deserialize: (i) => i.split(" ") });
Se.isolate = new Se({ deserialize: (i) => {
  if (i && i != "rtl" && i != "ltr" && i != "auto")
    throw new RangeError("Invalid value for isolate: " + i);
  return i || "auto";
} });
Se.contextHash = new Se({ perNode: !0 });
Se.lookAhead = new Se({ perNode: !0 });
Se.mounted = new Se({ perNode: !0 });
class fo {
  constructor(e, t, n) {
    this.tree = e, this.overlay = t, this.parser = n;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[Se.mounted.id];
  }
}
const Uk = /* @__PURE__ */ Object.create(null);
class Dt {
  /**
  @internal
  */
  constructor(e, t, n, r = 0) {
    this.name = e, this.props = t, this.id = n, this.flags = r;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : Uk, n = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), r = new Dt(e.name || "", t, e.id, n);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(r)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[s[0].id] = s[1];
        }
    }
    return r;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(Se.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let n in e)
      for (let r of n.split(" "))
        t[r] = e[n];
    return (n) => {
      for (let r = n.prop(Se.group), s = -1; s < (r ? r.length : 0); s++) {
        let o = t[s < 0 ? n.name : r[s]];
        if (o)
          return o;
      }
    };
  }
}
Dt.none = new Dt(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class Jf {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let t = [];
    for (let n of this.types) {
      let r = null;
      for (let s of e) {
        let o = s(n);
        if (o) {
          r || (r = Object.assign({}, n.props));
          let a = o[1], l = o[0];
          l.combine && l.id in r && (a = l.combine(r[l.id], a)), r[l.id] = a;
        }
      }
      t.push(r ? new Dt(n.name, r, n.id, n.flags) : n);
    }
    return new Jf(t);
  }
}
const na = /* @__PURE__ */ new WeakMap(), xp = /* @__PURE__ */ new WeakMap();
var Ye;
(function(i) {
  i[i.ExcludeBuffers = 1] = "ExcludeBuffers", i[i.IncludeAnonymous = 2] = "IncludeAnonymous", i[i.IgnoreMounts = 4] = "IgnoreMounts", i[i.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Ye || (Ye = {}));
class He {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, t, n, r, s) {
    if (this.type = e, this.children = t, this.positions = n, this.length = r, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, a] of s)
        this.props[typeof o == "number" ? o : o.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = fo.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let n of this.children) {
      let r = n.toString();
      r && (t && (t += ","), t += r);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new Ga(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, t = 0, n = 0) {
    let r = na.get(this) || this.topNode, s = new Ga(r);
    return s.moveTo(e, t), na.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Qt(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, t = 0) {
    let n = uo(na.get(this) || this.topNode, e, t, !1);
    return na.set(this, n), n;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, t = 0) {
    let n = uo(xp.get(this) || this.topNode, e, t, !0);
    return xp.set(this, n), n;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, t = 0) {
    return Hk(this, e, t);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: t, leave: n, from: r = 0, to: s = this.length } = e, o = e.mode || 0, a = (o & Ye.IncludeAnonymous) > 0;
    for (let l = this.cursor(o | Ye.IncludeAnonymous); ; ) {
      let c = !1;
      if (l.from <= s && l.to >= r && (!a && l.type.isAnonymous || t(l) !== !1)) {
        if (l.firstChild())
          continue;
        c = !0;
      }
      for (; c && n && (a || !l.type.isAnonymous) && n(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : iu(Dt.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, n, r) => new He(this.type, t, n, r, this.propValues), e.makeTree || ((t, n, r) => new He(Dt.none, t, n, r)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return Kk(e);
  }
}
He.empty = new He(Dt.none, [], [], 0);
class eu {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new eu(this.buffer, this.index);
  }
}
class Nn {
  /**
  Create a tree buffer.
  */
  constructor(e, t, n) {
    this.buffer = e, this.length = t, this.set = n;
  }
  /**
  @internal
  */
  get type() {
    return Dt.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let t = this.buffer[e], n = this.buffer[e + 3], r = this.set.types[t], s = r.name;
    if (/\W/.test(s) && !r.isError && (s = JSON.stringify(s)), e += 4, n == e)
      return s;
    let o = [];
    for (; e < n; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, t, n, r, s) {
    let { buffer: o } = this, a = -1;
    for (let l = e; l != t && !(Y0(s, r, o[l + 1], o[l + 2]) && (a = l, n > 0)); l = o[l + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, t, n) {
    let r = this.buffer, s = new Uint16Array(t - e), o = 0;
    for (let a = e, l = 0; a < t; ) {
      s[l++] = r[a++], s[l++] = r[a++] - n;
      let c = s[l++] = r[a++] - n;
      s[l++] = r[a++] - e, o = Math.max(o, c);
    }
    return new Nn(s, o, this.set);
  }
}
function Y0(i, e, t, n) {
  switch (i) {
    case -2:
      return t < e;
    case -1:
      return n >= e && t < e;
    case 0:
      return t < e && n > e;
    case 1:
      return t <= e && n > e;
    case 2:
      return n > e;
    case 4:
      return !0;
  }
}
function uo(i, e, t, n) {
  for (var r; i.from == i.to || (t < 1 ? i.from >= e : i.from > e) || (t > -1 ? i.to <= e : i.to < e); ) {
    let o = !n && i instanceof Qt && i.index < 0 ? null : i.parent;
    if (!o)
      return i;
    i = o;
  }
  let s = n ? 0 : Ye.IgnoreOverlays;
  if (n)
    for (let o = i, a = o.parent; a; o = a, a = o.parent)
      o instanceof Qt && o.index < 0 && ((r = a.enter(e, t, s)) === null || r === void 0 ? void 0 : r.from) != o.from && (i = a);
  for (; ; ) {
    let o = i.enter(e, t, s);
    if (!o)
      return i;
    i = o;
  }
}
class N0 {
  cursor(e = 0) {
    return new Ga(this, e);
  }
  getChild(e, t = null, n = null) {
    let r = kp(this, e, t, n);
    return r.length ? r[0] : null;
  }
  getChildren(e, t = null, n = null) {
    return kp(this, e, t, n);
  }
  resolve(e, t = 0) {
    return uo(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return uo(this, e, t, !0);
  }
  matchContext(e) {
    return Jh(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let t = this.childBefore(e), n = this;
    for (; t; ) {
      let r = t.lastChild;
      if (!r || r.to != t.to)
        break;
      r.type.isError && r.from == r.to ? (n = t, t = r.prevSibling) : t = r;
    }
    return n;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Qt extends N0 {
  constructor(e, t, n, r) {
    super(), this._tree = e, this.from = t, this.index = n, this._parent = r;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, n, r, s = 0) {
    for (let o = this; ; ) {
      for (let { children: a, positions: l } = o._tree, c = t > 0 ? a.length : -1; e != c; e += t) {
        let h = a[e], f = l[e] + o.from;
        if (Y0(r, n, f, f + h.length)) {
          if (h instanceof Nn) {
            if (s & Ye.ExcludeBuffers)
              continue;
            let u = h.findChild(0, h.buffer.length, t, n - f, r);
            if (u > -1)
              return new Wi(new Gk(o, h, e, f), null, u);
          } else if (s & Ye.IncludeAnonymous || !h.type.isAnonymous || tu(h)) {
            let u;
            if (!(s & Ye.IgnoreMounts) && (u = fo.get(h)) && !u.overlay)
              return new Qt(u.tree, f, e, o);
            let d = new Qt(h, f, e, o);
            return s & Ye.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(t < 0 ? h.children.length - 1 : 0, t, n, r);
          }
        }
      }
      if (s & Ye.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + t : e = t < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, n = 0) {
    let r;
    if (!(n & Ye.IgnoreOverlays) && (r = fo.get(this._tree)) && r.overlay) {
      let s = e - this.from;
      for (let { from: o, to: a } of r.overlay)
        if ((t > 0 ? o <= s : o < s) && (t < 0 ? a >= s : a > s))
          return new Qt(r.tree, r.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, n);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function kp(i, e, t, n) {
  let r = i.cursor(), s = [];
  if (!r.firstChild())
    return s;
  if (t != null) {
    for (let o = !1; !o; )
      if (o = r.type.is(t), !r.nextSibling())
        return s;
  }
  for (; ; ) {
    if (n != null && r.type.is(n))
      return s;
    if (r.type.is(e) && s.push(r.node), !r.nextSibling())
      return n == null ? s : [];
  }
}
function Jh(i, e, t = e.length - 1) {
  for (let n = i; t >= 0; n = n.parent) {
    if (!n)
      return !1;
    if (!n.type.isAnonymous) {
      if (e[t] && e[t] != n.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class Gk {
  constructor(e, t, n, r) {
    this.parent = e, this.buffer = t, this.index = n, this.start = r;
  }
}
class Wi extends N0 {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, n) {
    super(), this.context = e, this._parent = t, this.index = n, this.type = e.buffer.set.types[e.buffer.buffer[n]];
  }
  child(e, t, n) {
    let { buffer: r } = this.context, s = r.findChild(this.index + 4, r.buffer[this.index + 3], e, t - this.context.start, n);
    return s < 0 ? null : new Wi(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, n = 0) {
    if (n & Ye.ExcludeBuffers)
      return null;
    let { buffer: r } = this.context, s = r.findChild(this.index + 4, r.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return s < 0 ? null : new Wi(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Wi(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new Wi(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: n } = this.context, r = this.index + 4, s = n.buffer[this.index + 3];
    if (s > r) {
      let o = n.buffer[this.index + 1];
      e.push(n.slice(r, s, o)), t.push(0);
    }
    return new He(this.type, e, t, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function V0(i) {
  if (!i.length)
    return null;
  let e = 0, t = i[0];
  for (let s = 1; s < i.length; s++) {
    let o = i[s];
    (o.from > t.from || o.to < t.to) && (t = o, e = s);
  }
  let n = t instanceof Qt && t.index < 0 ? null : t.parent, r = i.slice();
  return n ? r[e] = n : r.splice(e, 1), new Fk(r, t);
}
class Fk {
  constructor(e, t) {
    this.heads = e, this.node = t;
  }
  get next() {
    return V0(this.heads);
  }
}
function Hk(i, e, t) {
  let n = i.resolveInner(e, t), r = null;
  for (let s = n instanceof Qt ? n : n.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (r || (r = [n])).push(o.resolve(e, t)), s = o;
    } else {
      let o = fo.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let a = new Qt(o.tree, o.overlay[0].from + s.from, -1, s);
        (r || (r = [n])).push(uo(a, e, t, !1));
      }
    }
  return r ? V0(r) : n;
}
class Ga {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Qt)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let n = e._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: n, buffer: r } = this.buffer;
    return this.type = t || r.set.types[r.buffer[e]], this.from = n + r.buffer[e + 1], this.to = n + r.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof Qt ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, t, n) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, n, this.mode));
    let { buffer: r } = this.buffer, s = r.findChild(this.index + 4, r.buffer[this.index + 3], e, t - this.buffer.start, n);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, t, n = this.mode) {
    return this.buffer ? n & Ye.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, n));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Ye.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Ye.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, n = this.stack.length - 1;
    if (e < 0) {
      let r = n < 0 ? 0 : this.stack[n] + 4;
      if (this.index != r)
        return this.yieldBuf(t.findChild(
          r,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let r = t.buffer[this.index + 3];
      if (r < (n < 0 ? t.buffer.length : t.buffer[this.stack[n] + 3]))
        return this.yieldBuf(r);
    }
    return n < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, n, { buffer: r } = this;
    if (r) {
      if (e > 0) {
        if (this.index < r.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (r.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: t, parent: n } = r);
    } else
      ({ index: t, _parent: n } = this._tree);
    for (; n; { index: t, _parent: n } = n)
      if (t > -1)
        for (let s = t + e, o = e < 0 ? -1 : n._tree.children.length; s != o; s += e) {
          let a = n._tree.children[s];
          if (this.mode & Ye.IncludeAnonymous || a instanceof Nn || !a.type.isAnonymous || tu(a))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, n = 0;
    if (e && e.context == this.buffer)
      e: for (let r = this.index, s = this.stack.length; s >= 0; ) {
        for (let o = e; o; o = o._parent)
          if (o.index == r) {
            if (r == this.index)
              return o;
            t = o, n = s + 1;
            break e;
          }
        r = this.stack[--s];
      }
    for (let r = n; r < this.stack.length; r++)
      t = new Wi(this.buffer, t, this.stack[r]);
    return this.bufferNode = new Wi(this.buffer, t, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, t) {
    for (let n = 0; ; ) {
      let r = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          n++;
          continue;
        }
        this.type.isAnonymous || (r = !0);
      }
      for (; ; ) {
        if (r && t && t(this), r = this.type.isAnonymous, !n)
          return;
        if (this.nextSibling())
          break;
        this.parent(), n--, r = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contextâ€”a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return Jh(this.node.parent, e);
    let { buffer: t } = this.buffer, { types: n } = t.set;
    for (let r = e.length - 1, s = this.stack.length - 1; r >= 0; s--) {
      if (s < 0)
        return Jh(this._tree, e, r);
      let o = n[t.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[r] && e[r] != o.name)
          return !1;
        r--;
      }
    }
    return !0;
  }
}
function tu(i) {
  return i.children.some((e) => e instanceof Nn || !e.type.isAnonymous || tu(e));
}
function Kk(i) {
  var e;
  let { buffer: t, nodeSet: n, maxBufferLength: r = B0, reused: s = [], minRepeatType: o = n.types.length } = i, a = Array.isArray(t) ? new eu(t, t.length) : t, l = n.types, c = 0, h = 0;
  function f(x, P, k, A, C, Z) {
    let { id: I, start: Q, end: E, size: y } = a, L = h, se = c;
    if (y < 0)
      if (a.next(), y == -1) {
        let z = s[I];
        k.push(z), A.push(Q - x);
        return;
      } else if (y == -3) {
        c = I;
        return;
      } else if (y == -4) {
        h = I;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${y}`);
    let V = l[I], fe, W, ce = Q - x;
    if (E - Q <= r && (W = m(a.pos - P, C))) {
      let z = new Uint16Array(W.size - W.skip), D = a.pos - W.size, J = z.length;
      for (; a.pos > D; )
        J = g(W.start, z, J);
      fe = new Nn(z, E - W.start, n), ce = W.start - x;
    } else {
      let z = a.pos - y;
      a.next();
      let D = [], J = [], ie = I >= o ? I : -1, U = 0, Qe = E;
      for (; a.pos > z; )
        ie >= 0 && a.id == ie && a.size >= 0 ? (a.end <= Qe - r && (p(D, J, Q, U, a.end, Qe, ie, L, se), U = D.length, Qe = a.end), a.next()) : Z > 2500 ? u(Q, z, D, J) : f(Q, z, D, J, ie, Z + 1);
      if (ie >= 0 && U > 0 && U < D.length && p(D, J, Q, U, Q, Qe, ie, L, se), D.reverse(), J.reverse(), ie > -1 && U > 0) {
        let Ie = d(V, se);
        fe = iu(V, D, J, 0, D.length, 0, E - Q, Ie, Ie);
      } else
        fe = O(V, D, J, E - Q, L - E, se);
    }
    k.push(fe), A.push(ce);
  }
  function u(x, P, k, A) {
    let C = [], Z = 0, I = -1;
    for (; a.pos > P; ) {
      let { id: Q, start: E, end: y, size: L } = a;
      if (L > 4)
        a.next();
      else {
        if (I > -1 && E < I)
          break;
        I < 0 && (I = y - r), C.push(Q, E, y), Z++, a.next();
      }
    }
    if (Z) {
      let Q = new Uint16Array(Z * 4), E = C[C.length - 2];
      for (let y = C.length - 3, L = 0; y >= 0; y -= 3)
        Q[L++] = C[y], Q[L++] = C[y + 1] - E, Q[L++] = C[y + 2] - E, Q[L++] = L;
      k.push(new Nn(Q, C[2] - E, n)), A.push(E - x);
    }
  }
  function d(x, P) {
    return (k, A, C) => {
      let Z = 0, I = k.length - 1, Q, E;
      if (I >= 0 && (Q = k[I]) instanceof He) {
        if (!I && Q.type == x && Q.length == C)
          return Q;
        (E = Q.prop(Se.lookAhead)) && (Z = A[I] + Q.length + E);
      }
      return O(x, k, A, C, Z, P);
    };
  }
  function p(x, P, k, A, C, Z, I, Q, E) {
    let y = [], L = [];
    for (; x.length > A; )
      y.push(x.pop()), L.push(P.pop() + k - C);
    x.push(O(n.types[I], y, L, Z - C, Q - Z, E)), P.push(C - k);
  }
  function O(x, P, k, A, C, Z, I) {
    if (Z) {
      let Q = [Se.contextHash, Z];
      I = I ? [Q].concat(I) : [Q];
    }
    if (C > 25) {
      let Q = [Se.lookAhead, C];
      I = I ? [Q].concat(I) : [Q];
    }
    return new He(x, P, k, A, I);
  }
  function m(x, P) {
    let k = a.fork(), A = 0, C = 0, Z = 0, I = k.end - r, Q = { size: 0, start: 0, skip: 0 };
    e: for (let E = k.pos - x; k.pos > E; ) {
      let y = k.size;
      if (k.id == P && y >= 0) {
        Q.size = A, Q.start = C, Q.skip = Z, Z += 4, A += 4, k.next();
        continue;
      }
      let L = k.pos - y;
      if (y < 0 || L < E || k.start < I)
        break;
      let se = k.id >= o ? 4 : 0, V = k.start;
      for (k.next(); k.pos > L; ) {
        if (k.size < 0)
          if (k.size == -3)
            se += 4;
          else
            break e;
        else k.id >= o && (se += 4);
        k.next();
      }
      C = V, A += y, Z += se;
    }
    return (P < 0 || A == x) && (Q.size = A, Q.start = C, Q.skip = Z), Q.size > 4 ? Q : void 0;
  }
  function g(x, P, k) {
    let { id: A, start: C, end: Z, size: I } = a;
    if (a.next(), I >= 0 && A < o) {
      let Q = k;
      if (I > 4) {
        let E = a.pos - (I - 4);
        for (; a.pos > E; )
          k = g(x, P, k);
      }
      P[--k] = Q, P[--k] = Z - x, P[--k] = C - x, P[--k] = A;
    } else I == -3 ? c = A : I == -4 && (h = A);
    return k;
  }
  let v = [], S = [];
  for (; a.pos > 0; )
    f(i.start || 0, i.bufferStart || 0, v, S, -1, 0);
  let w = (e = i.length) !== null && e !== void 0 ? e : v.length ? S[0] + v[0].length : 0;
  return new He(l[i.topID], v.reverse(), S.reverse(), w);
}
const Qp = /* @__PURE__ */ new WeakMap();
function Ta(i, e) {
  if (!i.isAnonymous || e instanceof Nn || e.type != i)
    return 1;
  let t = Qp.get(e);
  if (t == null) {
    t = 1;
    for (let n of e.children) {
      if (n.type != i || !(n instanceof He)) {
        t = 1;
        break;
      }
      t += Ta(i, n);
    }
    Qp.set(e, t);
  }
  return t;
}
function iu(i, e, t, n, r, s, o, a, l) {
  let c = 0;
  for (let p = n; p < r; p++)
    c += Ta(i, e[p]);
  let h = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), f = [], u = [];
  function d(p, O, m, g, v) {
    for (let S = m; S < g; ) {
      let w = S, x = O[S], P = Ta(i, p[S]);
      for (S++; S < g; S++) {
        let k = Ta(i, p[S]);
        if (P + k >= h)
          break;
        P += k;
      }
      if (S == w + 1) {
        if (P > h) {
          let k = p[w];
          d(k.children, k.positions, 0, k.children.length, O[w] + v);
          continue;
        }
        f.push(p[w]);
      } else {
        let k = O[S - 1] + p[S - 1].length - x;
        f.push(iu(i, p, O, w, S, x, k, null, l));
      }
      u.push(x + v - s);
    }
  }
  return d(e, t, n, r, 0), (a || l)(f, u, o);
}
class q0 {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, n) {
    let r = this.map.get(e);
    r || this.map.set(e, r = /* @__PURE__ */ new Map()), r.set(t, n);
  }
  getBuffer(e, t) {
    let n = this.map.get(e);
    return n && n.get(t);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, t) {
    e instanceof Wi ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof Qt && this.map.set(e.tree, t);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof Wi ? this.getBuffer(e.context.buffer, e.index) : e instanceof Qt ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class vn {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, t, n, r, s = !1, o = !1) {
    this.from = e, this.to = t, this.tree = n, this.offset = r, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, t = [], n = !1) {
    let r = [new vn(0, e.length, e, 0, !1, n)];
    for (let s of t)
      s.to > e.length && r.push(s);
    return r;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, t, n = 128) {
    if (!t.length)
      return e;
    let r = [], s = 1, o = e.length ? e[0] : null;
    for (let a = 0, l = 0, c = 0; ; a++) {
      let h = a < t.length ? t[a] : null, f = h ? h.fromA : 1e9;
      if (f - l >= n)
        for (; o && o.from < f; ) {
          let u = o;
          if (l >= u.from || f <= u.to || c) {
            let d = Math.max(u.from, l) - c, p = Math.min(u.to, f) - c;
            u = d >= p ? null : new vn(d, p, u.tree, u.offset + c, a > 0, !!h);
          }
          if (u && r.push(u), o.to > f)
            break;
          o = s < e.length ? e[s++] : null;
        }
      if (!h)
        break;
      l = h.toA, c = h.toA - h.toB;
    }
    return r;
  }
}
class W0 {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, t, n) {
    return typeof e == "string" && (e = new Jk(e)), n = n ? n.length ? n.map((r) => new ci(r.from, r.to)) : [new ci(0, 0)] : [new ci(0, e.length)], this.createParse(e, t || [], n);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, t, n) {
    let r = this.startParse(e, t, n);
    for (; ; ) {
      let s = r.advance();
      if (s)
        return s;
    }
  }
}
class Jk {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function eQ(i) {
  return (e, t, n, r) => new iQ(e, i, t, n, r);
}
class _p {
  constructor(e, t, n, r, s) {
    this.parser = e, this.parse = t, this.overlay = n, this.target = r, this.from = s;
  }
}
function Pp(i) {
  if (!i.length || i.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(i));
}
class tQ {
  constructor(e, t, n, r, s, o, a) {
    this.parser = e, this.predicate = t, this.mounts = n, this.index = r, this.start = s, this.target = o, this.prev = a, this.depth = 0, this.ranges = [];
  }
}
const ef = new Se({ perNode: !0 });
class iQ {
  constructor(e, t, n, r, s) {
    this.nest = t, this.input = n, this.fragments = r, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let n = this.baseParse.advance();
      if (!n)
        return null;
      if (this.baseParse = null, this.baseTree = n, this.startInner(), this.stoppedAt != null)
        for (let r of this.inner)
          r.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let n = this.baseTree;
      return this.stoppedAt != null && (n = new He(n.type, n.children, n.positions, n.length, n.propValues.concat([[ef, this.stoppedAt]]))), n;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let n = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      n[Se.mounted.id] = new fo(t, e.overlay, e.parser), e.target.props = n;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new sQ(this.fragments), t = null, n = null, r = new Ga(new Qt(this.baseTree, this.ranges[0].from, 0, null), Ye.IncludeAnonymous | Ye.IgnoreMounts);
    e: for (let s, o; ; ) {
      let a = !0, l;
      if (this.stoppedAt != null && r.from >= this.stoppedAt)
        a = !1;
      else if (e.hasNode(r)) {
        if (t) {
          let c = t.mounts.find((h) => h.frag.from <= r.from && h.frag.to >= r.to && h.mount.overlay);
          if (c)
            for (let h of c.mount.overlay) {
              let f = h.from + c.pos, u = h.to + c.pos;
              f >= r.from && u <= r.to && !t.ranges.some((d) => d.from < u && d.to > f) && t.ranges.push({ from: f, to: u });
            }
        }
        a = !1;
      } else if (n && (o = nQ(n.ranges, r.from, r.to)))
        a = o != 2;
      else if (!r.type.isAnonymous && (s = this.nest(r, this.input)) && (r.from < r.to || !s.overlay)) {
        r.tree || (rQ(r), t && t.depth++, n && n.depth++);
        let c = e.findMounts(r.from, s.parser);
        if (typeof s.overlay == "function")
          t = new tQ(s.parser, s.overlay, c, this.inner.length, r.from, r.tree, t);
        else {
          let h = Cp(this.ranges, s.overlay || (r.from < r.to ? [new ci(r.from, r.to)] : []));
          h.length && Pp(h), (h.length || !s.overlay) && this.inner.push(new _p(s.parser, h.length ? s.parser.startParse(this.input, Ap(c, h), h) : s.parser.startParse(""), s.overlay ? s.overlay.map((f) => new ci(f.from - r.from, f.to - r.from)) : null, r.tree, h.length ? h[0].from : r.from)), s.overlay ? h.length && (n = { ranges: h, depth: 0, prev: n }) : a = !1;
        }
      } else if (t && (l = t.predicate(r)) && (l === !0 && (l = new ci(r.from, r.to)), l.from < l.to)) {
        let c = t.ranges.length - 1;
        c >= 0 && t.ranges[c].to == l.from ? t.ranges[c] = { from: t.ranges[c].from, to: l.to } : t.ranges.push(l);
      }
      if (a && r.firstChild())
        t && t.depth++, n && n.depth++;
      else
        for (; !r.nextSibling(); ) {
          if (!r.parent())
            break e;
          if (t && !--t.depth) {
            let c = Cp(this.ranges, t.ranges);
            c.length && (Pp(c), this.inner.splice(t.index, 0, new _p(t.parser, t.parser.startParse(this.input, Ap(t.mounts, c), c), t.ranges.map((h) => new ci(h.from - t.start, h.to - t.start)), t.target, c[0].from))), t = t.prev;
          }
          n && !--n.depth && (n = n.prev);
        }
    }
  }
}
function nQ(i, e, t) {
  for (let n of i) {
    if (n.from >= t)
      break;
    if (n.to > e)
      return n.from <= e && n.to >= t ? 2 : 1;
  }
  return 0;
}
function $p(i, e, t, n, r, s) {
  if (e < t) {
    let o = i.buffer[e + 1];
    n.push(i.slice(e, t, o)), r.push(o - s);
  }
}
function rQ(i) {
  let { node: e } = i, t = [], n = e.context.buffer;
  do
    t.push(i.index), i.parent();
  while (!i.tree);
  let r = i.tree, s = r.children.indexOf(n), o = r.children[s], a = o.buffer, l = [s];
  function c(h, f, u, d, p, O) {
    let m = t[O], g = [], v = [];
    $p(o, h, m, g, v, d);
    let S = a[m + 1], w = a[m + 2];
    l.push(g.length);
    let x = O ? c(m + 4, a[m + 3], o.set.types[a[m]], S, w - S, O - 1) : e.toTree();
    return g.push(x), v.push(S - d), $p(o, a[m + 3], f, g, v, d), new He(u, g, v, p);
  }
  r.children[s] = c(0, a.length, Dt.none, 0, o.length, t.length - 1);
  for (let h of l) {
    let f = i.tree.children[h], u = i.tree.positions[h];
    i.yield(new Qt(f, u + i.from, h, i._tree));
  }
}
class Tp {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor(Ye.IncludeAnonymous | Ye.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, n = e - this.offset;
    for (; !this.done && t.from < n; )
      t.to >= e && t.enter(n, 1, Ye.IgnoreOverlays | Ye.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof He)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
let sQ = class {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let n = this.curFrag = e[0];
      this.curTo = (t = n.tree.prop(ef)) !== null && t !== void 0 ? t : n.to, this.inner = new Tp(n.tree, -n.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(ef)) !== null && e !== void 0 ? e : t.to, this.inner = new Tp(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var n;
    let r = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let o = (n = s.tree) === null || n === void 0 ? void 0 : n.prop(Se.mounted);
        if (o && o.parser == t)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= s.to)
              break;
            l.tree == this.curFrag.tree && r.push({
              frag: l,
              pos: s.from - l.offset,
              mount: o
            });
          }
      }
    }
    return r;
  }
};
function Cp(i, e) {
  let t = null, n = e;
  for (let r = 1, s = 0; r < i.length; r++) {
    let o = i[r - 1].to, a = i[r].from;
    for (; s < n.length; s++) {
      let l = n[s];
      if (l.from >= a)
        break;
      l.to <= o || (t || (n = t = e.slice()), l.from < o ? (t[s] = new ci(l.from, o), l.to > a && t.splice(s + 1, 0, new ci(a, l.to))) : l.to > a ? t[s--] = new ci(a, l.to) : t.splice(s--, 1));
    }
  }
  return n;
}
function oQ(i, e, t, n) {
  let r = 0, s = 0, o = !1, a = !1, l = -1e9, c = [];
  for (; ; ) {
    let h = r == i.length ? 1e9 : o ? i[r].to : i[r].from, f = s == e.length ? 1e9 : a ? e[s].to : e[s].from;
    if (o != a) {
      let u = Math.max(l, t), d = Math.min(h, f, n);
      u < d && c.push(new ci(u, d));
    }
    if (l = Math.min(h, f), l == 1e9)
      break;
    h == l && (o ? (o = !1, r++) : o = !0), f == l && (a ? (a = !1, s++) : a = !0);
  }
  return c;
}
function Ap(i, e) {
  let t = [];
  for (let { pos: n, mount: r, frag: s } of i) {
    let o = n + (r.overlay ? r.overlay[0].from : 0), a = o + r.tree.length, l = Math.max(s.from, o), c = Math.min(s.to, a);
    if (r.overlay) {
      let h = r.overlay.map((u) => new ci(u.from + n, u.to + n)), f = oQ(e, h, l, c);
      for (let u = 0, d = l; ; u++) {
        let p = u == f.length, O = p ? c : f[u].from;
        if (O > d && t.push(new vn(d, O, r.tree, -o, s.from >= d || s.openStart, s.to <= O || s.openEnd)), p)
          break;
        d = f[u].to;
      }
    } else
      t.push(new vn(l, c, r.tree, -o, s.from >= o || s.openStart, s.to <= a || s.openEnd));
  }
  return t;
}
let aQ = 0;
class ai {
  /**
  @internal
  */
  constructor(e, t, n, r) {
    this.name = e, this.set = t, this.base = n, this.modified = r, this.id = aQ++;
  }
  toString() {
    let { name: e } = this;
    for (let t of this.modified)
      t.name && (e = `${t.name}(${e})`);
    return e;
  }
  static define(e, t) {
    let n = typeof e == "string" ? e : "?";
    if (e instanceof ai && (t = e), t?.base)
      throw new Error("Can not derive from a modified tag");
    let r = new ai(n, [], null, []);
    if (r.set.push(r), t)
      for (let s of t.set)
        r.set.push(s);
    return r;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let t = new Fa(e);
    return (n) => n.modified.indexOf(t) > -1 ? n : Fa.get(n.base || n, n.modified.concat(t).sort((r, s) => r.id - s.id));
  }
}
let lQ = 0;
class Fa {
  constructor(e) {
    this.name = e, this.instances = [], this.id = lQ++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let n = t[0].instances.find((a) => a.base == e && cQ(t, a.modified));
    if (n)
      return n;
    let r = [], s = new ai(e.name, r, e, t);
    for (let a of t)
      a.instances.push(s);
    let o = hQ(t);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of o)
          r.push(Fa.get(a, l));
    return s;
  }
}
function cQ(i, e) {
  return i.length == e.length && i.every((t, n) => t == e[n]);
}
function hQ(i) {
  let e = [[]];
  for (let t = 0; t < i.length; t++)
    for (let n = 0, r = e.length; n < r; n++)
      e.push(e[n].concat(i[t]));
  return e.sort((t, n) => n.length - t.length);
}
function El(i) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in i) {
    let n = i[t];
    Array.isArray(n) || (n = [n]);
    for (let r of t.split(" "))
      if (r) {
        let s = [], o = 2, a = r;
        for (let f = 0; ; ) {
          if (a == "..." && f > 0 && f + 3 == r.length) {
            o = 1;
            break;
          }
          let u = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!u)
            throw new RangeError("Invalid path: " + r);
          if (s.push(u[0] == "*" ? "" : u[0][0] == '"' ? JSON.parse(u[0]) : u[0]), f += u[0].length, f == r.length)
            break;
          let d = r[f++];
          if (f == r.length && d == "!") {
            o = 0;
            break;
          }
          if (d != "/")
            throw new RangeError("Invalid path: " + r);
          a = r.slice(f);
        }
        let l = s.length - 1, c = s[l];
        if (!c)
          throw new RangeError("Invalid path: " + r);
        let h = new po(n, o, l > 0 ? s.slice(0, l) : null);
        e[c] = h.sort(e[c]);
      }
  }
  return j0.add(e);
}
const j0 = new Se({
  combine(i, e) {
    let t, n, r;
    for (; i || e; ) {
      if (!i || e && i.depth >= e.depth ? (r = e, e = e.next) : (r = i, i = i.next), t && t.mode == r.mode && !r.context && !t.context)
        continue;
      let s = new po(r.tags, r.mode, r.context);
      t ? t.next = s : n = s, t = s;
    }
    return n;
  }
});
class po {
  constructor(e, t, n, r) {
    this.tags = e, this.mode = t, this.context = n, this.next = r;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
po.empty = new po([], 2, null);
function U0(i, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let s of i)
    if (!Array.isArray(s.tag))
      t[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        t[o.id] = s.class;
  let { scope: n, all: r = null } = e || {};
  return {
    style: (s) => {
      let o = r;
      for (let a of s)
        for (let l of a.set) {
          let c = t[l.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: n
  };
}
function fQ(i, e) {
  let t = null;
  for (let n of i) {
    let r = n.style(e);
    r && (t = t ? t + " " + r : r);
  }
  return t;
}
function uQ(i, e, t, n = 0, r = i.length) {
  let s = new dQ(n, Array.isArray(e) ? e : [e], t);
  s.highlightRange(i.cursor(), n, r, "", s.highlighters), s.flush(r);
}
class dQ {
  constructor(e, t, n) {
    this.at = e, this.highlighters = t, this.span = n, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, n, r, s) {
    let { type: o, from: a, to: l } = e;
    if (a >= n || l <= t)
      return;
    o.isTop && (s = this.highlighters.filter((d) => !d.scope || d.scope(o)));
    let c = r, h = pQ(e) || po.empty, f = fQ(s, h.tags);
    if (f && (c && (c += " "), c += f, h.mode == 1 && (r += (r ? " " : "") + f)), this.startSpan(Math.max(t, a), c), h.opaque)
      return;
    let u = e.tree && e.tree.prop(Se.mounted);
    if (u && u.overlay) {
      let d = e.node.enter(u.overlay[0].from + a, 1), p = this.highlighters.filter((m) => !m.scope || m.scope(u.tree.type)), O = e.firstChild();
      for (let m = 0, g = a; ; m++) {
        let v = m < u.overlay.length ? u.overlay[m] : null, S = v ? v.from + a : l, w = Math.max(t, g), x = Math.min(n, S);
        if (w < x && O)
          for (; e.from < x && (this.highlightRange(e, w, x, r, s), this.startSpan(Math.min(x, e.to), c), !(e.to >= S || !e.nextSibling())); )
            ;
        if (!v || S > n)
          break;
        g = v.to + a, g > t && (this.highlightRange(d.cursor(), Math.max(t, v.from + a), Math.min(n, g), "", p), this.startSpan(Math.min(n, g), c));
      }
      O && e.parent();
    } else if (e.firstChild()) {
      u && (r = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= n)
            break;
          this.highlightRange(e, t, n, r, s), this.startSpan(Math.min(n, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function pQ(i) {
  let e = i.type.prop(j0);
  for (; e && e.context && !i.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const ne = ai.define, ra = ne(), $n = ne(), Rp = ne($n), Ep = ne($n), Tn = ne(), sa = ne(Tn), wc = ne(Tn), Zi = ne(), Jn = ne(Zi), Ei = ne(), Mi = ne(), tf = ne(), Ms = ne(tf), oa = ne(), T = {
  /**
  A comment.
  */
  comment: ra,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: ne(ra),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: ne(ra),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: ne(ra),
  /**
  Any kind of identifier.
  */
  name: $n,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: ne($n),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: Rp,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: ne(Rp),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: Ep,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: ne(Ep),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: ne($n),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: ne($n),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: ne($n),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: ne($n),
  /**
  A literal value.
  */
  literal: Tn,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: sa,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: ne(sa),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: ne(sa),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: ne(sa),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: wc,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: ne(wc),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: ne(wc),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: ne(Tn),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: ne(Tn),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: ne(Tn),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: ne(Tn),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: ne(Tn),
  /**
  A language keyword.
  */
  keyword: Ei,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: ne(Ei),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: ne(Ei),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: ne(Ei),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: ne(Ei),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: ne(Ei),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: ne(Ei),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: ne(Ei),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: ne(Ei),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: ne(Ei),
  /**
  An operator.
  */
  operator: Mi,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: ne(Mi),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: ne(Mi),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: ne(Mi),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: ne(Mi),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: ne(Mi),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: ne(Mi),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: ne(Mi),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: ne(Mi),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: ne(Mi),
  /**
  Program or markup punctuation.
  */
  punctuation: tf,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: ne(tf),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Ms,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: ne(Ms),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: ne(Ms),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: ne(Ms),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: ne(Ms),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Zi,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Jn,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: ne(Jn),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: ne(Jn),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: ne(Jn),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: ne(Jn),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: ne(Jn),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: ne(Jn),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: ne(Zi),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: ne(Zi),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: ne(Zi),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: ne(Zi),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: ne(Zi),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: ne(Zi),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: ne(Zi),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: ne(Zi),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: ne(),
  /**
  Deleted text.
  */
  deleted: ne(),
  /**
  Changed text.
  */
  changed: ne(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: ne(),
  /**
  Metadata or meta-instruction.
  */
  meta: oa,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: ne(oa),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: ne(oa),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: ne(oa),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: ai.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: ai.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: ai.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: ai.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: ai.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: ai.defineModifier("special")
};
for (let i in T) {
  let e = T[i];
  e instanceof ai && (e.name = i);
}
U0([
  { tag: T.link, class: "tok-link" },
  { tag: T.heading, class: "tok-heading" },
  { tag: T.emphasis, class: "tok-emphasis" },
  { tag: T.strong, class: "tok-strong" },
  { tag: T.keyword, class: "tok-keyword" },
  { tag: T.atom, class: "tok-atom" },
  { tag: T.bool, class: "tok-bool" },
  { tag: T.url, class: "tok-url" },
  { tag: T.labelName, class: "tok-labelName" },
  { tag: T.inserted, class: "tok-inserted" },
  { tag: T.deleted, class: "tok-deleted" },
  { tag: T.literal, class: "tok-literal" },
  { tag: T.string, class: "tok-string" },
  { tag: T.number, class: "tok-number" },
  { tag: [T.regexp, T.escape, T.special(T.string)], class: "tok-string2" },
  { tag: T.variableName, class: "tok-variableName" },
  { tag: T.local(T.variableName), class: "tok-variableName tok-local" },
  { tag: T.definition(T.variableName), class: "tok-variableName tok-definition" },
  { tag: T.special(T.variableName), class: "tok-variableName2" },
  { tag: T.definition(T.propertyName), class: "tok-propertyName tok-definition" },
  { tag: T.typeName, class: "tok-typeName" },
  { tag: T.namespace, class: "tok-namespace" },
  { tag: T.className, class: "tok-className" },
  { tag: T.macroName, class: "tok-macroName" },
  { tag: T.propertyName, class: "tok-propertyName" },
  { tag: T.operator, class: "tok-operator" },
  { tag: T.comment, class: "tok-comment" },
  { tag: T.meta, class: "tok-meta" },
  { tag: T.invalid, class: "tok-invalid" },
  { tag: T.punctuation, class: "tok-punctuation" }
]);
var xc;
const zr = /* @__PURE__ */ new Se();
function G0(i) {
  return le.define({
    combine: i ? (e) => e.concat(i) : void 0
  });
}
const nu = /* @__PURE__ */ new Se();
class vi {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, n = [], r = "") {
    this.data = e, this.name = r, $e.prototype.hasOwnProperty("tree") || Object.defineProperty($e.prototype, "tree", { get() {
      return Ke(this);
    } }), this.parser = t, this.extension = [
      Vn.of(this),
      $e.languageData.of((s, o, a) => {
        let l = Mp(s, o, a), c = l.type.prop(zr);
        if (!c)
          return [];
        let h = s.facet(c), f = l.type.prop(nu);
        if (f) {
          let u = l.resolve(o - l.from, a);
          for (let d of f)
            if (d.test(u, s)) {
              let p = s.facet(d.facet);
              return d.type == "replace" ? p : p.concat(h);
            }
        }
        return h;
      })
    ].concat(n);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, n = -1) {
    return Mp(e, t, n).type.prop(zr) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(Vn);
    if (t?.data == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let n = [], r = (s, o) => {
      if (s.prop(zr) == this.data) {
        n.push({ from: o, to: o + s.length });
        return;
      }
      let a = s.prop(Se.mounted);
      if (a) {
        if (a.tree.prop(zr) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              n.push({ from: l.from + o, to: l.to + o });
          else
            n.push({ from: o, to: o + s.length });
          return;
        } else if (a.overlay) {
          let l = n.length;
          if (r(a.tree, a.overlay[0].from + o), n.length > l)
            return;
        }
      }
      for (let l = 0; l < s.children.length; l++) {
        let c = s.children[l];
        c instanceof He && r(c, s.positions[l] + o);
      }
    };
    return r(Ke(e), 0), n;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
vi.setState = /* @__PURE__ */ ge.define();
function Mp(i, e, t) {
  let n = i.facet(Vn), r = Ke(i).topNode;
  if (!n || n.allowsNesting)
    for (let s = r; s; s = s.enter(e, t, Ye.ExcludeBuffers))
      s.type.isTop && (r = s);
  return r;
}
class ts extends vi {
  constructor(e, t, n) {
    super(e, t, [], n), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = G0(e.languageData);
    return new ts(t, e.parser.configure({
      props: [zr.add((n) => n.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new ts(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Ke(i) {
  let e = i.field(vi.state, !1);
  return e ? e.tree : He.empty;
}
class OQ {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let n = this.cursorPos - this.string.length;
    return e < n || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - n, t - n);
  }
}
let Zs = null;
class Ha {
  constructor(e, t, n = [], r, s, o, a, l) {
    this.parser = e, this.state = t, this.fragments = n, this.tree = r, this.treeLen = s, this.viewport = o, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, n) {
    return new Ha(e, t, [], He.empty, 0, n, [], null);
  }
  startParse() {
    return this.parser.startParse(new OQ(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != He.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var n;
      if (typeof e == "number") {
        let r = Date.now() + e;
        e = () => Date.now() > r;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let r = this.parse.advance();
        if (r)
          if (this.fragments = this.withoutTempSkipped(vn.addTree(r, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (n = this.parse.stoppedAt) !== null && n !== void 0 ? n : this.state.doc.length, this.tree = r, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(vn.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = Zs;
    Zs = this;
    try {
      return e();
    } finally {
      Zs = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = Zp(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: n, tree: r, treeLen: s, viewport: o, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((c, h, f, u) => l.push({ fromA: c, toA: h, fromB: f, toB: u })), n = vn.applyChanges(n, l), r = He.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        a = [];
        for (let c of this.skipped) {
          let h = e.mapPos(c.from, 1), f = e.mapPos(c.to, -1);
          h < f && a.push({ from: h, to: f });
        }
      }
    }
    return new Ha(this.parser, t, n, r, s, o, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let n = 0; n < this.skipped.length; n++) {
      let { from: r, to: s } = this.skipped[n];
      r < e.to && s > e.from && (this.fragments = Zp(this.fragments, r, s), this.skipped.splice(n--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends W0 {
      createParse(t, n, r) {
        let s = r[0].from, o = r[r.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let l = Zs;
            if (l) {
              for (let c of r)
                l.tempSkipped.push(c);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new He(Dt.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Zs;
  }
}
function Zp(i, e, t) {
  return vn.applyChanges(i, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class is {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), n = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, n) || t.takeTree(), new is(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), n = Ha.create(e.facet(Vn).parser, e, { from: 0, to: t });
    return n.work(20, t) || n.takeTree(), new is(n);
  }
}
vi.state = /* @__PURE__ */ ft.define({
  create: is.init,
  update(i, e) {
    for (let t of e.effects)
      if (t.is(vi.setState))
        return t.value;
    return e.startState.facet(Vn) != e.state.facet(Vn) ? is.init(e.state) : i.apply(e);
  }
});
let F0 = (i) => {
  let e = setTimeout(
    () => i(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (F0 = (i) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(i, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const kc = typeof navigator < "u" && (!((xc = navigator.scheduling) === null || xc === void 0) && xc.isInputPending) ? () => navigator.scheduling.isInputPending() : null, mQ = /* @__PURE__ */ ot.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(vi.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(vi.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = F0(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: n, viewport: { to: r } } = this.view, s = n.field(vi.state);
    if (s.tree == s.context.tree && s.context.isDone(
      r + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !kc ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = s.context.treeLen < r && n.doc.length > r + 1e3, l = s.context.work(() => kc && kc() || Date.now() > o, r + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (l || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: vi.setState.of(new is(s.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => Wt(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Vn = /* @__PURE__ */ le.define({
  combine(i) {
    return i.length ? i[0] : null;
  },
  enables: (i) => [
    vi.state,
    mQ,
    ae.contentAttributes.compute([i], (e) => {
      let t = e.facet(i);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class ru {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
const gQ = /* @__PURE__ */ le.define(), Ml = /* @__PURE__ */ le.define({
  combine: (i) => {
    if (!i.length)
      return "  ";
    let e = i[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(i[0]));
    return e;
  }
});
function Ka(i) {
  let e = i.facet(Ml);
  return e.charCodeAt(0) == 9 ? i.tabSize * e.length : e.length;
}
function Oo(i, e) {
  let t = "", n = i.tabSize, r = i.facet(Ml)[0];
  if (r == "	") {
    for (; e >= n; )
      t += "	", e -= n;
    r = " ";
  }
  for (let s = 0; s < e; s++)
    t += r;
  return t;
}
function su(i, e) {
  i instanceof $e && (i = new Zl(i));
  for (let n of i.state.facet(gQ)) {
    let r = n(i, e);
    if (r !== void 0)
      return r;
  }
  let t = Ke(i.state);
  return t.length >= e ? bQ(i, t, e) : null;
}
class Zl {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = Ka(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let n = this.state.doc.lineAt(e), { simulateBreak: r, simulateDoubleBreak: s } = this.options;
    return r != null && r >= n.from && r <= n.to ? s && r == e ? { text: "", from: e } : (t < 0 ? r < e : r <= e) ? { text: n.text.slice(r - n.from), from: r } : { text: n.text.slice(0, r - n.from), from: n.from } : n;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: n, from: r } = this.lineAt(e, t);
    return n.slice(e - r, Math.min(n.length, e + 100 - r));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: n, from: r } = this.lineAt(e, t), s = this.countColumn(n, e - r), o = this.options.overrideIndentation ? this.options.overrideIndentation(r) : -1;
    return o > -1 && (s += o - this.countColumn(n, n.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return ms(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: n, from: r } = this.lineAt(e, t), s = this.options.overrideIndentation;
    if (s) {
      let o = s(r);
      if (o > -1)
        return o;
    }
    return this.countColumn(n, n.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Xl = /* @__PURE__ */ new Se();
function bQ(i, e, t) {
  let n = e.resolveStack(t), r = e.resolveInner(t, -1).resolve(t, 0).enterUnfinishedNodesBefore(t);
  if (r != n.node) {
    let s = [];
    for (let o = r; o && !(o.from < n.node.from || o.to > n.node.to || o.from == n.node.from && o.type == n.node.type); o = o.parent)
      s.push(o);
    for (let o = s.length - 1; o >= 0; o--)
      n = { node: s[o], next: n };
  }
  return H0(n, i, t);
}
function H0(i, e, t) {
  for (let n = i; n; n = n.next) {
    let r = vQ(n.node);
    if (r)
      return r(ou.create(e, t, n));
  }
  return 0;
}
function yQ(i) {
  return i.pos == i.options.simulateBreak && i.options.simulateDoubleBreak;
}
function vQ(i) {
  let e = i.type.prop(Xl);
  if (e)
    return e;
  let t = i.firstChild, n;
  if (t && (n = t.type.prop(Se.closedBy))) {
    let r = i.lastChild, s = r && n.indexOf(r.name) > -1;
    return (o) => K0(o, !0, 1, void 0, s && !yQ(o) ? r.from : void 0);
  }
  return i.parent == null ? SQ : null;
}
function SQ() {
  return 0;
}
class ou extends Zl {
  constructor(e, t, n) {
    super(e.state, e.options), this.base = e, this.pos = t, this.context = n;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, t, n) {
    return new ou(e, t, n);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let n = e.resolve(t.from);
      for (; n.parent && n.parent.from == n.from; )
        n = n.parent;
      if (wQ(n, e))
        break;
      t = this.state.doc.lineAt(n.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return H0(this.context.next, this.base, this.pos);
  }
}
function wQ(i, e) {
  for (let t = e; t; t = t.parent)
    if (i == t)
      return !0;
  return !1;
}
function xQ(i) {
  let e = i.node, t = e.childAfter(e.from), n = e.lastChild;
  if (!t)
    return null;
  let r = i.options.simulateBreak, s = i.state.doc.lineAt(t.from), o = r == null || r <= s.from ? s.to : Math.min(s.to, r);
  for (let a = t.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == n)
      return null;
    if (!l.type.isSkipped) {
      if (l.from >= o)
        return null;
      let c = /^ */.exec(s.text.slice(t.to - s.from))[0].length;
      return { from: t.from, to: t.to + c };
    }
    a = l.to;
  }
}
function kQ({ closing: i, align: e = !0, units: t = 1 }) {
  return (n) => K0(n, e, t, i);
}
function K0(i, e, t, n, r) {
  let s = i.textAfter, o = s.match(/^\s*/)[0].length, a = n && s.slice(o, o + n.length) == n || r == i.pos + o, l = e ? xQ(i) : null;
  return l ? a ? i.column(l.from) : i.column(l.to) : i.baseIndent + (a ? 0 : i.unit * t);
}
const QQ = (i) => i.baseIndent;
function Ca({ except: i, units: e = 1 } = {}) {
  return (t) => {
    let n = i && i.test(t.textAfter);
    return t.baseIndent + (n ? 0 : e * t.unit);
  };
}
const _Q = 200;
function PQ() {
  return $e.transactionFilter.of((i) => {
    if (!i.docChanged || !i.isUserEvent("input.type") && !i.isUserEvent("input.complete"))
      return i;
    let e = i.startState.languageDataAt("indentOnInput", i.startState.selection.main.head);
    if (!e.length)
      return i;
    let t = i.newDoc, { head: n } = i.newSelection.main, r = t.lineAt(n);
    if (n > r.from + _Q)
      return i;
    let s = t.sliceString(r.from, n);
    if (!e.some((c) => c.test(s)))
      return i;
    let { state: o } = i, a = -1, l = [];
    for (let { head: c } of o.selection.ranges) {
      let h = o.doc.lineAt(c);
      if (h.from == a)
        continue;
      a = h.from;
      let f = su(o, h.from);
      if (f == null)
        continue;
      let u = /^\s*/.exec(h.text)[0], d = Oo(o, f);
      u != d && l.push({ from: h.from, to: h.from + u.length, insert: d });
    }
    return l.length ? [i, { changes: l, sequential: !0 }] : i;
  });
}
const $Q = /* @__PURE__ */ le.define(), zl = /* @__PURE__ */ new Se();
function J0(i) {
  let e = i.firstChild, t = i.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? i.to : t.from } : null;
}
function TQ(i, e, t) {
  let n = Ke(i);
  if (n.length < t)
    return null;
  let r = n.resolveStack(t, 1), s = null;
  for (let o = r; o; o = o.next) {
    let a = o.node;
    if (a.to <= t || a.from > t)
      continue;
    if (s && a.from < e)
      break;
    let l = a.type.prop(zl);
    if (l && (a.to < n.length - 50 || n.length == i.doc.length || !CQ(a))) {
      let c = l(a, i);
      c && c.from <= t && c.from >= e && c.to > t && (s = c);
    }
  }
  return s;
}
function CQ(i) {
  let e = i.lastChild;
  return e && e.to == i.to && e.type.isError;
}
function Ja(i, e, t) {
  for (let n of i.facet($Q)) {
    let r = n(i, e, t);
    if (r)
      return r;
  }
  return TQ(i, e, t);
}
function e1(i, e) {
  let t = e.mapPos(i.from, 1), n = e.mapPos(i.to, -1);
  return t >= n ? void 0 : { from: t, to: n };
}
const Dl = /* @__PURE__ */ ge.define({ map: e1 }), Ro = /* @__PURE__ */ ge.define({ map: e1 });
function t1(i) {
  let e = [];
  for (let { head: t } of i.state.selection.ranges)
    e.some((n) => n.from <= t && n.to >= t) || e.push(i.lineBlockAt(t));
  return e;
}
const yr = /* @__PURE__ */ ft.define({
  create() {
    return pe.none;
  },
  update(i, e) {
    e.isUserEvent("delete") && e.changes.iterChangedRanges((t, n) => i = Xp(i, t, n)), i = i.map(e.changes);
    for (let t of e.effects)
      if (t.is(Dl) && !AQ(i, t.value.from, t.value.to)) {
        let { preparePlaceholder: n } = e.state.facet(r1), r = n ? pe.replace({ widget: new DQ(n(e.state, t.value)) }) : zp;
        i = i.update({ add: [r.range(t.value.from, t.value.to)] });
      } else t.is(Ro) && (i = i.update({
        filter: (n, r) => t.value.from != n || t.value.to != r,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    return e.selection && (i = Xp(i, e.selection.main.head)), i;
  },
  provide: (i) => ae.decorations.from(i),
  toJSON(i, e) {
    let t = [];
    return i.between(0, e.doc.length, (n, r) => {
      t.push(n, r);
    }), t;
  },
  fromJSON(i) {
    if (!Array.isArray(i) || i.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < i.length; ) {
      let n = i[t++], r = i[t++];
      if (typeof n != "number" || typeof r != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(zp.range(n, r));
    }
    return pe.set(e, !0);
  }
});
function Xp(i, e, t = e) {
  let n = !1;
  return i.between(e, t, (r, s) => {
    r < t && s > e && (n = !0);
  }), n ? i.update({
    filterFrom: e,
    filterTo: t,
    filter: (r, s) => r >= t || s <= e
  }) : i;
}
function el(i, e, t) {
  var n;
  let r = null;
  return (n = i.field(yr, !1)) === null || n === void 0 || n.between(e, t, (s, o) => {
    (!r || r.from > s) && (r = { from: s, to: o });
  }), r;
}
function AQ(i, e, t) {
  let n = !1;
  return i.between(e, e, (r, s) => {
    r == e && s == t && (n = !0);
  }), n;
}
function i1(i, e) {
  return i.field(yr, !1) ? e : e.concat(ge.appendConfig.of(s1()));
}
const RQ = (i) => {
  for (let e of t1(i)) {
    let t = Ja(i.state, e.from, e.to);
    if (t)
      return i.dispatch({ effects: i1(i.state, [Dl.of(t), n1(i, t)]) }), !0;
  }
  return !1;
}, EQ = (i) => {
  if (!i.state.field(yr, !1))
    return !1;
  let e = [];
  for (let t of t1(i)) {
    let n = el(i.state, t.from, t.to);
    n && e.push(Ro.of(n), n1(i, n, !1));
  }
  return e.length && i.dispatch({ effects: e }), e.length > 0;
};
function n1(i, e, t = !0) {
  let n = i.state.doc.lineAt(e.from).number, r = i.state.doc.lineAt(e.to).number;
  return ae.announce.of(`${i.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${n} ${i.state.phrase("to")} ${r}.`);
}
const MQ = (i) => {
  let { state: e } = i, t = [];
  for (let n = 0; n < e.doc.length; ) {
    let r = i.lineBlockAt(n), s = Ja(e, r.from, r.to);
    s && t.push(Dl.of(s)), n = (s ? i.lineBlockAt(s.to) : r).to + 1;
  }
  return t.length && i.dispatch({ effects: i1(i.state, t) }), !!t.length;
}, ZQ = (i) => {
  let e = i.state.field(yr, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, i.state.doc.length, (n, r) => {
    t.push(Ro.of({ from: n, to: r }));
  }), i.dispatch({ effects: t }), !0;
}, XQ = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: RQ },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: EQ },
  { key: "Ctrl-Alt-[", run: MQ },
  { key: "Ctrl-Alt-]", run: ZQ }
], zQ = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "â€¦"
}, r1 = /* @__PURE__ */ le.define({
  combine(i) {
    return sn(i, zQ);
  }
});
function s1(i) {
  return [yr, BQ];
}
function o1(i, e) {
  let { state: t } = i, n = t.facet(r1), r = (o) => {
    let a = i.lineBlockAt(i.posAtDOM(o.target)), l = el(i.state, a.from, a.to);
    l && i.dispatch({ effects: Ro.of(l) }), o.preventDefault();
  };
  if (n.placeholderDOM)
    return n.placeholderDOM(i, r, e);
  let s = document.createElement("span");
  return s.textContent = n.placeholderText, s.setAttribute("aria-label", t.phrase("folded code")), s.title = t.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = r, s;
}
const zp = /* @__PURE__ */ pe.replace({ widget: /* @__PURE__ */ new class extends Pn {
  toDOM(i) {
    return o1(i, null);
  }
}() });
class DQ extends Pn {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return o1(e, this.value);
  }
}
const LQ = {
  openText: "âŒ„",
  closedText: "â€º",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class Qc extends kn {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function IQ(i = {}) {
  let e = { ...LQ, ...i }, t = new Qc(e, !0), n = new Qc(e, !1), r = ot.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(Vn) != o.state.facet(Vn) || o.startState.field(yr, !1) != o.state.field(yr, !1) || Ke(o.startState) != Ke(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let a = new wn();
      for (let l of o.viewportLineBlocks) {
        let c = el(o.state, l.from, l.to) ? n : Ja(o.state, l.from, l.to) ? t : null;
        c && a.add(l.from, l.from, c);
      }
      return a.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    r,
    Xk({
      class: "cm-foldGutter",
      markers(o) {
        var a;
        return ((a = o.plugin(r)) === null || a === void 0 ? void 0 : a.markers) || Te.empty;
      },
      initialSpacer() {
        return new Qc(e, !1);
      },
      domEventHandlers: {
        ...s,
        click: (o, a, l) => {
          if (s.click && s.click(o, a, l))
            return !0;
          let c = el(o.state, a.from, a.to);
          if (c)
            return o.dispatch({ effects: Ro.of(c) }), !0;
          let h = Ja(o.state, a.from, a.to);
          return h ? (o.dispatch({ effects: Dl.of(h) }), !0) : !1;
        }
      }
    }),
    s1()
  ];
}
const BQ = /* @__PURE__ */ ae.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Eo {
  constructor(e, t) {
    this.specs = e;
    let n;
    function r(a) {
      let l = In.newName();
      return (n || (n = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const s = typeof t.all == "string" ? t.all : t.all ? r(t.all) : void 0, o = t.scope;
    this.scope = o instanceof vi ? (a) => a.prop(zr) == o.data : o ? (a) => a == o : void 0, this.style = U0(e.map((a) => ({
      tag: a.tag,
      class: a.class || r(Object.assign({}, a, { tag: null }))
    })), {
      all: s
    }).style, this.module = n ? new In(n) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new Eo(e, t || {});
  }
}
const nf = /* @__PURE__ */ le.define(), a1 = /* @__PURE__ */ le.define({
  combine(i) {
    return i.length ? [i[0]] : null;
  }
});
function _c(i) {
  let e = i.facet(nf);
  return e.length ? e : i.facet(a1);
}
function au(i, e) {
  let t = [NQ], n;
  return i instanceof Eo && (i.module && t.push(ae.styleModule.of(i.module)), n = i.themeType), e?.fallback ? t.push(a1.of(i)) : n ? t.push(nf.computeN([ae.darkTheme], (r) => r.facet(ae.darkTheme) == (n == "dark") ? [i] : [])) : t.push(nf.of(i)), t;
}
class YQ {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Ke(e.state), this.decorations = this.buildDeco(e, _c(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let t = Ke(e.state), n = _c(e.state), r = n != _c(e.startState), { viewport: s } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);
    t.length < s.to && !r && t.type == this.tree.type && o >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (t != this.tree || e.viewportChanged || r) && (this.tree = t, this.decorations = this.buildDeco(e.view, n), this.decoratedTo = s.to);
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return pe.none;
    let n = new wn();
    for (let { from: r, to: s } of e.visibleRanges)
      uQ(this.tree, t, (o, a, l) => {
        n.add(o, a, this.markCache[l] || (this.markCache[l] = pe.mark({ class: l })));
      }, r, s);
    return n.finish();
  }
}
const NQ = /* @__PURE__ */ Wn.high(/* @__PURE__ */ ot.fromClass(YQ, {
  decorations: (i) => i.decorations
})), l1 = /* @__PURE__ */ Eo.define([
  {
    tag: T.meta,
    color: "#404740"
  },
  {
    tag: T.link,
    textDecoration: "underline"
  },
  {
    tag: T.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: T.emphasis,
    fontStyle: "italic"
  },
  {
    tag: T.strong,
    fontWeight: "bold"
  },
  {
    tag: T.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: T.keyword,
    color: "#708"
  },
  {
    tag: [T.atom, T.bool, T.url, T.contentSeparator, T.labelName],
    color: "#219"
  },
  {
    tag: [T.literal, T.inserted],
    color: "#164"
  },
  {
    tag: [T.string, T.deleted],
    color: "#a11"
  },
  {
    tag: [T.regexp, T.escape, /* @__PURE__ */ T.special(T.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ T.definition(T.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ T.local(T.variableName),
    color: "#30a"
  },
  {
    tag: [T.typeName, T.namespace],
    color: "#085"
  },
  {
    tag: T.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ T.special(T.variableName), T.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ T.definition(T.propertyName),
    color: "#00c"
  },
  {
    tag: T.comment,
    color: "#940"
  },
  {
    tag: T.invalid,
    color: "#f00"
  }
]), VQ = /* @__PURE__ */ ae.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), c1 = 1e4, h1 = "()[]{}", f1 = /* @__PURE__ */ le.define({
  combine(i) {
    return sn(i, {
      afterCursor: !0,
      brackets: h1,
      maxScanDistance: c1,
      renderMatch: jQ
    });
  }
}), qQ = /* @__PURE__ */ pe.mark({ class: "cm-matchingBracket" }), WQ = /* @__PURE__ */ pe.mark({ class: "cm-nonmatchingBracket" });
function jQ(i) {
  let e = [], t = i.matched ? qQ : WQ;
  return e.push(t.range(i.start.from, i.start.to)), i.end && e.push(t.range(i.end.from, i.end.to)), e;
}
const UQ = /* @__PURE__ */ ft.define({
  create() {
    return pe.none;
  },
  update(i, e) {
    if (!e.docChanged && !e.selection)
      return i;
    let t = [], n = e.state.facet(f1);
    for (let r of e.state.selection.ranges) {
      if (!r.empty)
        continue;
      let s = ji(e.state, r.head, -1, n) || r.head > 0 && ji(e.state, r.head - 1, 1, n) || n.afterCursor && (ji(e.state, r.head, 1, n) || r.head < e.state.doc.length && ji(e.state, r.head + 1, -1, n));
      s && (t = t.concat(n.renderMatch(s, e.state)));
    }
    return pe.set(t, !0);
  },
  provide: (i) => ae.decorations.from(i)
}), GQ = [
  UQ,
  VQ
];
function FQ(i = {}) {
  return [f1.of(i), GQ];
}
const u1 = /* @__PURE__ */ new Se();
function rf(i, e, t) {
  let n = i.prop(e < 0 ? Se.openedBy : Se.closedBy);
  if (n)
    return n;
  if (i.name.length == 1) {
    let r = t.indexOf(i.name);
    if (r > -1 && r % 2 == (e < 0 ? 1 : 0))
      return [t[r + e]];
  }
  return null;
}
function sf(i) {
  let e = i.type.prop(u1);
  return e ? e(i.node) : i;
}
function ji(i, e, t, n = {}) {
  let r = n.maxScanDistance || c1, s = n.brackets || h1, o = Ke(i), a = o.resolveInner(e, t);
  for (let l = a; l; l = l.parent) {
    let c = rf(l.type, t, s);
    if (c && l.from < l.to) {
      let h = sf(l);
      if (h && (t > 0 ? e >= h.from && e < h.to : e > h.from && e <= h.to))
        return HQ(i, e, t, l, h, c, s);
    }
  }
  return KQ(i, e, t, o, a.type, r, s);
}
function HQ(i, e, t, n, r, s, o) {
  let a = n.parent, l = { from: r.from, to: r.to }, c = 0, h = a?.cursor();
  if (h && (t < 0 ? h.childBefore(n.from) : h.childAfter(n.to)))
    do
      if (t < 0 ? h.to <= n.from : h.from >= n.to) {
        if (c == 0 && s.indexOf(h.type.name) > -1 && h.from < h.to) {
          let f = sf(h);
          return { start: l, end: f ? { from: f.from, to: f.to } : void 0, matched: !0 };
        } else if (rf(h.type, t, o))
          c++;
        else if (rf(h.type, -t, o)) {
          if (c == 0) {
            let f = sf(h);
            return {
              start: l,
              end: f && f.from < f.to ? { from: f.from, to: f.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (t < 0 ? h.prevSibling() : h.nextSibling());
  return { start: l, matched: !1 };
}
function KQ(i, e, t, n, r, s, o) {
  let a = t < 0 ? i.sliceDoc(e - 1, e) : i.sliceDoc(e, e + 1), l = o.indexOf(a);
  if (l < 0 || l % 2 == 0 != t > 0)
    return null;
  let c = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, h = i.doc.iterRange(e, t > 0 ? i.doc.length : 0), f = 0;
  for (let u = 0; !h.next().done && u <= s; ) {
    let d = h.value;
    t < 0 && (u += d.length);
    let p = e + u * t;
    for (let O = t > 0 ? 0 : d.length - 1, m = t > 0 ? d.length : -1; O != m; O += t) {
      let g = o.indexOf(d[O]);
      if (!(g < 0 || n.resolveInner(p + O, 1).type != r))
        if (g % 2 == 0 == t > 0)
          f++;
        else {
          if (f == 1)
            return { start: c, end: { from: p + O, to: p + O + 1 }, matched: g >> 1 == l >> 1 };
          f--;
        }
    }
    t > 0 && (u += d.length);
  }
  return h.done ? { start: c, matched: !1 } : null;
}
const JQ = /* @__PURE__ */ Object.create(null), Dp = [Dt.none], Lp = [], Ip = /* @__PURE__ */ Object.create(null), e2 = /* @__PURE__ */ Object.create(null);
for (let [i, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  e2[i] = /* @__PURE__ */ t2(JQ, e);
function Pc(i, e) {
  Lp.indexOf(i) > -1 || (Lp.push(i), console.warn(e));
}
function t2(i, e) {
  let t = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let c of a.split(".")) {
      let h = i[c] || T[c];
      h ? typeof h == "function" ? l.length ? l = l.map(h) : Pc(c, `Modifier ${c} used at start of tag`) : l.length ? Pc(c, `Tag ${c} used as modifier`) : l = Array.isArray(h) ? h : [h] : Pc(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of l)
      t.push(c);
  }
  if (!t.length)
    return 0;
  let n = e.replace(/ /g, "_"), r = n + " " + t.map((a) => a.id), s = Ip[r];
  if (s)
    return s.id;
  let o = Ip[r] = Dt.define({
    id: Dp.length,
    name: n,
    props: [El({ [n]: t })]
  });
  return Dp.push(o), o.id;
}
We.RTL, We.LTR;
const i2 = (i) => {
  let { state: e } = i, t = e.doc.lineAt(e.selection.main.from), n = cu(i.state, t.from);
  return n.line ? n2(i) : n.block ? s2(i) : !1;
};
function lu(i, e) {
  return ({ state: t, dispatch: n }) => {
    if (t.readOnly)
      return !1;
    let r = i(e, t);
    return r ? (n(t.update(r)), !0) : !1;
  };
}
const n2 = /* @__PURE__ */ lu(
  l2,
  0
  /* CommentOption.Toggle */
), r2 = /* @__PURE__ */ lu(
  d1,
  0
  /* CommentOption.Toggle */
), s2 = /* @__PURE__ */ lu(
  (i, e) => d1(i, e, a2(e)),
  0
  /* CommentOption.Toggle */
);
function cu(i, e) {
  let t = i.languageDataAt("commentTokens", e, 1);
  return t.length ? t[0] : {};
}
const Xs = 50;
function o2(i, { open: e, close: t }, n, r) {
  let s = i.sliceDoc(n - Xs, n), o = i.sliceDoc(r, r + Xs), a = /\s*$/.exec(s)[0].length, l = /^\s*/.exec(o)[0].length, c = s.length - a;
  if (s.slice(c - e.length, c) == e && o.slice(l, l + t.length) == t)
    return {
      open: { pos: n - a, margin: a && 1 },
      close: { pos: r + l, margin: l && 1 }
    };
  let h, f;
  r - n <= 2 * Xs ? h = f = i.sliceDoc(n, r) : (h = i.sliceDoc(n, n + Xs), f = i.sliceDoc(r - Xs, r));
  let u = /^\s*/.exec(h)[0].length, d = /\s*$/.exec(f)[0].length, p = f.length - d - t.length;
  return h.slice(u, u + e.length) == e && f.slice(p, p + t.length) == t ? {
    open: {
      pos: n + u + e.length,
      margin: /\s/.test(h.charAt(u + e.length)) ? 1 : 0
    },
    close: {
      pos: r - d - t.length,
      margin: /\s/.test(f.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function a2(i) {
  let e = [];
  for (let t of i.selection.ranges) {
    let n = i.doc.lineAt(t.from), r = t.to <= n.to ? n : i.doc.lineAt(t.to);
    r.from > n.from && r.from == t.to && (r = t.to == n.to + 1 ? n : i.doc.lineAt(t.to - 1));
    let s = e.length - 1;
    s >= 0 && e[s].to > n.from ? e[s].to = r.to : e.push({ from: n.from + /^\s*/.exec(n.text)[0].length, to: r.to });
  }
  return e;
}
function d1(i, e, t = e.selection.ranges) {
  let n = t.map((s) => cu(e, s.from).block);
  if (!n.every((s) => s))
    return null;
  let r = t.map((s, o) => o2(e, n[o], s.from, s.to));
  if (i != 2 && !r.every((s) => s))
    return { changes: e.changes(t.map((s, o) => r[o] ? [] : [{ from: s.from, insert: n[o].open + " " }, { from: s.to, insert: " " + n[o].close }])) };
  if (i != 1 && r.some((s) => s)) {
    let s = [];
    for (let o = 0, a; o < r.length; o++)
      if (a = r[o]) {
        let l = n[o], { open: c, close: h } = a;
        s.push({ from: c.pos - l.open.length, to: c.pos + c.margin }, { from: h.pos - h.margin, to: h.pos + l.close.length });
      }
    return { changes: s };
  }
  return null;
}
function l2(i, e, t = e.selection.ranges) {
  let n = [], r = -1;
  for (let { from: s, to: o } of t) {
    let a = n.length, l = 1e9, c = cu(e, s).line;
    if (c) {
      for (let h = s; h <= o; ) {
        let f = e.doc.lineAt(h);
        if (f.from > r && (s == o || o > f.from)) {
          r = f.from;
          let u = /^\s*/.exec(f.text)[0].length, d = u == f.length, p = f.text.slice(u, u + c.length) == c ? u : -1;
          u < f.text.length && u < l && (l = u), n.push({ line: f, comment: p, token: c, indent: u, empty: d, single: !1 });
        }
        h = f.to + 1;
      }
      if (l < 1e9)
        for (let h = a; h < n.length; h++)
          n[h].indent < n[h].line.text.length && (n[h].indent = l);
      n.length == a + 1 && (n[a].single = !0);
    }
  }
  if (i != 2 && n.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: a, token: l, indent: c, empty: h, single: f } of n)
      (f || !h) && s.push({ from: a.from + c, insert: l + " " });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (i != 1 && n.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: a, token: l } of n)
      if (a >= 0) {
        let c = o.from + a, h = c + l.length;
        o.text[h - o.from] == " " && h++, s.push({ from: c, to: h });
      }
    return { changes: s };
  }
  return null;
}
const of = /* @__PURE__ */ _n.define(), c2 = /* @__PURE__ */ _n.define(), h2 = /* @__PURE__ */ le.define(), p1 = /* @__PURE__ */ le.define({
  combine(i) {
    return sn(i, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (n, r) => e(n, r) || t(n, r)
    });
  }
}), O1 = /* @__PURE__ */ ft.define({
  create() {
    return Ui.empty;
  },
  update(i, e) {
    let t = e.state.facet(p1), n = e.annotation(of);
    if (n) {
      let l = jt.fromTransaction(e, n.selection), c = n.side, h = c == 0 ? i.undone : i.done;
      return l ? h = tl(h, h.length, t.minDepth, l) : h = y1(h, e.startState.selection), new Ui(c == 0 ? n.rest : h, c == 0 ? h : n.rest);
    }
    let r = e.annotation(c2);
    if ((r == "full" || r == "before") && (i = i.isolate()), e.annotation(st.addToHistory) === !1)
      return e.changes.empty ? i : i.addMapping(e.changes.desc);
    let s = jt.fromTransaction(e), o = e.annotation(st.time), a = e.annotation(st.userEvent);
    return s ? i = i.addChanges(s, o, a, t, e) : e.selection && (i = i.addSelection(e.startState.selection, o, a, t.newGroupDelay)), (r == "full" || r == "after") && (i = i.isolate()), i;
  },
  toJSON(i) {
    return { done: i.done.map((e) => e.toJSON()), undone: i.undone.map((e) => e.toJSON()) };
  },
  fromJSON(i) {
    return new Ui(i.done.map(jt.fromJSON), i.undone.map(jt.fromJSON));
  }
});
function m1(i = {}) {
  return [
    O1,
    p1.of(i),
    ae.domEventHandlers({
      beforeinput(e, t) {
        let n = e.inputType == "historyUndo" ? g1 : e.inputType == "historyRedo" ? af : null;
        return n ? (e.preventDefault(), n(t)) : !1;
      }
    })
  ];
}
function Ll(i, e) {
  return function({ state: t, dispatch: n }) {
    if (!e && t.readOnly)
      return !1;
    let r = t.field(O1, !1);
    if (!r)
      return !1;
    let s = r.pop(i, t, e);
    return s ? (n(s), !0) : !1;
  };
}
const g1 = /* @__PURE__ */ Ll(0, !1), af = /* @__PURE__ */ Ll(1, !1), f2 = /* @__PURE__ */ Ll(0, !0), u2 = /* @__PURE__ */ Ll(1, !0);
class jt {
  constructor(e, t, n, r, s) {
    this.changes = e, this.effects = t, this.mapped = n, this.startSelection = r, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new jt(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, n;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (n = this.startSelection) === null || n === void 0 ? void 0 : n.toJSON(),
      selectionsAfter: this.selectionsAfter.map((r) => r.toJSON())
    };
  }
  static fromJSON(e) {
    return new jt(e.changes && lt.fromJSON(e.changes), [], e.mapped && Gi.fromJSON(e.mapped), e.startSelection && q.fromJSON(e.startSelection), e.selectionsAfter.map(q.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let n = hi;
    for (let r of e.startState.facet(h2)) {
      let s = r(e);
      s.length && (n = n.concat(s));
    }
    return !n.length && e.changes.empty ? null : new jt(e.changes.invert(e.startState.doc), n, void 0, t || e.startState.selection, hi);
  }
  static selection(e) {
    return new jt(void 0, hi, void 0, void 0, e);
  }
}
function tl(i, e, t, n) {
  let r = e + 1 > t + 20 ? e - t - 1 : 0, s = i.slice(r, e);
  return s.push(n), s;
}
function d2(i, e) {
  let t = [], n = !1;
  return i.iterChangedRanges((r, s) => t.push(r, s)), e.iterChangedRanges((r, s, o, a) => {
    for (let l = 0; l < t.length; ) {
      let c = t[l++], h = t[l++];
      a >= c && o <= h && (n = !0);
    }
  }), n;
}
function p2(i, e) {
  return i.ranges.length == e.ranges.length && i.ranges.filter((t, n) => t.empty != e.ranges[n].empty).length === 0;
}
function b1(i, e) {
  return i.length ? e.length ? i.concat(e) : i : e;
}
const hi = [], O2 = 200;
function y1(i, e) {
  if (i.length) {
    let t = i[i.length - 1], n = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - O2));
    return n.length && n[n.length - 1].eq(e) ? i : (n.push(e), tl(i, i.length - 1, 1e9, t.setSelAfter(n)));
  } else
    return [jt.selection([e])];
}
function m2(i) {
  let e = i[i.length - 1], t = i.slice();
  return t[i.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function $c(i, e) {
  if (!i.length)
    return i;
  let t = i.length, n = hi;
  for (; t; ) {
    let r = g2(i[t - 1], e, n);
    if (r.changes && !r.changes.empty || r.effects.length) {
      let s = i.slice(0, t);
      return s[t - 1] = r, s;
    } else
      e = r.mapped, t--, n = r.selectionsAfter;
  }
  return n.length ? [jt.selection(n)] : hi;
}
function g2(i, e, t) {
  let n = b1(i.selectionsAfter.length ? i.selectionsAfter.map((a) => a.map(e)) : hi, t);
  if (!i.changes)
    return jt.selection(n);
  let r = i.changes.map(e), s = e.mapDesc(i.changes, !0), o = i.mapped ? i.mapped.composeDesc(s) : s;
  return new jt(r, ge.mapEffects(i.effects, e), o, i.startSelection.map(s), n);
}
const b2 = /^(input\.type|delete)($|\.)/;
class Ui {
  constructor(e, t, n = 0, r = void 0) {
    this.done = e, this.undone = t, this.prevTime = n, this.prevUserEvent = r;
  }
  isolate() {
    return this.prevTime ? new Ui(this.done, this.undone) : this;
  }
  addChanges(e, t, n, r, s) {
    let o = this.done, a = o[o.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!n || b2.test(n)) && (!a.selectionsAfter.length && t - this.prevTime < r.newGroupDelay && r.joinToEvent(s, d2(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    n == "input.type.compose") ? o = tl(o, o.length - 1, r.minDepth, new jt(e.changes.compose(a.changes), b1(ge.mapEffects(e.effects, a.changes), a.effects), a.mapped, a.startSelection, hi)) : o = tl(o, o.length, r.minDepth, e), new Ui(o, hi, t, n);
  }
  addSelection(e, t, n, r) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : hi;
    return s.length > 0 && t - this.prevTime < r && n == this.prevUserEvent && n && /^select($|\.)/.test(n) && p2(s[s.length - 1], e) ? this : new Ui(y1(this.done, e), this.undone, t, n);
  }
  addMapping(e) {
    return new Ui($c(this.done, e), $c(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, n) {
    let r = e == 0 ? this.done : this.undone;
    if (r.length == 0)
      return null;
    let s = r[r.length - 1], o = s.selectionsAfter[0] || t.selection;
    if (n && s.selectionsAfter.length)
      return t.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: of.of({ side: e, rest: m2(r), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let a = r.length == 1 ? hi : r.slice(0, r.length - 1);
      return s.mapped && (a = $c(a, s.mapped)), t.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: of.of({ side: e, rest: a, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Ui.empty = /* @__PURE__ */ new Ui(hi, hi);
const v1 = [
  { key: "Mod-z", run: g1, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: af, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: af, preventDefault: !0 },
  { key: "Mod-u", run: f2, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: u2, preventDefault: !0 }
];
function bs(i, e) {
  return q.create(i.ranges.map(e), i.mainIndex);
}
function Pi(i, e) {
  return i.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function $i({ state: i, dispatch: e }, t) {
  let n = bs(i.selection, t);
  return n.eq(i.selection, !0) ? !1 : (e(Pi(i, n)), !0);
}
function Il(i, e) {
  return q.cursor(e ? i.to : i.from);
}
function S1(i, e) {
  return $i(i, (t) => t.empty ? i.moveByChar(t, e) : Il(t, e));
}
function Pt(i) {
  return i.textDirectionAt(i.state.selection.main.head) == We.LTR;
}
const w1 = (i) => S1(i, !Pt(i)), x1 = (i) => S1(i, Pt(i));
function k1(i, e) {
  return $i(i, (t) => t.empty ? i.moveByGroup(t, e) : Il(t, e));
}
const y2 = (i) => k1(i, !Pt(i)), v2 = (i) => k1(i, Pt(i));
function S2(i, e, t) {
  if (e.type.prop(t))
    return !0;
  let n = e.to - e.from;
  return n && (n > 2 || /[^\s,.;:]/.test(i.sliceDoc(e.from, e.to))) || e.firstChild;
}
function Bl(i, e, t) {
  let n = Ke(i).resolveInner(e.head), r = t ? Se.closedBy : Se.openedBy;
  for (let l = e.head; ; ) {
    let c = t ? n.childAfter(l) : n.childBefore(l);
    if (!c)
      break;
    S2(i, c, r) ? n = c : l = t ? c.to : c.from;
  }
  let s = n.type.prop(r), o, a;
  return s && (o = t ? ji(i, n.from, 1) : ji(i, n.to, -1)) && o.matched ? a = t ? o.end.to : o.end.from : a = t ? n.to : n.from, q.cursor(a, t ? -1 : 1);
}
const w2 = (i) => $i(i, (e) => Bl(i.state, e, !Pt(i))), x2 = (i) => $i(i, (e) => Bl(i.state, e, Pt(i)));
function Q1(i, e) {
  return $i(i, (t) => {
    if (!t.empty)
      return Il(t, e);
    let n = i.moveVertically(t, e);
    return n.head != t.head ? n : i.moveToLineBoundary(t, e);
  });
}
const _1 = (i) => Q1(i, !1), P1 = (i) => Q1(i, !0);
function $1(i) {
  let e = i.scrollDOM.clientHeight < i.scrollDOM.scrollHeight - 2, t = 0, n = 0, r;
  if (e) {
    for (let s of i.state.facet(ae.scrollMargins)) {
      let o = s(i);
      o?.top && (t = Math.max(o?.top, t)), o?.bottom && (n = Math.max(o?.bottom, n));
    }
    r = i.scrollDOM.clientHeight - t - n;
  } else
    r = (i.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: n,
    selfScroll: e,
    height: Math.max(i.defaultLineHeight, r - 5)
  };
}
function T1(i, e) {
  let t = $1(i), { state: n } = i, r = bs(n.selection, (o) => o.empty ? i.moveVertically(o, e, t.height) : Il(o, e));
  if (r.eq(n.selection))
    return !1;
  let s;
  if (t.selfScroll) {
    let o = i.coordsAtPos(n.selection.main.head), a = i.scrollDOM.getBoundingClientRect(), l = a.top + t.marginTop, c = a.bottom - t.marginBottom;
    o && o.top > l && o.bottom < c && (s = ae.scrollIntoView(r.main.head, { y: "start", yMargin: o.top - l }));
  }
  return i.dispatch(Pi(n, r), { effects: s }), !0;
}
const Bp = (i) => T1(i, !1), lf = (i) => T1(i, !0);
function jn(i, e, t) {
  let n = i.lineBlockAt(e.head), r = i.moveToLineBoundary(e, t);
  if (r.head == e.head && r.head != (t ? n.to : n.from) && (r = i.moveToLineBoundary(e, t, !1)), !t && r.head == n.from && n.length) {
    let s = /^\s*/.exec(i.state.sliceDoc(n.from, Math.min(n.from + 100, n.to)))[0].length;
    s && e.head != n.from + s && (r = q.cursor(n.from + s));
  }
  return r;
}
const k2 = (i) => $i(i, (e) => jn(i, e, !0)), Q2 = (i) => $i(i, (e) => jn(i, e, !1)), _2 = (i) => $i(i, (e) => jn(i, e, !Pt(i))), P2 = (i) => $i(i, (e) => jn(i, e, Pt(i))), $2 = (i) => $i(i, (e) => q.cursor(i.lineBlockAt(e.head).from, 1)), T2 = (i) => $i(i, (e) => q.cursor(i.lineBlockAt(e.head).to, -1));
function C2(i, e, t) {
  let n = !1, r = bs(i.selection, (s) => {
    let o = ji(i, s.head, -1) || ji(i, s.head, 1) || s.head > 0 && ji(i, s.head - 1, 1) || s.head < i.doc.length && ji(i, s.head + 1, -1);
    if (!o || !o.end)
      return s;
    n = !0;
    let a = o.start.from == s.head ? o.end.to : o.end.from;
    return q.cursor(a);
  });
  return n ? (e(Pi(i, r)), !0) : !1;
}
const A2 = ({ state: i, dispatch: e }) => C2(i, e);
function gi(i, e) {
  let t = bs(i.state.selection, (n) => {
    let r = e(n);
    return q.range(n.anchor, r.head, r.goalColumn, r.bidiLevel || void 0);
  });
  return t.eq(i.state.selection) ? !1 : (i.dispatch(Pi(i.state, t)), !0);
}
function C1(i, e) {
  return gi(i, (t) => i.moveByChar(t, e));
}
const A1 = (i) => C1(i, !Pt(i)), R1 = (i) => C1(i, Pt(i));
function E1(i, e) {
  return gi(i, (t) => i.moveByGroup(t, e));
}
const R2 = (i) => E1(i, !Pt(i)), E2 = (i) => E1(i, Pt(i)), M2 = (i) => gi(i, (e) => Bl(i.state, e, !Pt(i))), Z2 = (i) => gi(i, (e) => Bl(i.state, e, Pt(i)));
function M1(i, e) {
  return gi(i, (t) => i.moveVertically(t, e));
}
const Z1 = (i) => M1(i, !1), X1 = (i) => M1(i, !0);
function z1(i, e) {
  return gi(i, (t) => i.moveVertically(t, e, $1(i).height));
}
const Yp = (i) => z1(i, !1), Np = (i) => z1(i, !0), X2 = (i) => gi(i, (e) => jn(i, e, !0)), z2 = (i) => gi(i, (e) => jn(i, e, !1)), D2 = (i) => gi(i, (e) => jn(i, e, !Pt(i))), L2 = (i) => gi(i, (e) => jn(i, e, Pt(i))), I2 = (i) => gi(i, (e) => q.cursor(i.lineBlockAt(e.head).from)), B2 = (i) => gi(i, (e) => q.cursor(i.lineBlockAt(e.head).to)), Vp = ({ state: i, dispatch: e }) => (e(Pi(i, { anchor: 0 })), !0), qp = ({ state: i, dispatch: e }) => (e(Pi(i, { anchor: i.doc.length })), !0), Wp = ({ state: i, dispatch: e }) => (e(Pi(i, { anchor: i.selection.main.anchor, head: 0 })), !0), jp = ({ state: i, dispatch: e }) => (e(Pi(i, { anchor: i.selection.main.anchor, head: i.doc.length })), !0), Y2 = ({ state: i, dispatch: e }) => (e(i.update({ selection: { anchor: 0, head: i.doc.length }, userEvent: "select" })), !0), N2 = ({ state: i, dispatch: e }) => {
  let t = Yl(i).map(({ from: n, to: r }) => q.range(n, Math.min(r + 1, i.doc.length)));
  return e(i.update({ selection: q.create(t), userEvent: "select" })), !0;
}, V2 = ({ state: i, dispatch: e }) => {
  let t = bs(i.selection, (n) => {
    let r = Ke(i), s = r.resolveStack(n.from, 1);
    if (n.empty) {
      let o = r.resolveStack(n.from, -1);
      o.node.from >= s.node.from && o.node.to <= s.node.to && (s = o);
    }
    for (let o = s; o; o = o.next) {
      let { node: a } = o;
      if ((a.from < n.from && a.to >= n.to || a.to > n.to && a.from <= n.from) && o.next)
        return q.range(a.to, a.from);
    }
    return n;
  });
  return t.eq(i.selection) ? !1 : (e(Pi(i, t)), !0);
};
function D1(i, e) {
  let { state: t } = i, n = t.selection, r = t.selection.ranges.slice();
  for (let s of t.selection.ranges) {
    let o = t.doc.lineAt(s.head);
    if (e ? o.to < i.state.doc.length : o.from > 0)
      for (let a = s; ; ) {
        let l = i.moveVertically(a, e);
        if (l.head < o.from || l.head > o.to) {
          r.some((c) => c.head == l.head) || r.push(l);
          break;
        } else {
          if (l.head == a.head)
            break;
          a = l;
        }
      }
  }
  return r.length == n.ranges.length ? !1 : (i.dispatch(Pi(t, q.create(r, r.length - 1))), !0);
}
const q2 = (i) => D1(i, !1), W2 = (i) => D1(i, !0), j2 = ({ state: i, dispatch: e }) => {
  let t = i.selection, n = null;
  return t.ranges.length > 1 ? n = q.create([t.main]) : t.main.empty || (n = q.create([q.cursor(t.main.head)])), n ? (e(Pi(i, n)), !0) : !1;
};
function Mo(i, e) {
  if (i.state.readOnly)
    return !1;
  let t = "delete.selection", { state: n } = i, r = n.changeByRange((s) => {
    let { from: o, to: a } = s;
    if (o == a) {
      let l = e(s);
      l < o ? (t = "delete.backward", l = aa(i, l, !1)) : l > o && (t = "delete.forward", l = aa(i, l, !0)), o = Math.min(o, l), a = Math.max(a, l);
    } else
      o = aa(i, o, !1), a = aa(i, a, !0);
    return o == a ? { range: s } : { changes: { from: o, to: a }, range: q.cursor(o, o < s.head ? -1 : 1) };
  });
  return r.changes.empty ? !1 : (i.dispatch(n.update(r, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? ae.announce.of(n.phrase("Selection deleted")) : void 0
  })), !0);
}
function aa(i, e, t) {
  if (i instanceof ae)
    for (let n of i.state.facet(ae.atomicRanges).map((r) => r(i)))
      n.between(e, e, (r, s) => {
        r < e && s > e && (e = t ? s : r);
      });
  return e;
}
const L1 = (i, e, t) => Mo(i, (n) => {
  let r = n.from, { state: s } = i, o = s.doc.lineAt(r), a, l;
  if (t && !e && r > o.from && r < o.from + 200 && !/[^ \t]/.test(a = o.text.slice(0, r - o.from))) {
    if (a[a.length - 1] == "	")
      return r - 1;
    let c = ms(a, s.tabSize), h = c % Ka(s) || Ka(s);
    for (let f = 0; f < h && a[a.length - 1 - f] == " "; f++)
      r--;
    l = r;
  } else
    l = gt(o.text, r - o.from, e, e) + o.from, l == r && o.number != (e ? s.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(o.text.slice(l - o.from, r - o.from)) && (l = gt(o.text, l - o.from, !1, !1) + o.from);
  return l;
}), cf = (i) => L1(i, !1, !0), I1 = (i) => L1(i, !0, !1), B1 = (i, e) => Mo(i, (t) => {
  let n = t.head, { state: r } = i, s = r.doc.lineAt(n), o = r.charCategorizer(n);
  for (let a = null; ; ) {
    if (n == (e ? s.to : s.from)) {
      n == t.head && s.number != (e ? r.doc.lines : 1) && (n += e ? 1 : -1);
      break;
    }
    let l = gt(s.text, n - s.from, e) + s.from, c = s.text.slice(Math.min(n, l) - s.from, Math.max(n, l) - s.from), h = o(c);
    if (a != null && h != a)
      break;
    (c != " " || n != t.head) && (a = h), n = l;
  }
  return n;
}), Y1 = (i) => B1(i, !1), U2 = (i) => B1(i, !0), G2 = (i) => Mo(i, (e) => {
  let t = i.lineBlockAt(e.head).to;
  return e.head < t ? t : Math.min(i.state.doc.length, e.head + 1);
}), F2 = (i) => Mo(i, (e) => {
  let t = i.moveToLineBoundary(e, !1).head;
  return e.head > t ? t : Math.max(0, e.head - 1);
}), H2 = (i) => Mo(i, (e) => {
  let t = i.moveToLineBoundary(e, !0).head;
  return e.head < t ? t : Math.min(i.state.doc.length, e.head + 1);
}), K2 = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let t = i.changeByRange((n) => ({
    changes: { from: n.from, to: n.to, insert: Re.of(["", ""]) },
    range: q.cursor(n.from)
  }));
  return e(i.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, J2 = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let t = i.changeByRange((n) => {
    if (!n.empty || n.from == 0 || n.from == i.doc.length)
      return { range: n };
    let r = n.from, s = i.doc.lineAt(r), o = r == s.from ? r - 1 : gt(s.text, r - s.from, !1) + s.from, a = r == s.to ? r + 1 : gt(s.text, r - s.from, !0) + s.from;
    return {
      changes: { from: o, to: a, insert: i.doc.slice(r, a).append(i.doc.slice(o, r)) },
      range: q.cursor(a)
    };
  });
  return t.changes.empty ? !1 : (e(i.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Yl(i) {
  let e = [], t = -1;
  for (let n of i.selection.ranges) {
    let r = i.doc.lineAt(n.from), s = i.doc.lineAt(n.to);
    if (!n.empty && n.to == s.from && (s = i.doc.lineAt(n.to - 1)), t >= r.number) {
      let o = e[e.length - 1];
      o.to = s.to, o.ranges.push(n);
    } else
      e.push({ from: r.from, to: s.to, ranges: [n] });
    t = s.number + 1;
  }
  return e;
}
function N1(i, e, t) {
  if (i.readOnly)
    return !1;
  let n = [], r = [];
  for (let s of Yl(i)) {
    if (t ? s.to == i.doc.length : s.from == 0)
      continue;
    let o = i.doc.lineAt(t ? s.to + 1 : s.from - 1), a = o.length + 1;
    if (t) {
      n.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + i.lineBreak });
      for (let l of s.ranges)
        r.push(q.range(Math.min(i.doc.length, l.anchor + a), Math.min(i.doc.length, l.head + a)));
    } else {
      n.push({ from: o.from, to: s.from }, { from: s.to, insert: i.lineBreak + o.text });
      for (let l of s.ranges)
        r.push(q.range(l.anchor - a, l.head - a));
    }
  }
  return n.length ? (e(i.update({
    changes: n,
    scrollIntoView: !0,
    selection: q.create(r, i.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const e_ = ({ state: i, dispatch: e }) => N1(i, e, !1), t_ = ({ state: i, dispatch: e }) => N1(i, e, !0);
function V1(i, e, t) {
  if (i.readOnly)
    return !1;
  let n = [];
  for (let r of Yl(i))
    t ? n.push({ from: r.from, insert: i.doc.slice(r.from, r.to) + i.lineBreak }) : n.push({ from: r.to, insert: i.lineBreak + i.doc.slice(r.from, r.to) });
  return e(i.update({ changes: n, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const i_ = ({ state: i, dispatch: e }) => V1(i, e, !1), n_ = ({ state: i, dispatch: e }) => V1(i, e, !0), r_ = (i) => {
  if (i.state.readOnly)
    return !1;
  let { state: e } = i, t = e.changes(Yl(e).map(({ from: r, to: s }) => (r > 0 ? r-- : s < e.doc.length && s++, { from: r, to: s }))), n = bs(e.selection, (r) => {
    let s;
    if (i.lineWrapping) {
      let o = i.lineBlockAt(r.head), a = i.coordsAtPos(r.head, r.assoc || 1);
      a && (s = o.bottom + i.documentTop - a.bottom + i.defaultLineHeight / 2);
    }
    return i.moveVertically(r, !0, s);
  }).map(t);
  return i.dispatch({ changes: t, selection: n, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function s_(i, e) {
  if (/\(\)|\[\]|\{\}/.test(i.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = Ke(i).resolveInner(e), n = t.childBefore(e), r = t.childAfter(e), s;
  return n && r && n.to <= e && r.from >= e && (s = n.type.prop(Se.closedBy)) && s.indexOf(r.name) > -1 && i.doc.lineAt(n.to).from == i.doc.lineAt(r.from).from && !/\S/.test(i.sliceDoc(n.to, r.from)) ? { from: n.to, to: r.from } : null;
}
const Up = /* @__PURE__ */ q1(!1), o_ = /* @__PURE__ */ q1(!0);
function q1(i) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let n = e.changeByRange((r) => {
      let { from: s, to: o } = r, a = e.doc.lineAt(s), l = !i && s == o && s_(e, s);
      i && (s = o = (o <= a.to ? a : e.doc.lineAt(o)).to);
      let c = new Zl(e, { simulateBreak: s, simulateDoubleBreak: !!l }), h = su(c, s);
      for (h == null && (h = ms(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < a.to && /\s/.test(a.text[o - a.from]); )
        o++;
      l ? { from: s, to: o } = l : s > a.from && s < a.from + 100 && !/\S/.test(a.text.slice(0, s)) && (s = a.from);
      let f = ["", Oo(e, h)];
      return l && f.push(Oo(e, c.lineIndent(a.from, -1))), {
        changes: { from: s, to: o, insert: Re.of(f) },
        range: q.cursor(s + 1 + f[1].length)
      };
    });
    return t(e.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function hu(i, e) {
  let t = -1;
  return i.changeByRange((n) => {
    let r = [];
    for (let o = n.from; o <= n.to; ) {
      let a = i.doc.lineAt(o);
      a.number > t && (n.empty || n.to > a.from) && (e(a, r, n), t = a.number), o = a.to + 1;
    }
    let s = i.changes(r);
    return {
      changes: r,
      range: q.range(s.mapPos(n.anchor, 1), s.mapPos(n.head, 1))
    };
  });
}
const a_ = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), n = new Zl(i, { overrideIndentation: (s) => {
    let o = t[s];
    return o ?? -1;
  } }), r = hu(i, (s, o, a) => {
    let l = su(n, s.from);
    if (l == null)
      return;
    /\S/.test(s.text) || (l = 0);
    let c = /^\s*/.exec(s.text)[0], h = Oo(i, l);
    (c != h || a.from < s.from + c.length) && (t[s.from] = l, o.push({ from: s.from, to: s.from + c.length, insert: h }));
  });
  return r.changes.empty || e(i.update(r, { userEvent: "indent" })), !0;
}, W1 = ({ state: i, dispatch: e }) => i.readOnly ? !1 : (e(i.update(hu(i, (t, n) => {
  n.push({ from: t.from, insert: i.facet(Ml) });
}), { userEvent: "input.indent" })), !0), l_ = ({ state: i, dispatch: e }) => i.readOnly ? !1 : (e(i.update(hu(i, (t, n) => {
  let r = /^\s*/.exec(t.text)[0];
  if (!r)
    return;
  let s = ms(r, i.tabSize), o = 0, a = Oo(i, Math.max(0, s - Ka(i)));
  for (; o < r.length && o < a.length && r.charCodeAt(o) == a.charCodeAt(o); )
    o++;
  n.push({ from: t.from + o, to: t.from + r.length, insert: a.slice(o) });
}), { userEvent: "delete.dedent" })), !0), c_ = (i) => (i.setTabFocusMode(), !0), h_ = ({ state: i, dispatch: e }) => i.selection.ranges.some((t) => !t.empty) ? W1({ state: i, dispatch: e }) : (e(i.update(i.replaceSelection("	"), { scrollIntoView: !0, userEvent: "input" })), !0), f_ = [
  { key: "Ctrl-b", run: w1, shift: A1, preventDefault: !0 },
  { key: "Ctrl-f", run: x1, shift: R1 },
  { key: "Ctrl-p", run: _1, shift: Z1 },
  { key: "Ctrl-n", run: P1, shift: X1 },
  { key: "Ctrl-a", run: $2, shift: I2 },
  { key: "Ctrl-e", run: T2, shift: B2 },
  { key: "Ctrl-d", run: I1 },
  { key: "Ctrl-h", run: cf },
  { key: "Ctrl-k", run: G2 },
  { key: "Ctrl-Alt-h", run: Y1 },
  { key: "Ctrl-o", run: K2 },
  { key: "Ctrl-t", run: J2 },
  { key: "Ctrl-v", run: lf }
], u_ = /* @__PURE__ */ [
  { key: "ArrowLeft", run: w1, shift: A1, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: y2, shift: R2, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: _2, shift: D2, preventDefault: !0 },
  { key: "ArrowRight", run: x1, shift: R1, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: v2, shift: E2, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: P2, shift: L2, preventDefault: !0 },
  { key: "ArrowUp", run: _1, shift: Z1, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Vp, shift: Wp },
  { mac: "Ctrl-ArrowUp", run: Bp, shift: Yp },
  { key: "ArrowDown", run: P1, shift: X1, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: qp, shift: jp },
  { mac: "Ctrl-ArrowDown", run: lf, shift: Np },
  { key: "PageUp", run: Bp, shift: Yp },
  { key: "PageDown", run: lf, shift: Np },
  { key: "Home", run: Q2, shift: z2, preventDefault: !0 },
  { key: "Mod-Home", run: Vp, shift: Wp },
  { key: "End", run: k2, shift: X2, preventDefault: !0 },
  { key: "Mod-End", run: qp, shift: jp },
  { key: "Enter", run: Up, shift: Up },
  { key: "Mod-a", run: Y2 },
  { key: "Backspace", run: cf, shift: cf, preventDefault: !0 },
  { key: "Delete", run: I1, preventDefault: !0 },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: Y1, preventDefault: !0 },
  { key: "Mod-Delete", mac: "Alt-Delete", run: U2, preventDefault: !0 },
  { mac: "Mod-Backspace", run: F2, preventDefault: !0 },
  { mac: "Mod-Delete", run: H2, preventDefault: !0 }
].concat(/* @__PURE__ */ f_.map((i) => ({ mac: i.key, run: i.run, shift: i.shift }))), j1 = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: w2, shift: M2 },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: x2, shift: Z2 },
  { key: "Alt-ArrowUp", run: e_ },
  { key: "Shift-Alt-ArrowUp", run: i_ },
  { key: "Alt-ArrowDown", run: t_ },
  { key: "Shift-Alt-ArrowDown", run: n_ },
  { key: "Mod-Alt-ArrowUp", run: q2 },
  { key: "Mod-Alt-ArrowDown", run: W2 },
  { key: "Escape", run: j2 },
  { key: "Mod-Enter", run: o_ },
  { key: "Alt-l", mac: "Ctrl-l", run: N2 },
  { key: "Mod-i", run: V2, preventDefault: !0 },
  { key: "Mod-[", run: l_ },
  { key: "Mod-]", run: W1 },
  { key: "Mod-Alt-\\", run: a_ },
  { key: "Shift-Mod-k", run: r_ },
  { key: "Shift-Mod-\\", run: A2 },
  { key: "Mod-/", run: i2 },
  { key: "Alt-A", run: r2 },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: c_ }
].concat(u_), Gp = typeof String.prototype.normalize == "function" ? (i) => i.normalize("NFKD") : (i) => i;
class ns {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, n = 0, r = e.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(n, r), this.bufferStart = n, this.normalize = s ? (a) => s(Gp(a)) : Gp, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Yt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = Df(e), n = this.bufferStart + this.bufferPos;
      this.bufferPos += Bi(e);
      let r = this.normalize(t);
      if (r.length)
        for (let s = 0, o = n; ; s++) {
          let a = r.charCodeAt(s), l = this.match(a, o, this.bufferPos + this.bufferStart);
          if (s == r.length - 1) {
            if (l)
              return this.value = l, this;
            break;
          }
          o == n && s < t.length && t.charCodeAt(s) == a && o++;
        }
    }
  }
  match(e, t, n) {
    let r = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let o = this.matches[s], a = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? r = { from: this.matches[s + 1], to: n } : (this.matches[s]++, a = !0)), a || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? r = { from: t, to: n } : this.matches.push(1, t)), r && this.test && !this.test(r.from, r.to, this.buffer, this.bufferStart) && (r = null), r;
  }
}
typeof Symbol < "u" && (ns.prototype[Symbol.iterator] = function() {
  return this;
});
const U1 = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, fu = "gm" + (/x/.unicode == null ? "" : "u");
class G1 {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, n, r = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = U1, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new F1(e, t, n, r, s);
    this.re = new RegExp(t, fu + (n?.ignoreCase ? "i" : "")), this.test = n?.test, this.iter = e.iter();
    let o = e.lineAt(r);
    this.curLineStart = o.from, this.matchPos = il(e, r), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let n = this.curLineStart + t.index, r = n + t[0].length;
        if (this.matchPos = il(this.text, r + (n == r ? 1 : 0)), n == this.curLineStart + this.curLine.length && this.nextLine(), (n < r || n > this.value.to) && (!this.test || this.test(n, r, t)))
          return this.value = { from: n, to: r, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Tc = /* @__PURE__ */ new WeakMap();
class Nr {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, n) {
    let r = Tc.get(e);
    if (!r || r.from >= n || r.to <= t) {
      let a = new Nr(t, e.sliceString(t, n));
      return Tc.set(e, a), a;
    }
    if (r.from == t && r.to == n)
      return r;
    let { text: s, from: o } = r;
    return o > t && (s = e.sliceString(t, o) + s, o = t), r.to < n && (s += e.sliceString(r.to, n)), Tc.set(e, new Nr(o, s)), new Nr(t, s.slice(t - o, n - o));
  }
}
class F1 {
  constructor(e, t, n, r, s) {
    this.text = e, this.to = s, this.done = !1, this.value = U1, this.matchPos = il(e, r), this.re = new RegExp(t, fu + (n?.ignoreCase ? "i" : "")), this.test = n?.test, this.flat = Nr.get(e, r, this.chunkEnd(
      r + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let n = this.flat.from + t.index, r = n + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(n, r, t)))
          return this.value = { from: n, to: r, match: t }, this.matchPos = il(this.text, r + (n == r ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Nr.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (G1.prototype[Symbol.iterator] = F1.prototype[Symbol.iterator] = function() {
  return this;
});
function d_(i) {
  try {
    return new RegExp(i, fu), !0;
  } catch {
    return !1;
  }
}
function il(i, e) {
  if (e >= i.length)
    return e;
  let t = i.lineAt(e), n;
  for (; e < t.to && (n = t.text.charCodeAt(e - t.from)) >= 56320 && n < 57344; )
    e++;
  return e;
}
function hf(i) {
  let e = String(i.state.doc.lineAt(i.state.selection.main.head).number), t = De("input", { class: "cm-textfield", name: "line", value: e }), n = De("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), i.dispatch({ effects: Js.of(!1) }), i.focus()) : s.keyCode == 13 && (s.preventDefault(), r());
    },
    onsubmit: (s) => {
      s.preventDefault(), r();
    }
  }, De("label", i.state.phrase("Go to line"), ": ", t), " ", De("button", { class: "cm-button", type: "submit" }, i.state.phrase("go")), De("button", {
    name: "close",
    onclick: () => {
      i.dispatch({ effects: Js.of(!1) }), i.focus();
    },
    "aria-label": i.state.phrase("close"),
    type: "button"
  }, ["Ã—"]));
  function r() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(t.value);
    if (!s)
      return;
    let { state: o } = i, a = o.doc.lineAt(o.selection.main.head), [, l, c, h, f] = s, u = h ? +h.slice(1) : 0, d = c ? +c : a.number;
    if (c && f) {
      let m = d / 100;
      l && (m = m * (l == "-" ? -1 : 1) + a.number / o.doc.lines), d = Math.round(o.doc.lines * m);
    } else c && l && (d = d * (l == "-" ? -1 : 1) + a.number);
    let p = o.doc.line(Math.max(1, Math.min(o.doc.lines, d))), O = q.cursor(p.from + Math.max(0, Math.min(u, p.length)));
    i.dispatch({
      effects: [Js.of(!1), ae.scrollIntoView(O.from, { y: "center" })],
      selection: O
    }), i.focus();
  }
  return { dom: n };
}
const Js = /* @__PURE__ */ ge.define(), Fp = /* @__PURE__ */ ft.define({
  create() {
    return !0;
  },
  update(i, e) {
    for (let t of e.effects)
      t.is(Js) && (i = t.value);
    return i;
  },
  provide: (i) => ho.from(i, (e) => e ? hf : null)
}), p_ = (i) => {
  let e = co(i, hf);
  if (!e) {
    let t = [Js.of(!0)];
    i.state.field(Fp, !1) == null && t.push(ge.appendConfig.of([Fp, O_])), i.dispatch({ effects: t }), e = co(i, hf);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, O_ = /* @__PURE__ */ ae.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), m_ = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, g_ = /* @__PURE__ */ le.define({
  combine(i) {
    return sn(i, m_, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function b_(i) {
  return [x_, w_];
}
const y_ = /* @__PURE__ */ pe.mark({ class: "cm-selectionMatch" }), v_ = /* @__PURE__ */ pe.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function Hp(i, e, t, n) {
  return (t == 0 || i(e.sliceDoc(t - 1, t)) != Fe.Word) && (n == e.doc.length || i(e.sliceDoc(n, n + 1)) != Fe.Word);
}
function S_(i, e, t, n) {
  return i(e.sliceDoc(t, t + 1)) == Fe.Word && i(e.sliceDoc(n - 1, n)) == Fe.Word;
}
const w_ = /* @__PURE__ */ ot.fromClass(class {
  constructor(i) {
    this.decorations = this.getDeco(i);
  }
  update(i) {
    (i.selectionSet || i.docChanged || i.viewportChanged) && (this.decorations = this.getDeco(i.view));
  }
  getDeco(i) {
    let e = i.state.facet(g_), { state: t } = i, n = t.selection;
    if (n.ranges.length > 1)
      return pe.none;
    let r = n.main, s, o = null;
    if (r.empty) {
      if (!e.highlightWordAroundCursor)
        return pe.none;
      let l = t.wordAt(r.head);
      if (!l)
        return pe.none;
      o = t.charCategorizer(r.head), s = t.sliceDoc(l.from, l.to);
    } else {
      let l = r.to - r.from;
      if (l < e.minSelectionLength || l > 200)
        return pe.none;
      if (e.wholeWords) {
        if (s = t.sliceDoc(r.from, r.to), o = t.charCategorizer(r.head), !(Hp(o, t, r.from, r.to) && S_(o, t, r.from, r.to)))
          return pe.none;
      } else if (s = t.sliceDoc(r.from, r.to), !s)
        return pe.none;
    }
    let a = [];
    for (let l of i.visibleRanges) {
      let c = new ns(t.doc, s, l.from, l.to);
      for (; !c.next().done; ) {
        let { from: h, to: f } = c.value;
        if ((!o || Hp(o, t, h, f)) && (r.empty && h <= r.from && f >= r.to ? a.push(v_.range(h, f)) : (h >= r.to || f <= r.from) && a.push(y_.range(h, f)), a.length > e.maxMatches))
          return pe.none;
      }
    }
    return pe.set(a);
  }
}, {
  decorations: (i) => i.decorations
}), x_ = /* @__PURE__ */ ae.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), k_ = ({ state: i, dispatch: e }) => {
  let { selection: t } = i, n = q.create(t.ranges.map((r) => i.wordAt(r.head) || q.cursor(r.head)), t.mainIndex);
  return n.eq(t) ? !1 : (e(i.update({ selection: n })), !0);
};
function Q_(i, e) {
  let { main: t, ranges: n } = i.selection, r = i.wordAt(t.head), s = r && r.from == t.from && r.to == t.to;
  for (let o = !1, a = new ns(i.doc, e, n[n.length - 1].to); ; )
    if (a.next(), a.done) {
      if (o)
        return null;
      a = new ns(i.doc, e, 0, Math.max(0, n[n.length - 1].from - 1)), o = !0;
    } else {
      if (o && n.some((l) => l.from == a.value.from))
        continue;
      if (s) {
        let l = i.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const __ = ({ state: i, dispatch: e }) => {
  let { ranges: t } = i.selection;
  if (t.some((s) => s.from === s.to))
    return k_({ state: i, dispatch: e });
  let n = i.sliceDoc(t[0].from, t[0].to);
  if (i.selection.ranges.some((s) => i.sliceDoc(s.from, s.to) != n))
    return !1;
  let r = Q_(i, n);
  return r ? (e(i.update({
    selection: i.selection.addRange(q.range(r.from, r.to), !1),
    effects: ae.scrollIntoView(r.to)
  })), !0) : !1;
}, ys = /* @__PURE__ */ le.define({
  combine(i) {
    return sn(i, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new D_(e),
      scrollToMatch: (e) => ae.scrollIntoView(e)
    });
  }
});
class H1 {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || d_(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, n) => n == "n" ? `
` : n == "r" ? "\r" : n == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new C_(this) : new $_(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, n) {
    let r = e.doc ? e : $e.create({ doc: e });
    return n == null && (n = r.doc.length), this.regexp ? Er(this, r, t, n) : Rr(this, r, t, n);
  }
}
class K1 {
  constructor(e) {
    this.spec = e;
  }
}
function Rr(i, e, t, n) {
  return new ns(e.doc, i.unquoted, t, n, i.caseSensitive ? void 0 : (r) => r.toLowerCase(), i.wholeWord ? P_(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function P_(i, e) {
  return (t, n, r, s) => ((s > t || s + r.length < n) && (s = Math.max(0, t - 2), r = i.sliceString(s, Math.min(i.length, n + 2))), (e(nl(r, t - s)) != Fe.Word || e(rl(r, t - s)) != Fe.Word) && (e(rl(r, n - s)) != Fe.Word || e(nl(r, n - s)) != Fe.Word));
}
class $_ extends K1 {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, n) {
    let r = Rr(this.spec, e, n, e.doc.length).nextOverlapping();
    if (r.done) {
      let s = Math.min(e.doc.length, t + this.spec.unquoted.length);
      r = Rr(this.spec, e, 0, s).nextOverlapping();
    }
    return r.done || r.value.from == t && r.value.to == n ? null : r.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, n) {
    for (let r = n; ; ) {
      let s = Math.max(t, r - 1e4 - this.spec.unquoted.length), o = Rr(this.spec, e, s, r), a = null;
      for (; !o.nextOverlapping().done; )
        a = o.value;
      if (a)
        return a;
      if (s == t)
        return null;
      r -= 1e4;
    }
  }
  prevMatch(e, t, n) {
    let r = this.prevMatchInRange(e, 0, t);
    return r || (r = this.prevMatchInRange(e, Math.max(0, n - this.spec.unquoted.length), e.doc.length)), r && (r.from != t || r.to != n) ? r : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let n = Rr(this.spec, e, 0, e.doc.length), r = [];
    for (; !n.next().done; ) {
      if (r.length >= t)
        return null;
      r.push(n.value);
    }
    return r;
  }
  highlight(e, t, n, r) {
    let s = Rr(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(n + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      r(s.value.from, s.value.to);
  }
}
function Er(i, e, t, n) {
  return new G1(e.doc, i.search, {
    ignoreCase: !i.caseSensitive,
    test: i.wholeWord ? T_(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, n);
}
function nl(i, e) {
  return i.slice(gt(i, e, !1), e);
}
function rl(i, e) {
  return i.slice(e, gt(i, e));
}
function T_(i) {
  return (e, t, n) => !n[0].length || (i(nl(n.input, n.index)) != Fe.Word || i(rl(n.input, n.index)) != Fe.Word) && (i(rl(n.input, n.index + n[0].length)) != Fe.Word || i(nl(n.input, n.index + n[0].length)) != Fe.Word);
}
class C_ extends K1 {
  nextMatch(e, t, n) {
    let r = Er(this.spec, e, n, e.doc.length).next();
    return r.done && (r = Er(this.spec, e, 0, t).next()), r.done ? null : r.value;
  }
  prevMatchInRange(e, t, n) {
    for (let r = 1; ; r++) {
      let s = Math.max(
        t,
        n - r * 1e4
        /* FindPrev.ChunkSize */
      ), o = Er(this.spec, e, s, n), a = null;
      for (; !o.next().done; )
        a = o.value;
      if (a && (s == t || a.from > s + 10))
        return a;
      if (s == t)
        return null;
    }
  }
  prevMatch(e, t, n) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, n, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (t, n) => {
      if (n == "&")
        return e.match[0];
      if (n == "$")
        return "$";
      for (let r = n.length; r > 0; r--) {
        let s = +n.slice(0, r);
        if (s > 0 && s < e.match.length)
          return e.match[s] + n.slice(r);
      }
      return t;
    });
  }
  matchAll(e, t) {
    let n = Er(this.spec, e, 0, e.doc.length), r = [];
    for (; !n.next().done; ) {
      if (r.length >= t)
        return null;
      r.push(n.value);
    }
    return r;
  }
  highlight(e, t, n, r) {
    let s = Er(this.spec, e, Math.max(
      0,
      t - 250
      /* RegExp.HighlightMargin */
    ), Math.min(n + 250, e.doc.length));
    for (; !s.next().done; )
      r(s.value.from, s.value.to);
  }
}
const mo = /* @__PURE__ */ ge.define(), uu = /* @__PURE__ */ ge.define(), Dn = /* @__PURE__ */ ft.define({
  create(i) {
    return new Cc(ff(i).create(), null);
  },
  update(i, e) {
    for (let t of e.effects)
      t.is(mo) ? i = new Cc(t.value.create(), i.panel) : t.is(uu) && (i = new Cc(i.query, t.value ? du : null));
    return i;
  },
  provide: (i) => ho.from(i, (e) => e.panel)
});
class Cc {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const A_ = /* @__PURE__ */ pe.mark({ class: "cm-searchMatch" }), R_ = /* @__PURE__ */ pe.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), E_ = /* @__PURE__ */ ot.fromClass(class {
  constructor(i) {
    this.view = i, this.decorations = this.highlight(i.state.field(Dn));
  }
  update(i) {
    let e = i.state.field(Dn);
    (e != i.startState.field(Dn) || i.docChanged || i.selectionSet || i.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: i, panel: e }) {
    if (!e || !i.spec.valid)
      return pe.none;
    let { view: t } = this, n = new wn();
    for (let r = 0, s = t.visibleRanges, o = s.length; r < o; r++) {
      let { from: a, to: l } = s[r];
      for (; r < o - 1 && l > s[r + 1].from - 500; )
        l = s[++r].to;
      i.highlight(t.state, a, l, (c, h) => {
        let f = t.state.selection.ranges.some((u) => u.from == c && u.to == h);
        n.add(c, h, f ? R_ : A_);
      });
    }
    return n.finish();
  }
}, {
  decorations: (i) => i.decorations
});
function Zo(i) {
  return (e) => {
    let t = e.state.field(Dn, !1);
    return t && t.query.spec.valid ? i(e, t) : tb(e);
  };
}
const sl = /* @__PURE__ */ Zo((i, { query: e }) => {
  let { to: t } = i.state.selection.main, n = e.nextMatch(i.state, t, t);
  if (!n)
    return !1;
  let r = q.single(n.from, n.to), s = i.state.facet(ys);
  return i.dispatch({
    selection: r,
    effects: [pu(i, n), s.scrollToMatch(r.main, i)],
    userEvent: "select.search"
  }), eb(i), !0;
}), ol = /* @__PURE__ */ Zo((i, { query: e }) => {
  let { state: t } = i, { from: n } = t.selection.main, r = e.prevMatch(t, n, n);
  if (!r)
    return !1;
  let s = q.single(r.from, r.to), o = i.state.facet(ys);
  return i.dispatch({
    selection: s,
    effects: [pu(i, r), o.scrollToMatch(s.main, i)],
    userEvent: "select.search"
  }), eb(i), !0;
}), M_ = /* @__PURE__ */ Zo((i, { query: e }) => {
  let t = e.matchAll(i.state, 1e3);
  return !t || !t.length ? !1 : (i.dispatch({
    selection: q.create(t.map((n) => q.range(n.from, n.to))),
    userEvent: "select.search.matches"
  }), !0);
}), Z_ = ({ state: i, dispatch: e }) => {
  let t = i.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: n, to: r } = t.main, s = [], o = 0;
  for (let a = new ns(i.doc, i.sliceDoc(n, r)); !a.next().done; ) {
    if (s.length > 1e3)
      return !1;
    a.value.from == n && (o = s.length), s.push(q.range(a.value.from, a.value.to));
  }
  return e(i.update({
    selection: q.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, Kp = /* @__PURE__ */ Zo((i, { query: e }) => {
  let { state: t } = i, { from: n, to: r } = t.selection.main;
  if (t.readOnly)
    return !1;
  let s = e.nextMatch(t, n, n);
  if (!s)
    return !1;
  let o = s, a = [], l, c, h = [];
  o.from == n && o.to == r && (c = t.toText(e.getReplacement(o)), a.push({ from: o.from, to: o.to, insert: c }), o = e.nextMatch(t, o.from, o.to), h.push(ae.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(n).number) + ".")));
  let f = i.state.changes(a);
  return o && (l = q.single(o.from, o.to).map(f), h.push(pu(i, o)), h.push(t.facet(ys).scrollToMatch(l.main, i))), i.dispatch({
    changes: f,
    selection: l,
    effects: h,
    userEvent: "input.replace"
  }), !0;
}), X_ = /* @__PURE__ */ Zo((i, { query: e }) => {
  if (i.state.readOnly)
    return !1;
  let t = e.matchAll(i.state, 1e9).map((r) => {
    let { from: s, to: o } = r;
    return { from: s, to: o, insert: e.getReplacement(r) };
  });
  if (!t.length)
    return !1;
  let n = i.state.phrase("replaced $ matches", t.length) + ".";
  return i.dispatch({
    changes: t,
    effects: ae.announce.of(n),
    userEvent: "input.replace.all"
  }), !0;
});
function du(i) {
  return i.state.facet(ys).createPanel(i);
}
function ff(i, e) {
  var t, n, r, s, o;
  let a = i.selection.main, l = a.empty || a.to > a.from + 100 ? "" : i.sliceDoc(a.from, a.to);
  if (e && !l)
    return e;
  let c = i.facet(ys);
  return new H1({
    search: ((t = e?.literal) !== null && t !== void 0 ? t : c.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (n = e?.caseSensitive) !== null && n !== void 0 ? n : c.caseSensitive,
    literal: (r = e?.literal) !== null && r !== void 0 ? r : c.literal,
    regexp: (s = e?.regexp) !== null && s !== void 0 ? s : c.regexp,
    wholeWord: (o = e?.wholeWord) !== null && o !== void 0 ? o : c.wholeWord
  });
}
function J1(i) {
  let e = co(i, du);
  return e && e.dom.querySelector("[main-field]");
}
function eb(i) {
  let e = J1(i);
  e && e == i.root.activeElement && e.select();
}
const tb = (i) => {
  let e = i.state.field(Dn, !1);
  if (e && e.panel) {
    let t = J1(i);
    if (t && t != i.root.activeElement) {
      let n = ff(i.state, e.query.spec);
      n.valid && i.dispatch({ effects: mo.of(n) }), t.focus(), t.select();
    }
  } else
    i.dispatch({ effects: [
      uu.of(!0),
      e ? mo.of(ff(i.state, e.query.spec)) : ge.appendConfig.of(I_)
    ] });
  return !0;
}, ib = (i) => {
  let e = i.state.field(Dn, !1);
  if (!e || !e.panel)
    return !1;
  let t = co(i, du);
  return t && t.dom.contains(i.root.activeElement) && i.focus(), i.dispatch({ effects: uu.of(!1) }), !0;
}, z_ = [
  { key: "Mod-f", run: tb, scope: "editor search-panel" },
  { key: "F3", run: sl, shift: ol, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: sl, shift: ol, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: ib, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: Z_ },
  { key: "Mod-Alt-g", run: p_ },
  { key: "Mod-d", run: __, preventDefault: !0 }
];
class D_ {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(Dn).query.spec;
    this.commit = this.commit.bind(this), this.searchField = De("input", {
      value: t.search,
      placeholder: Gt(e, "Find"),
      "aria-label": Gt(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = De("input", {
      value: t.replace,
      placeholder: Gt(e, "Replace"),
      "aria-label": Gt(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = De("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = De("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = De("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function n(r, s, o) {
      return De("button", { class: "cm-button", name: r, onclick: s, type: "button" }, o);
    }
    this.dom = De("div", { onkeydown: (r) => this.keydown(r), class: "cm-search" }, [
      this.searchField,
      n("next", () => sl(e), [Gt(e, "next")]),
      n("prev", () => ol(e), [Gt(e, "previous")]),
      n("select", () => M_(e), [Gt(e, "all")]),
      De("label", null, [this.caseField, Gt(e, "match case")]),
      De("label", null, [this.reField, Gt(e, "regexp")]),
      De("label", null, [this.wordField, Gt(e, "by word")]),
      ...e.state.readOnly ? [] : [
        De("br"),
        this.replaceField,
        n("replace", () => Kp(e), [Gt(e, "replace")]),
        n("replaceAll", () => X_(e), [Gt(e, "replace all")])
      ],
      De("button", {
        name: "close",
        onclick: () => ib(e),
        "aria-label": Gt(e, "close"),
        type: "button"
      }, ["Ã—"])
    ]);
  }
  commit() {
    let e = new H1({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: mo.of(e) }));
  }
  keydown(e) {
    Ux(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? ol : sl)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Kp(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let n of t.effects)
        n.is(mo) && !n.value.eq(this.query) && this.setQuery(n.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(ys).top;
  }
}
function Gt(i, e) {
  return i.state.phrase(e);
}
const la = 30, ca = /[\s\.,:;?!]/;
function pu(i, { from: e, to: t }) {
  let n = i.state.doc.lineAt(e), r = i.state.doc.lineAt(t).to, s = Math.max(n.from, e - la), o = Math.min(r, t + la), a = i.state.sliceDoc(s, o);
  if (s != n.from) {
    for (let l = 0; l < la; l++)
      if (!ca.test(a[l + 1]) && ca.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (o != r) {
    for (let l = a.length - 1; l > a.length - la; l--)
      if (!ca.test(a[l - 1]) && ca.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return ae.announce.of(`${i.state.phrase("current match")}. ${a} ${i.state.phrase("on line")} ${n.number}.`);
}
const L_ = /* @__PURE__ */ ae.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), I_ = [
  Dn,
  /* @__PURE__ */ Wn.low(E_),
  L_
];
class nb {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesâ€”in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, n, r) {
    this.state = e, this.pos = t, this.explicit = n, this.view = r, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = Ke(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), n = Math.max(t.from, this.pos - 250), r = t.text.slice(n - t.from, this.pos - t.from), s = r.search(sb(e, !1));
    return s < 0 ? null : { from: n + s, to: this.pos, text: r.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, t, n) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(t), n && n.onDocChange && (this.abortOnDocChange = !0));
  }
}
function Jp(i) {
  let e = Object.keys(i).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function B_(i) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: r } of i) {
    e[r[0]] = !0;
    for (let s = 1; s < r.length; s++)
      t[r[s]] = !0;
  }
  let n = Jp(e) + Jp(t) + "*$";
  return [new RegExp("^" + n), new RegExp(n)];
}
function rb(i) {
  let e = i.map((r) => typeof r == "string" ? { label: r } : r), [t, n] = e.every((r) => /^\w+$/.test(r.label)) ? [/\w*$/, /\w+$/] : B_(e);
  return (r) => {
    let s = r.matchBefore(n);
    return s || r.explicit ? { from: s ? s.from : r.pos, options: e, validFor: t } : null;
  };
}
function Y_(i, e) {
  return (t) => {
    for (let n = Ke(t.state).resolveInner(t.pos, -1); n; n = n.parent) {
      if (i.indexOf(n.name) > -1)
        return null;
      if (n.type.isTop)
        break;
    }
    return e(t);
  };
}
class eO {
  constructor(e, t, n, r) {
    this.completion = e, this.source = t, this.match = n, this.score = r;
  }
}
function fr(i) {
  return i.selection.main.from;
}
function sb(i, e) {
  var t;
  let { source: n } = i, r = e && n[0] != "^", s = n[n.length - 1] != "$";
  return !r && !s ? i : new RegExp(`${r ? "^" : ""}(?:${n})${s ? "$" : ""}`, (t = i.flags) !== null && t !== void 0 ? t : i.ignoreCase ? "i" : "");
}
const Ou = /* @__PURE__ */ _n.define();
function N_(i, e, t, n) {
  let { main: r } = i.selection, s = t - r.from, o = n - r.from;
  return {
    ...i.changeByRange((a) => {
      if (a != r && t != n && i.sliceDoc(a.from + s, a.from + o) != i.sliceDoc(t, n))
        return { range: a };
      let l = i.toText(e);
      return {
        changes: { from: a.from + s, to: n == r.from ? a.to : a.from + o, insert: l },
        range: q.cursor(a.from + s + l.length)
      };
    }),
    scrollIntoView: !0,
    userEvent: "input.complete"
  };
}
const tO = /* @__PURE__ */ new WeakMap();
function V_(i) {
  if (!Array.isArray(i))
    return i;
  let e = tO.get(i);
  return e || tO.set(i, e = rb(i)), e;
}
const al = /* @__PURE__ */ ge.define(), go = /* @__PURE__ */ ge.define();
class q_ {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let t = 0; t < e.length; ) {
      let n = Yt(e, t), r = Bi(n);
      this.chars.push(n);
      let s = e.slice(t, t + r), o = s.toUpperCase();
      this.folded.push(Yt(o == s ? s.toLowerCase() : o, 0)), t += r;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, t) {
    return this.score = e, this.matched = t, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: t, folded: n, any: r, precise: s, byWord: o } = this;
    if (t.length == 1) {
      let v = Yt(e, 0), S = Bi(v), w = S == e.length ? 0 : -100;
      if (v != t[0]) if (v == n[0])
        w += -200;
      else
        return null;
      return this.ret(w, [0, S]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = t.length, c = 0;
    if (a < 0) {
      for (let v = 0, S = Math.min(e.length, 200); v < S && c < l; ) {
        let w = Yt(e, v);
        (w == t[c] || w == n[c]) && (r[c++] = v), v += Bi(w);
      }
      if (c < l)
        return null;
    }
    let h = 0, f = 0, u = !1, d = 0, p = -1, O = -1, m = /[a-z]/.test(e), g = !0;
    for (let v = 0, S = Math.min(e.length, 200), w = 0; v < S && f < l; ) {
      let x = Yt(e, v);
      a < 0 && (h < l && x == t[h] && (s[h++] = v), d < l && (x == t[d] || x == n[d] ? (d == 0 && (p = v), O = v + 1, d++) : d = 0));
      let P, k = x < 255 ? x >= 48 && x <= 57 || x >= 97 && x <= 122 ? 2 : x >= 65 && x <= 90 ? 1 : 0 : (P = Df(x)) != P.toLowerCase() ? 1 : P != P.toUpperCase() ? 2 : 0;
      (!v || k == 1 && m || w == 0 && k != 0) && (t[f] == x || n[f] == x && (u = !0) ? o[f++] = v : o.length && (g = !1)), w = k, v += Bi(x);
    }
    return f == l && o[0] == 0 && g ? this.result(-100 + (u ? -200 : 0), o, e) : d == l && p == 0 ? this.ret(-200 - e.length + (O == e.length ? 0 : -100), [0, O]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : d == l ? this.ret(-900 - e.length, [p, O]) : f == l ? this.result(-100 + (u ? -200 : 0) + -700 + (g ? 0 : -1100), o, e) : t.length == 2 ? null : this.result((r[0] ? -700 : 0) + -200 + -1100, r, e);
  }
  result(e, t, n) {
    let r = [], s = 0;
    for (let o of t) {
      let a = o + (this.astral ? Bi(Yt(n, o)) : 1);
      s && r[s - 1] == o ? r[s - 1] = a : (r[s++] = o, r[s++] = a);
    }
    return this.ret(e - n.length, r);
  }
}
class W_ {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let t = e.slice(0, this.pattern.length), n = t == this.pattern ? 0 : t.toLowerCase() == this.folded ? -200 : null;
    return n == null ? null : (this.matched = [0, t.length], this.score = n + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const ht = /* @__PURE__ */ le.define({
  combine(i) {
    return sn(i, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: j_,
      filterStrict: !1,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (n) => iO(e(n), t(n)),
      optionClass: (e, t) => (n) => iO(e(n), t(n)),
      addToOptions: (e, t) => e.concat(t),
      filterStrict: (e, t) => e || t
    });
  }
});
function iO(i, e) {
  return i ? e ? i + " " + e : i : e;
}
function j_(i, e, t, n, r, s) {
  let o = i.textDirection == We.RTL, a = o, l = !1, c = "top", h, f, u = e.left - r.left, d = r.right - e.right, p = n.right - n.left, O = n.bottom - n.top;
  if (a && u < Math.min(p, d) ? a = !1 : !a && d < Math.min(p, u) && (a = !0), p <= (a ? u : d))
    h = Math.max(r.top, Math.min(t.top, r.bottom - O)) - e.top, f = Math.min(400, a ? u : d);
  else {
    l = !0, f = Math.min(
      400,
      (o ? e.right : r.right - e.left) - 30
      /* Info.Margin */
    );
    let v = r.bottom - e.bottom;
    v >= O || v > e.top ? h = t.bottom - e.top : (c = "bottom", h = e.bottom - t.top);
  }
  let m = (e.bottom - e.top) / s.offsetHeight, g = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${c}: ${h / m}px; max-width: ${f / g}px`,
    class: "cm-completionInfo-" + (l ? o ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function U_(i) {
  let e = i.addToOptions.slice();
  return i.icons && e.push({
    render(t) {
      let n = document.createElement("div");
      return n.classList.add("cm-completionIcon"), t.type && n.classList.add(...t.type.split(/\s+/g).map((r) => "cm-completionIcon-" + r)), n.setAttribute("aria-hidden", "true"), n;
    },
    position: 20
  }), e.push({
    render(t, n, r, s) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let a = t.displayLabel || t.label, l = 0;
      for (let c = 0; c < s.length; ) {
        let h = s[c++], f = s[c++];
        h > l && o.appendChild(document.createTextNode(a.slice(l, h)));
        let u = o.appendChild(document.createElement("span"));
        u.appendChild(document.createTextNode(a.slice(h, f))), u.className = "cm-completionMatchedText", l = f;
      }
      return l < a.length && o.appendChild(document.createTextNode(a.slice(l))), o;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let n = document.createElement("span");
      return n.className = "cm-completionDetail", n.textContent = t.detail, n;
    },
    position: 80
  }), e.sort((t, n) => t.position - n.position).map((t) => t.render);
}
function Ac(i, e, t) {
  if (i <= t)
    return { from: 0, to: i };
  if (e < 0 && (e = 0), e <= i >> 1) {
    let r = Math.floor(e / t);
    return { from: r * t, to: (r + 1) * t };
  }
  let n = Math.floor((i - e) / t);
  return { from: i - (n + 1) * t, to: i - n * t };
}
class G_ {
  constructor(e, t, n) {
    this.view = e, this.stateField = t, this.applyCompletion = n, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let r = e.state.field(t), { options: s, selected: o } = r.open, a = e.state.facet(ht);
    this.optionContent = U_(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = Ac(s.length, o, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: c } = e.state.field(t).open;
      for (let h = l.target, f; h && h != this.dom; h = h.parentNode)
        if (h.nodeName == "LI" && (f = /-(\d+)$/.exec(h.id)) && +f[1] < c.length) {
          this.applyCompletion(e, c[+f[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(ht).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: go.of(null) });
    }), this.showOptions(s, r.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, t) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, t, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var t;
    let n = e.state.field(this.stateField), r = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), n != r) {
      let { options: s, selected: o, disabled: a } = n.open;
      (!r.open || r.open.options != s) && (this.range = Ac(s.length, o, e.state.facet(ht).maxRenderedOptions), this.showOptions(s, n.id)), this.updateSel(), a != ((t = r.open) === null || t === void 0 ? void 0 : t.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let n of this.currentClass.split(" "))
        n && this.dom.classList.remove(n);
      for (let n of t.split(" "))
        n && this.dom.classList.add(n);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    (t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = Ac(t.options.length, t.selected, this.view.state.facet(ht).maxRenderedOptions), this.showOptions(t.options, e.id));
    let n = this.updateSelectedOption(t.selected);
    if (n) {
      this.destroyInfo();
      let { completion: r } = t.options[t.selected], { info: s } = r;
      if (!s)
        return;
      let o = typeof s == "string" ? document.createTextNode(s) : s(r);
      if (!o)
        return;
      "then" in o ? o.then((a) => {
        a && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(a, r);
      }).catch((a) => Wt(this.view.state, a, "completion info")) : (this.addInfoPane(o, r), n.setAttribute("aria-describedby", this.info.id));
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let n = this.info = document.createElement("div");
    if (n.className = "cm-tooltip cm-completionInfo", n.id = "cm-completionInfo-" + Math.floor(Math.random() * 65535).toString(16), e.nodeType != null)
      n.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: r, destroy: s } = e;
      n.appendChild(r), this.infoDestroy = s || null;
    }
    this.dom.appendChild(n), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let n = this.list.firstChild, r = this.range.from; n; n = n.nextSibling, r++)
      n.nodeName != "LI" || !n.id ? r-- : r == e ? n.hasAttribute("aria-selected") || (n.setAttribute("aria-selected", "true"), t = n) : n.hasAttribute("aria-selected") && (n.removeAttribute("aria-selected"), n.removeAttribute("aria-describedby"));
    return t && H_(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), n = this.info.getBoundingClientRect(), r = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.documentElement;
      s = { left: 0, top: 0, right: o.clientWidth, bottom: o.clientHeight };
    }
    return r.top > Math.min(s.bottom, t.bottom) - 10 || r.bottom < Math.max(s.top, t.top) + 10 ? null : this.view.state.facet(ht).positionInfo(this.view, t, r, n, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, n) {
    const r = document.createElement("ul");
    r.id = t, r.setAttribute("role", "listbox"), r.setAttribute("aria-expanded", "true"), r.setAttribute("aria-label", this.view.state.phrase("Completions")), r.addEventListener("mousedown", (o) => {
      o.target == r && o.preventDefault();
    });
    let s = null;
    for (let o = n.from; o < n.to; o++) {
      let { completion: a, match: l } = e[o], { section: c } = a;
      if (c) {
        let u = typeof c == "string" ? c : c.name;
        if (u != s && (o > n.from || n.from == 0))
          if (s = u, typeof c != "string" && c.header)
            r.appendChild(c.header(c));
          else {
            let d = r.appendChild(document.createElement("completion-section"));
            d.textContent = u;
          }
      }
      const h = r.appendChild(document.createElement("li"));
      h.id = t + "-" + o, h.setAttribute("role", "option");
      let f = this.optionClass(a);
      f && (h.className = f);
      for (let u of this.optionContent) {
        let d = u(a, this.view.state, this.view, l);
        d && h.appendChild(d);
      }
    }
    return n.from && r.classList.add("cm-completionListIncompleteTop"), n.to < e.length && r.classList.add("cm-completionListIncompleteBottom"), r;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function F_(i, e) {
  return (t) => new G_(t, i, e);
}
function H_(i, e) {
  let t = i.getBoundingClientRect(), n = e.getBoundingClientRect(), r = t.height / i.offsetHeight;
  n.top < t.top ? i.scrollTop -= (t.top - n.top) / r : n.bottom > t.bottom && (i.scrollTop += (n.bottom - t.bottom) / r);
}
function nO(i) {
  return (i.boost || 0) * 100 + (i.apply ? 10 : 0) + (i.info ? 5 : 0) + (i.type ? 1 : 0);
}
function K_(i, e) {
  let t = [], n = null, r = null, s = (h) => {
    t.push(h);
    let { section: f } = h.completion;
    if (f) {
      n || (n = []);
      let u = typeof f == "string" ? f : f.name;
      n.some((d) => d.name == u) || n.push(typeof f == "string" ? { name: u } : f);
    }
  }, o = e.facet(ht);
  for (let h of i)
    if (h.hasResult()) {
      let f = h.result.getMatch;
      if (h.result.filter === !1)
        for (let u of h.result.options)
          s(new eO(u, h.source, f ? f(u) : [], 1e9 - t.length));
      else {
        let u = e.sliceDoc(h.from, h.to), d, p = o.filterStrict ? new W_(u) : new q_(u);
        for (let O of h.result.options)
          if (d = p.match(O.label)) {
            let m = O.displayLabel ? f ? f(O, d.matched) : [] : d.matched, g = d.score + (O.boost || 0);
            if (s(new eO(O, h.source, m, g)), typeof O.section == "object" && O.section.rank === "dynamic") {
              let { name: v } = O.section;
              r || (r = /* @__PURE__ */ Object.create(null)), r[v] = Math.max(g, r[v] || -1e9);
            }
          }
      }
    }
  if (n) {
    let h = /* @__PURE__ */ Object.create(null), f = 0, u = (d, p) => (d.rank === "dynamic" && p.rank === "dynamic" ? r[p.name] - r[d.name] : 0) || (typeof d.rank == "number" ? d.rank : 1e9) - (typeof p.rank == "number" ? p.rank : 1e9) || (d.name < p.name ? -1 : 1);
    for (let d of n.sort(u))
      f -= 1e5, h[d.name] = f;
    for (let d of t) {
      let { section: p } = d.completion;
      p && (d.score += h[typeof p == "string" ? p : p.name]);
    }
  }
  let a = [], l = null, c = o.compareCompletions;
  for (let h of t.sort((f, u) => u.score - f.score || c(f.completion, u.completion))) {
    let f = h.completion;
    !l || l.label != f.label || l.detail != f.detail || l.type != null && f.type != null && l.type != f.type || l.apply != f.apply || l.boost != f.boost ? a.push(h) : nO(h.completion) > nO(l) && (a[a.length - 1] = h), l = h.completion;
  }
  return a;
}
class Dr {
  constructor(e, t, n, r, s, o) {
    this.options = e, this.attrs = t, this.tooltip = n, this.timestamp = r, this.selected = s, this.disabled = o;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new Dr(this.options, rO(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, n, r, s, o) {
    if (r && !o && e.some((c) => c.isPending))
      return r.setDisabled();
    let a = K_(e, t);
    if (!a.length)
      return r && e.some((c) => c.isPending) ? r.setDisabled() : null;
    let l = t.facet(ht).selectOnOpen ? 0 : -1;
    if (r && r.selected != l && r.selected != -1) {
      let c = r.options[r.selected].completion;
      for (let h = 0; h < a.length; h++)
        if (a[h].completion == c) {
          l = h;
          break;
        }
    }
    return new Dr(a, rO(n, l), {
      pos: e.reduce((c, h) => h.hasResult() ? Math.min(c, h.from) : c, 1e8),
      create: rP,
      above: s.aboveCursor
    }, r ? r.timestamp : Date.now(), l, !1);
  }
  map(e) {
    return new Dr(this.options, this.attrs, { ...this.tooltip, pos: e.mapPos(this.tooltip.pos) }, this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new Dr(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class ll {
  constructor(e, t, n) {
    this.active = e, this.id = t, this.open = n;
  }
  static start() {
    return new ll(iP, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, n = t.facet(ht), s = (n.override || t.languageDataAt("autocomplete", fr(t)).map(V_)).map((l) => (this.active.find((h) => h.source == l) || new fi(
      l,
      this.active.some(
        (h) => h.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, n));
    s.length == this.active.length && s.every((l, c) => l == this.active[c]) && (s = this.active);
    let o = this.open, a = e.effects.some((l) => l.is(mu));
    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !J_(s, this.active) || a ? o = Dr.build(s, t, this.id, o, n, a) : o && o.disabled && !s.some((l) => l.isPending) && (o = null), !o && s.every((l) => !l.isPending) && s.some((l) => l.hasResult()) && (s = s.map((l) => l.hasResult() ? new fi(
      l.source,
      0
      /* State.Inactive */
    ) : l));
    for (let l of e.effects)
      l.is(ab) && (o = o && o.setSelected(l.value, this.id));
    return s == this.active && o == this.open ? this : new ll(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? eP : tP;
  }
}
function J_(i, e) {
  if (i == e)
    return !0;
  for (let t = 0, n = 0; ; ) {
    for (; t < i.length && !i[t].hasResult(); )
      t++;
    for (; n < e.length && !e[n].hasResult(); )
      n++;
    let r = t == i.length, s = n == e.length;
    if (r || s)
      return r == s;
    if (i[t++].result != e[n++].result)
      return !1;
  }
}
const eP = {
  "aria-autocomplete": "list"
}, tP = {};
function rO(i, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": i
  };
  return e > -1 && (t["aria-activedescendant"] = i + "-" + e), t;
}
const iP = [];
function ob(i, e) {
  if (i.isUserEvent("input.complete")) {
    let n = i.annotation(Ou);
    if (n && e.activateOnCompletion(n))
      return 12;
  }
  let t = i.isUserEvent("input.type");
  return t && e.activateOnTyping ? 5 : t ? 1 : i.isUserEvent("delete.backward") ? 2 : i.selection ? 8 : i.docChanged ? 16 : 0;
}
class fi {
  constructor(e, t, n = !1) {
    this.source = e, this.state = t, this.explicit = n;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, t) {
    let n = ob(e, t), r = this;
    (n & 8 || n & 16 && this.touches(e)) && (r = new fi(
      r.source,
      0
      /* State.Inactive */
    )), n & 4 && r.state == 0 && (r = new fi(
      this.source,
      1
      /* State.Pending */
    )), r = r.updateFor(e, n);
    for (let s of e.effects)
      if (s.is(al))
        r = new fi(r.source, 1, s.value);
      else if (s.is(go))
        r = new fi(
          r.source,
          0
          /* State.Inactive */
        );
      else if (s.is(mu))
        for (let o of s.value)
          o.source == r.source && (r = o);
    return r;
  }
  updateFor(e, t) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange(fr(e.state));
  }
}
class Vr extends fi {
  constructor(e, t, n, r, s, o) {
    super(e, 3, t), this.limit = n, this.result = r, this.from = s, this.to = o;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, t) {
    var n;
    if (!(t & 3))
      return this.map(e.changes);
    let r = this.result;
    r.map && !e.changes.empty && (r = r.map(r, e.changes));
    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), a = fr(e.state);
    if (a > o || !r || t & 2 && (fr(e.startState) == this.from || a < this.limit))
      return new fi(
        this.source,
        t & 4 ? 1 : 0
        /* State.Inactive */
      );
    let l = e.changes.mapPos(this.limit);
    return nP(r.validFor, e.state, s, o) ? new Vr(this.source, this.explicit, l, r, s, o) : r.update && (r = r.update(r, s, o, new nb(e.state, a, !1))) ? new Vr(this.source, this.explicit, l, r, r.from, (n = r.to) !== null && n !== void 0 ? n : fr(e.state)) : new fi(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new Vr(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new fi(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function nP(i, e, t, n) {
  if (!i)
    return !1;
  let r = e.sliceDoc(t, n);
  return typeof i == "function" ? i(r, t, n, e) : sb(i, !0).test(r);
}
const mu = /* @__PURE__ */ ge.define({
  map(i, e) {
    return i.map((t) => t.map(e));
  }
}), ab = /* @__PURE__ */ ge.define(), Nt = /* @__PURE__ */ ft.define({
  create() {
    return ll.start();
  },
  update(i, e) {
    return i.update(e);
  },
  provide: (i) => [
    Kf.from(i, (e) => e.tooltip),
    ae.contentAttributes.from(i, (e) => e.attrs)
  ]
});
function gu(i, e) {
  const t = e.completion.apply || e.completion.label;
  let n = i.state.field(Nt).active.find((r) => r.source == e.source);
  return n instanceof Vr ? (typeof t == "string" ? i.dispatch({
    ...N_(i.state, t, n.from, n.to),
    annotations: Ou.of(e.completion)
  }) : t(i, e.completion, n.from, n.to), !0) : !1;
}
const rP = /* @__PURE__ */ F_(Nt, gu);
function ha(i, e = "option") {
  return (t) => {
    let n = t.state.field(Nt, !1);
    if (!n || !n.open || n.open.disabled || Date.now() - n.open.timestamp < t.state.facet(ht).interactionDelay)
      return !1;
    let r = 1, s;
    e == "page" && (s = z0(t, n.open.tooltip)) && (r = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = n.open.options, a = n.open.selected > -1 ? n.open.selected + r * (i ? 1 : -1) : i ? 0 : o - 1;
    return a < 0 ? a = e == "page" ? 0 : o - 1 : a >= o && (a = e == "page" ? o - 1 : 0), t.dispatch({ effects: ab.of(a) }), !0;
  };
}
const sP = (i) => {
  let e = i.state.field(Nt, !1);
  return i.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < i.state.facet(ht).interactionDelay ? !1 : gu(i, e.open.options[e.open.selected]);
}, Rc = (i) => i.state.field(Nt, !1) ? (i.dispatch({ effects: al.of(!0) }), !0) : !1, oP = (i) => {
  let e = i.state.field(Nt, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* State.Inactive */
  ) ? !1 : (i.dispatch({ effects: go.of(null) }), !0);
};
class aP {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const lP = 50, cP = 1e3, hP = /* @__PURE__ */ ot.fromClass(class {
  constructor(i) {
    this.view = i, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of i.state.field(Nt).active)
      e.isPending && this.startQuery(e);
  }
  update(i) {
    let e = i.state.field(Nt), t = i.state.facet(ht);
    if (!i.selectionSet && !i.docChanged && i.startState.field(Nt) == e)
      return;
    let n = i.transactions.some((s) => {
      let o = ob(s, t);
      return o & 8 || (s.selection || s.docChanged) && !(o & 3);
    });
    for (let s = 0; s < this.running.length; s++) {
      let o = this.running[s];
      if (n || o.context.abortOnDocChange && i.docChanged || o.updates.length + i.transactions.length > lP && Date.now() - o.time > cP) {
        for (let a of o.context.abortListeners)
          try {
            a();
          } catch (l) {
            Wt(this.view.state, l);
          }
        o.context.abortListeners = null, this.running.splice(s--, 1);
      } else
        o.updates.push(...i.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), i.transactions.some((s) => s.effects.some((o) => o.is(al))) && (this.pendingStart = !0);
    let r = this.pendingStart ? 50 : t.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((s) => s.isPending && !this.running.some((o) => o.active.source == s.source)) ? setTimeout(() => this.startUpdate(), r) : -1, this.composing != 0)
      for (let s of i.transactions)
        s.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && s.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: i } = this.view, e = i.field(Nt);
    for (let t of e.active)
      t.isPending && !this.running.some((n) => n.active.source == t.source) && this.startQuery(t);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(ht).updateSyncTime));
  }
  startQuery(i) {
    let { state: e } = this.view, t = fr(e), n = new nb(e, t, i.explicit, this.view), r = new aP(i, n);
    this.running.push(r), Promise.resolve(i.source(n)).then((s) => {
      r.context.aborted || (r.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: go.of(null) }), Wt(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((i) => i.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(ht).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var i;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(ht), n = this.view.state.field(Nt);
    for (let r = 0; r < this.running.length; r++) {
      let s = this.running[r];
      if (s.done === void 0)
        continue;
      if (this.running.splice(r--, 1), s.done) {
        let a = fr(s.updates.length ? s.updates[0].startState : this.view.state), l = Math.min(a, s.done.from + (s.active.explicit ? 0 : 1)), c = new Vr(s.active.source, s.active.explicit, l, s.done, s.done.from, (i = s.done.to) !== null && i !== void 0 ? i : a);
        for (let h of s.updates)
          c = c.update(h, t);
        if (c.hasResult()) {
          e.push(c);
          continue;
        }
      }
      let o = n.active.find((a) => a.source == s.active.source);
      if (o && o.isPending)
        if (s.done == null) {
          let a = new fi(
            s.active.source,
            0
            /* State.Inactive */
          );
          for (let l of s.updates)
            a = a.update(l, t);
          a.isPending || e.push(a);
        } else
          this.startQuery(o);
    }
    (e.length || n.open && n.open.disabled) && this.view.dispatch({ effects: mu.of(e) });
  }
}, {
  eventHandlers: {
    blur(i) {
      let e = this.view.state.field(Nt, !1);
      if (e && e.tooltip && this.view.state.facet(ht).closeOnBlur) {
        let t = e.open && z0(this.view, e.open.tooltip);
        (!t || !t.dom.contains(i.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: go.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: al.of(!1) }), 20), this.composing = 0;
    }
  }
}), fP = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), uP = /* @__PURE__ */ Wn.highest(/* @__PURE__ */ ae.domEventHandlers({
  keydown(i, e) {
    let t = e.state.field(Nt, !1);
    if (!t || !t.open || t.open.disabled || t.open.selected < 0 || i.key.length > 1 || i.ctrlKey && !(fP && i.altKey) || i.metaKey)
      return !1;
    let n = t.open.options[t.open.selected], r = t.active.find((o) => o.source == n.source), s = n.completion.commitCharacters || r.result.commitCharacters;
    return s && s.indexOf(i.key) > -1 && gu(e, n), !1;
  }
})), lb = /* @__PURE__ */ ae.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"Â·Â·Â·"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'Æ’'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'â—‹'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'â—Œ'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'ð‘¥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'ð¶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'ð‘¡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'âˆª'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'â–¡'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'ðŸ”‘ï¸Ž'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'â–¢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class dP {
  constructor(e, t, n, r) {
    this.field = e, this.line = t, this.from = n, this.to = r;
  }
}
class bu {
  constructor(e, t, n) {
    this.field = e, this.from = t, this.to = n;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, Ot.TrackDel), n = e.mapPos(this.to, 1, Ot.TrackDel);
    return t == null || n == null ? null : new bu(this.field, t, n);
  }
}
class yu {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let n = [], r = [t], s = e.doc.lineAt(t), o = /^\s*/.exec(s.text)[0];
    for (let l of this.lines) {
      if (n.length) {
        let c = o, h = /^\t*/.exec(l)[0].length;
        for (let f = 0; f < h; f++)
          c += e.facet(Ml);
        r.push(t + c.length - h), l = c + l.slice(h);
      }
      n.push(l), t += l.length + 1;
    }
    let a = this.fieldPositions.map((l) => new bu(l.field, r[l.line] + l.from, r[l.line] + l.to));
    return { text: n, ranges: a };
  }
  static parse(e) {
    let t = [], n = [], r = [], s;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(o); ) {
        let a = s[1] ? +s[1] : null, l = s[2] || s[3] || "", c = -1, h = l.replace(/\\[{}]/g, (f) => f[1]);
        for (let f = 0; f < t.length; f++)
          (a != null ? t[f].seq == a : h && t[f].name == h) && (c = f);
        if (c < 0) {
          let f = 0;
          for (; f < t.length && (a == null || t[f].seq != null && t[f].seq < a); )
            f++;
          t.splice(f, 0, { seq: a, name: h }), c = f;
          for (let u of r)
            u.field >= c && u.field++;
        }
        for (let f of r)
          if (f.line == n.length && f.from > s.index) {
            let u = s[2] ? 3 + (s[1] || "").length : 2;
            f.from -= u, f.to -= u;
          }
        r.push(new dP(c, n.length, s.index, s.index + h.length)), o = o.slice(0, s.index) + l + o.slice(s.index + s[0].length);
      }
      o = o.replace(/\\([{}])/g, (a, l, c) => {
        for (let h of r)
          h.line == n.length && h.from > c && (h.from--, h.to--);
        return l;
      }), n.push(o);
    }
    return new yu(n, r);
  }
}
let pP = /* @__PURE__ */ pe.widget({ widget: /* @__PURE__ */ new class extends Pn {
  toDOM() {
    let i = document.createElement("span");
    return i.className = "cm-snippetFieldPosition", i;
  }
  ignoreEvent() {
    return !1;
  }
}() }), OP = /* @__PURE__ */ pe.mark({ class: "cm-snippetField" });
class vs {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = pe.set(e.map((n) => (n.from == n.to ? pP : OP).range(n.from, n.to)), !0);
  }
  map(e) {
    let t = [];
    for (let n of this.ranges) {
      let r = n.map(e);
      if (!r)
        return null;
      t.push(r);
    }
    return new vs(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((n) => n.field == this.active && n.from <= t.from && n.to >= t.to));
  }
}
const Xo = /* @__PURE__ */ ge.define({
  map(i, e) {
    return i && i.map(e);
  }
}), mP = /* @__PURE__ */ ge.define(), bo = /* @__PURE__ */ ft.define({
  create() {
    return null;
  },
  update(i, e) {
    for (let t of e.effects) {
      if (t.is(Xo))
        return t.value;
      if (t.is(mP) && i)
        return new vs(i.ranges, t.value);
    }
    return i && e.docChanged && (i = i.map(e.changes)), i && e.selection && !i.selectionInsideField(e.selection) && (i = null), i;
  },
  provide: (i) => ae.decorations.from(i, (e) => e ? e.deco : pe.none)
});
function vu(i, e) {
  return q.create(i.filter((t) => t.field == e).map((t) => q.range(t.from, t.to)));
}
function gP(i) {
  let e = yu.parse(i);
  return (t, n, r, s) => {
    let { text: o, ranges: a } = e.instantiate(t.state, r), { main: l } = t.state.selection, c = {
      changes: { from: r, to: s == l.from ? l.to : s, insert: Re.of(o) },
      scrollIntoView: !0,
      annotations: n ? [Ou.of(n), st.userEvent.of("input.complete")] : void 0
    };
    if (a.length && (c.selection = vu(a, 0)), a.some((h) => h.field > 0)) {
      let h = new vs(a, 0), f = c.effects = [Xo.of(h)];
      t.state.field(bo, !1) === void 0 && f.push(ge.appendConfig.of([bo, wP, xP, lb]));
    }
    t.dispatch(t.state.update(c));
  };
}
function cb(i) {
  return ({ state: e, dispatch: t }) => {
    let n = e.field(bo, !1);
    if (!n || i < 0 && n.active == 0)
      return !1;
    let r = n.active + i, s = i > 0 && !n.ranges.some((o) => o.field == r + i);
    return t(e.update({
      selection: vu(n.ranges, r),
      effects: Xo.of(s ? null : new vs(n.ranges, r)),
      scrollIntoView: !0
    })), !0;
  };
}
const bP = ({ state: i, dispatch: e }) => i.field(bo, !1) ? (e(i.update({ effects: Xo.of(null) })), !0) : !1, yP = /* @__PURE__ */ cb(1), vP = /* @__PURE__ */ cb(-1), SP = [
  { key: "Tab", run: yP, shift: vP },
  { key: "Escape", run: bP }
], sO = /* @__PURE__ */ le.define({
  combine(i) {
    return i.length ? i[0] : SP;
  }
}), wP = /* @__PURE__ */ Wn.highest(/* @__PURE__ */ gs.compute([sO], (i) => i.facet(sO)));
function Bt(i, e) {
  return { ...e, apply: gP(i) };
}
const xP = /* @__PURE__ */ ae.domEventHandlers({
  mousedown(i, e) {
    let t = e.state.field(bo, !1), n;
    if (!t || (n = e.posAtCoords({ x: i.clientX, y: i.clientY })) == null)
      return !1;
    let r = t.ranges.find((s) => s.from <= n && s.to >= n);
    return !r || r.field == t.active ? !1 : (e.dispatch({
      selection: vu(t.ranges, r.field),
      effects: Xo.of(t.ranges.some((s) => s.field > r.field) ? new vs(t.ranges, r.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), yo = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, sr = /* @__PURE__ */ ge.define({
  map(i, e) {
    let t = e.mapPos(i, -1, Ot.TrackAfter);
    return t ?? void 0;
  }
}), Su = /* @__PURE__ */ new class extends Or {
}();
Su.startSide = 1;
Su.endSide = -1;
const hb = /* @__PURE__ */ ft.define({
  create() {
    return Te.empty;
  },
  update(i, e) {
    if (i = i.map(e.changes), e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head);
      i = i.update({ filter: (n) => n >= t.from && n <= t.to });
    }
    for (let t of e.effects)
      t.is(sr) && (i = i.update({ add: [Su.range(t.value, t.value + 1)] }));
    return i;
  }
});
function kP() {
  return [_P, hb];
}
const Ec = "()[]{}<>Â«Â»Â»Â«ï¼»ï¼½ï½›ï½";
function fb(i) {
  for (let e = 0; e < Ec.length; e += 2)
    if (Ec.charCodeAt(e) == i)
      return Ec.charAt(e + 1);
  return Df(i < 128 ? i : i + 1);
}
function ub(i, e) {
  return i.languageDataAt("closeBrackets", e)[0] || yo;
}
const QP = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), _P = /* @__PURE__ */ ae.inputHandler.of((i, e, t, n) => {
  if ((QP ? i.composing : i.compositionStarted) || i.state.readOnly)
    return !1;
  let r = i.state.selection.main;
  if (n.length > 2 || n.length == 2 && Bi(Yt(n, 0)) == 1 || e != r.from || t != r.to)
    return !1;
  let s = TP(i.state, n);
  return s ? (i.dispatch(s), !0) : !1;
}), PP = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let n = ub(i, i.selection.main.head).brackets || yo.brackets, r = null, s = i.changeByRange((o) => {
    if (o.empty) {
      let a = CP(i.doc, o.head);
      for (let l of n)
        if (l == a && Nl(i.doc, o.head) == fb(Yt(l, 0)))
          return {
            changes: { from: o.head - l.length, to: o.head + l.length },
            range: q.cursor(o.head - l.length)
          };
    }
    return { range: r = o };
  });
  return r || e(i.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !r;
}, $P = [
  { key: "Backspace", run: PP }
];
function TP(i, e) {
  let t = ub(i, i.selection.main.head), n = t.brackets || yo.brackets;
  for (let r of n) {
    let s = fb(Yt(r, 0));
    if (e == r)
      return s == r ? EP(i, r, n.indexOf(r + r + r) > -1, t) : AP(i, r, s, t.before || yo.before);
    if (e == s && db(i, i.selection.main.from))
      return RP(i, r, s);
  }
  return null;
}
function db(i, e) {
  let t = !1;
  return i.field(hb).between(0, i.doc.length, (n) => {
    n == e && (t = !0);
  }), t;
}
function Nl(i, e) {
  let t = i.sliceString(e, e + 2);
  return t.slice(0, Bi(Yt(t, 0)));
}
function CP(i, e) {
  let t = i.sliceString(e - 2, e);
  return Bi(Yt(t, 0)) == t.length ? t : t.slice(1);
}
function AP(i, e, t, n) {
  let r = null, s = i.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: t, from: o.to }],
        effects: sr.of(o.to + e.length),
        range: q.range(o.anchor + e.length, o.head + e.length)
      };
    let a = Nl(i.doc, o.head);
    return !a || /\s/.test(a) || n.indexOf(a) > -1 ? {
      changes: { insert: e + t, from: o.head },
      effects: sr.of(o.head + e.length),
      range: q.cursor(o.head + e.length)
    } : { range: r = o };
  });
  return r ? null : i.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function RP(i, e, t) {
  let n = null, r = i.changeByRange((s) => s.empty && Nl(i.doc, s.head) == t ? {
    changes: { from: s.head, to: s.head + t.length, insert: t },
    range: q.cursor(s.head + t.length)
  } : n = { range: s });
  return n ? null : i.update(r, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function EP(i, e, t, n) {
  let r = n.stringPrefixes || yo.stringPrefixes, s = null, o = i.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: sr.of(a.to + e.length),
        range: q.range(a.anchor + e.length, a.head + e.length)
      };
    let l = a.head, c = Nl(i.doc, l), h;
    if (c == e) {
      if (oO(i, l))
        return {
          changes: { insert: e + e, from: l },
          effects: sr.of(l + e.length),
          range: q.cursor(l + e.length)
        };
      if (db(i, l)) {
        let u = t && i.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + u.length, insert: u },
          range: q.cursor(l + u.length)
        };
      }
    } else {
      if (t && i.sliceDoc(l - 2 * e.length, l) == e + e && (h = aO(i, l - 2 * e.length, r)) > -1 && oO(i, h))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: sr.of(l + e.length),
          range: q.cursor(l + e.length)
        };
      if (i.charCategorizer(l)(c) != Fe.Word && aO(i, l, r) > -1 && !MP(i, l, e, r))
        return {
          changes: { insert: e + e, from: l },
          effects: sr.of(l + e.length),
          range: q.cursor(l + e.length)
        };
    }
    return { range: s = a };
  });
  return s ? null : i.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function oO(i, e) {
  let t = Ke(i).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function MP(i, e, t, n) {
  let r = Ke(i).resolveInner(e, -1), s = n.reduce((o, a) => Math.max(o, a.length), 0);
  for (let o = 0; o < 5; o++) {
    let a = i.sliceDoc(r.from, Math.min(r.to, r.from + t.length + s)), l = a.indexOf(t);
    if (!l || l > -1 && n.indexOf(a.slice(0, l)) > -1) {
      let h = r.firstChild;
      for (; h && h.from == r.from && h.to - h.from > t.length + l; ) {
        if (i.sliceDoc(h.to - t.length, h.to) == t)
          return !1;
        h = h.firstChild;
      }
      return !0;
    }
    let c = r.to == e && r.parent;
    if (!c)
      break;
    r = c;
  }
  return !1;
}
function aO(i, e, t) {
  let n = i.charCategorizer(e);
  if (n(i.sliceDoc(e - 1, e)) != Fe.Word)
    return e;
  for (let r of t) {
    let s = e - r.length;
    if (i.sliceDoc(s, e) == r && n(i.sliceDoc(s - 1, s)) != Fe.Word)
      return s;
  }
  return -1;
}
function ZP(i = {}) {
  return [
    uP,
    Nt,
    ht.of(i),
    hP,
    XP,
    lb
  ];
}
const pb = [
  { key: "Ctrl-Space", run: Rc },
  { mac: "Alt-`", run: Rc },
  { mac: "Alt-i", run: Rc },
  { key: "Escape", run: oP },
  { key: "ArrowDown", run: /* @__PURE__ */ ha(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ ha(!1) },
  { key: "PageDown", run: /* @__PURE__ */ ha(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ ha(!1, "page") },
  { key: "Enter", run: sP }
], XP = /* @__PURE__ */ Wn.highest(/* @__PURE__ */ gs.computeN([ht], (i) => i.facet(ht).defaultKeymap ? [pb] : []));
class lO {
  constructor(e, t, n) {
    this.from = e, this.to = t, this.diagnostic = n;
  }
}
class ir {
  constructor(e, t, n) {
    this.diagnostics = e, this.panel = t, this.selected = n;
  }
  static init(e, t, n) {
    let r = n.facet(vo).markerFilter;
    r && (e = r(e, n));
    let s = e.slice().sort((d, p) => d.from - p.from || d.to - p.to), o = new wn(), a = [], l = 0, c = n.doc.iter(), h = 0, f = n.doc.length;
    for (let d = 0; ; ) {
      let p = d == s.length ? null : s[d];
      if (!p && !a.length)
        break;
      let O, m;
      if (a.length)
        O = l, m = a.reduce((S, w) => Math.min(S, w.to), p && p.from > O ? p.from : 1e8);
      else {
        if (O = p.from, O > f)
          break;
        m = p.to, a.push(p), d++;
      }
      for (; d < s.length; ) {
        let S = s[d];
        if (S.from == O && (S.to > S.from || S.to == O))
          a.push(S), d++, m = Math.min(S.to, m);
        else {
          m = Math.min(S.from, m);
          break;
        }
      }
      m = Math.min(m, f);
      let g = !1;
      if (a.some((S) => S.from == O && (S.to == m || m == f)) && (g = O == m, !g && m - O < 10)) {
        let S = O - (h + c.value.length);
        S > 0 && (c.next(S), h = O);
        for (let w = O; ; ) {
          if (w >= m) {
            g = !0;
            break;
          }
          if (!c.lineBreak && h + c.value.length > w)
            break;
          w = h + c.value.length, h += c.value.length, c.next();
        }
      }
      let v = GP(a);
      if (g)
        o.add(O, O, pe.widget({
          widget: new qP(v),
          diagnostics: a.slice()
        }));
      else {
        let S = a.reduce((w, x) => x.markClass ? w + " " + x.markClass : w, "");
        o.add(O, m, pe.mark({
          class: "cm-lintRange cm-lintRange-" + v + S,
          diagnostics: a.slice(),
          inclusiveEnd: a.some((w) => w.to > m)
        }));
      }
      if (l = m, l == f)
        break;
      for (let S = 0; S < a.length; S++)
        a[S].to <= l && a.splice(S--, 1);
    }
    let u = o.finish();
    return new ir(u, t, rs(u));
  }
}
function rs(i, e = null, t = 0) {
  let n = null;
  return i.between(t, 1e9, (r, s, { spec: o }) => {
    if (!(e && o.diagnostics.indexOf(e) < 0))
      if (!n)
        n = new lO(r, s, e || o.diagnostics[0]);
      else {
        if (o.diagnostics.indexOf(n.diagnostic) < 0)
          return !1;
        n = new lO(n.from, s, n.diagnostic);
      }
  }), n;
}
function zP(i, e) {
  let t = e.pos, n = e.end || t, r = i.state.facet(vo).hideOn(i, t, n);
  if (r != null)
    return r;
  let s = i.startState.doc.lineAt(e.pos);
  return !!(i.effects.some((o) => o.is(Ob)) || i.changes.touchesRange(s.from, Math.max(s.to, n)));
}
function DP(i, e) {
  return i.field(ti, !1) ? e : e.concat(ge.appendConfig.of(FP));
}
const Ob = /* @__PURE__ */ ge.define(), wu = /* @__PURE__ */ ge.define(), mb = /* @__PURE__ */ ge.define(), ti = /* @__PURE__ */ ft.define({
  create() {
    return new ir(pe.none, null, null);
  },
  update(i, e) {
    if (e.docChanged && i.diagnostics.size) {
      let t = i.diagnostics.map(e.changes), n = null, r = i.panel;
      if (i.selected) {
        let s = e.changes.mapPos(i.selected.from, 1);
        n = rs(t, i.selected.diagnostic, s) || rs(t, null, s);
      }
      !t.size && r && e.state.facet(vo).autoPanel && (r = null), i = new ir(t, r, n);
    }
    for (let t of e.effects)
      if (t.is(Ob)) {
        let n = e.state.facet(vo).autoPanel ? t.value.length ? So.open : null : i.panel;
        i = ir.init(t.value, n, e.state);
      } else t.is(wu) ? i = new ir(i.diagnostics, t.value ? So.open : null, i.selected) : t.is(mb) && (i = new ir(i.diagnostics, i.panel, t.value));
    return i;
  },
  provide: (i) => [
    ho.from(i, (e) => e.panel),
    ae.decorations.from(i, (e) => e.diagnostics)
  ]
}), LP = /* @__PURE__ */ pe.mark({ class: "cm-lintRange cm-lintRange-active" });
function IP(i, e, t) {
  let { diagnostics: n } = i.state.field(ti), r, s = -1, o = -1;
  n.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (l, c, { spec: h }) => {
    if (e >= l && e <= c && (l == c || (e > l || t > 0) && (e < c || t < 0)))
      return r = h.diagnostics, s = l, o = c, !1;
  });
  let a = i.state.facet(vo).tooltipFilter;
  return r && a && (r = a(r, i.state)), r ? {
    pos: s,
    end: o,
    above: i.state.doc.lineAt(s).to < o,
    create() {
      return { dom: BP(i, r) };
    }
  } : null;
}
function BP(i, e) {
  return De("ul", { class: "cm-tooltip-lint" }, e.map((t) => bb(i, t, !1)));
}
const YP = (i) => {
  let e = i.state.field(ti, !1);
  (!e || !e.panel) && i.dispatch({ effects: DP(i.state, [wu.of(!0)]) });
  let t = co(i, So.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, cO = (i) => {
  let e = i.state.field(ti, !1);
  return !e || !e.panel ? !1 : (i.dispatch({ effects: wu.of(!1) }), !0);
}, NP = (i) => {
  let e = i.state.field(ti, !1);
  if (!e)
    return !1;
  let t = i.state.selection.main, n = e.diagnostics.iter(t.to + 1);
  return !n.value && (n = e.diagnostics.iter(0), !n.value || n.from == t.from && n.to == t.to) ? !1 : (i.dispatch({ selection: { anchor: n.from, head: n.to }, scrollIntoView: !0 }), !0);
}, VP = [
  { key: "Mod-Shift-m", run: YP, preventDefault: !0 },
  { key: "F8", run: NP }
], vo = /* @__PURE__ */ le.define({
  combine(i) {
    return {
      sources: i.map((e) => e.source).filter((e) => e != null),
      ...sn(i.map((e) => e.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null,
        needsRefresh: null,
        hideOn: () => null
      }, {
        delay: Math.max,
        markerFilter: hO,
        tooltipFilter: hO,
        needsRefresh: (e, t) => e ? t ? (n) => e(n) || t(n) : e : t,
        hideOn: (e, t) => e ? t ? (n, r, s) => e(n, r, s) || t(n, r, s) : e : t,
        autoPanel: (e, t) => e || t
      })
    };
  }
});
function hO(i, e) {
  return i ? e ? (t, n) => e(i(t, n), n) : i : e;
}
function gb(i) {
  let e = [];
  if (i)
    e: for (let { name: t } of i) {
      for (let n = 0; n < t.length; n++) {
        let r = t[n];
        if (/[a-zA-Z]/.test(r) && !e.some((s) => s.toLowerCase() == r.toLowerCase())) {
          e.push(r);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function bb(i, e, t) {
  var n;
  let r = t ? gb(e.actions) : [];
  return De("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, De("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(i) : e.message), (n = e.actions) === null || n === void 0 ? void 0 : n.map((s, o) => {
    let a = !1, l = (d) => {
      if (d.preventDefault(), a)
        return;
      a = !0;
      let p = rs(i.state.field(ti).diagnostics, e);
      p && s.apply(i, p.from, p.to);
    }, { name: c } = s, h = r[o] ? c.indexOf(r[o]) : -1, f = h < 0 ? c : [
      c.slice(0, h),
      De("u", c.slice(h, h + 1)),
      c.slice(h + 1)
    ], u = s.markClass ? " " + s.markClass : "";
    return De("button", {
      type: "button",
      class: "cm-diagnosticAction" + u,
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${c}${h < 0 ? "" : ` (access key "${r[o]})"`}.`
    }, f);
  }), e.source && De("div", { class: "cm-diagnosticSource" }, e.source));
}
class qP extends Pn {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return De("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class fO {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = bb(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class So {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (r) => {
      if (r.keyCode == 27)
        cO(this.view), this.view.focus();
      else if (r.keyCode == 38 || r.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (r.keyCode == 40 || r.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (r.keyCode == 36)
        this.moveSelection(0);
      else if (r.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (r.keyCode == 13)
        this.view.focus();
      else if (r.keyCode >= 65 && r.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], o = gb(s.actions);
        for (let a = 0; a < o.length; a++)
          if (o[a].toUpperCase().charCodeAt(0) == r.keyCode) {
            let l = rs(this.view.state.field(ti).diagnostics, s);
            l && s.actions[a].apply(e, l.from, l.to);
          }
      } else
        return;
      r.preventDefault();
    }, n = (r) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(r.target) && this.moveSelection(s);
    };
    this.list = De("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: n
    }), this.dom = De("div", { class: "cm-panel-lint" }, this.list, De("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => cO(this.view)
    }, "Ã—")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(ti).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(ti), n = 0, r = !1, s = null, o = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (a, l, { spec: c }) => {
      for (let h of c.diagnostics) {
        if (o.has(h))
          continue;
        o.add(h);
        let f = -1, u;
        for (let d = n; d < this.items.length; d++)
          if (this.items[d].diagnostic == h) {
            f = d;
            break;
          }
        f < 0 ? (u = new fO(this.view, h), this.items.splice(n, 0, u), r = !0) : (u = this.items[f], f > n && (this.items.splice(n, f - n), r = !0)), t && u.diagnostic == t.diagnostic ? u.dom.hasAttribute("aria-selected") || (u.dom.setAttribute("aria-selected", "true"), s = u) : u.dom.hasAttribute("aria-selected") && u.dom.removeAttribute("aria-selected"), n++;
      }
    }); n < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      r = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new fO(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), r = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: a, panel: l }) => {
        let c = l.height / this.list.offsetHeight;
        a.top < l.top ? this.list.scrollTop -= (l.top - a.top) / c : a.bottom > l.bottom && (this.list.scrollTop += (a.bottom - l.bottom) / c);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), r && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let n = e;
      e = n.nextSibling, n.remove();
    }
    for (let n of this.items)
      if (n.dom.parentNode == this.list) {
        for (; e != n.dom; )
          t();
        e = n.dom.nextSibling;
      } else
        this.list.insertBefore(n.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(ti), n = rs(t.diagnostics, this.items[e].diagnostic);
    n && this.view.dispatch({
      selection: { anchor: n.from, head: n.to },
      scrollIntoView: !0,
      effects: mb.of(n)
    });
  }
  static open(e) {
    return new So(e);
  }
}
function WP(i, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(i)}</svg>')`;
}
function fa(i) {
  return WP(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${i}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const jP = /* @__PURE__ */ ae.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ fa("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ fa("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ fa("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ fa("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function UP(i) {
  return i == "error" ? 4 : i == "warning" ? 3 : i == "info" ? 2 : 1;
}
function GP(i) {
  let e = "hint", t = 1;
  for (let n of i) {
    let r = UP(n.severity);
    r > t && (t = r, e = n.severity);
  }
  return e;
}
const FP = [
  ti,
  /* @__PURE__ */ ae.decorations.compute([ti], (i) => {
    let { selected: e, panel: t } = i.field(ti);
    return !e || !t || e.from == e.to ? pe.none : pe.set([
      LP.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ Rk(IP, { hideOn: zP }),
  jP
], HP = [
  Nk(),
  Wk(),
  Z0(),
  m1(),
  IQ(),
  R0(),
  rk(),
  $e.allowMultipleSelections.of(!0),
  PQ(),
  au(l1, { fallback: !0 }),
  FQ(),
  kP(),
  ZP(),
  Sk(),
  kk(),
  Ok(),
  b_(),
  gs.of([
    ...$P,
    ...j1,
    ...z_,
    ...v1,
    ...XQ,
    ...pb,
    ...VP
  ])
], yb = [
  Z0(),
  m1(),
  R0(),
  au(l1, { fallback: !0 }),
  gs.of([
    ...j1,
    ...v1
  ])
];
class cl {
  /**
  @internal
  */
  constructor(e, t, n, r, s, o, a, l, c, h = 0, f) {
    this.p = e, this.stack = t, this.state = n, this.reducePos = r, this.pos = s, this.score = o, this.buffer = a, this.bufferBase = l, this.curContext = c, this.lookAhead = h, this.parent = f;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, t, n = 0) {
    let r = e.parser.context;
    return new cl(e, [], t, n, n, 0, [], 0, r ? new uO(r, r.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, t) {
    this.stack.push(this.state, t, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var t;
    let n = e >> 19, r = e & 65535, { parser: s } = this.p, o = this.reducePos < this.pos - 25;
    o && this.setLookAhead(this.pos);
    let a = s.dynamicPrecedence(r);
    if (a && (this.score += a), n == 0) {
      this.pushState(s.getGoto(this.state, r, !0), this.reducePos), r < s.minRepeatTerm && this.storeNode(r, this.reducePos, this.reducePos, o ? 8 : 4, !0), this.reduceContext(r, this.reducePos);
      return;
    }
    let l = this.stack.length - (n - 1) * 3 - (e & 262144 ? 6 : 0), c = l ? this.stack[l - 2] : this.p.ranges[0].from, h = this.reducePos - c;
    h >= 2e3 && !(!((t = this.p.parser.nodeSet.types[r]) === null || t === void 0) && t.isAnonymous) && (c == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = h) : this.p.lastBigReductionSize < h && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = c, this.p.lastBigReductionSize = h));
    let f = l ? this.stack[l - 1] : 0, u = this.bufferBase + this.buffer.length - f;
    if (r < s.minRepeatTerm || e & 131072) {
      let d = s.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(r, c, d, u + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[l];
    else {
      let d = this.stack[l - 3];
      this.state = s.getGoto(d, r, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(r, c);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, t, n, r = 4, s = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this, a = this.buffer.length;
      if (a == 0 && o.parent && (a = o.bufferBase - o.parent.bufferBase, o = o.parent), a > 0 && o.buffer[a - 4] == 0 && o.buffer[a - 1] > -1) {
        if (t == n)
          return;
        if (o.buffer[a - 2] >= t) {
          o.buffer[a - 2] = n;
          return;
        }
      }
    }
    if (!s || this.pos == n)
      this.buffer.push(e, t, n, r);
    else {
      let o = this.buffer.length;
      if (o > 0 && (this.buffer[o - 4] != 0 || this.buffer[o - 1] < 0)) {
        let a = !1;
        for (let l = o; l > 0 && this.buffer[l - 2] > n; l -= 4)
          if (this.buffer[l - 1] >= 0) {
            a = !0;
            break;
          }
        if (a)
          for (; o > 0 && this.buffer[o - 2] > n; )
            this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, r > 4 && (r -= 4);
      }
      this.buffer[o] = e, this.buffer[o + 1] = t, this.buffer[o + 2] = n, this.buffer[o + 3] = r;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, t, n, r) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if ((e & 262144) == 0) {
      let s = e, { parser: o } = this.p;
      (r > this.pos || t <= o.maxNode) && (this.pos = r, o.stateFlag(
        s,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = r)), this.pushState(s, n), this.shiftContext(t, n), t <= o.maxNode && this.buffer.push(t, n, r, 4);
    } else
      this.pos = r, this.shiftContext(t, n), t <= this.p.parser.maxNode && this.buffer.push(t, n, r, 4);
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, t, n, r) {
    e & 65536 ? this.reduce(e) : this.shift(e, t, n, r);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, t) {
    let n = this.p.reused.length - 1;
    (n < 0 || this.p.reused[n] != e) && (this.p.reused.push(e), n++);
    let r = this.pos;
    this.reducePos = this.pos = r + e.length, this.pushState(t, r), this.buffer.push(
      n,
      r,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, t = e.buffer.length;
    for (; t > 0 && e.buffer[t - 2] > e.reducePos; )
      t -= 4;
    let n = e.buffer.slice(t), r = e.bufferBase + t;
    for (; e && r == e.bufferBase; )
      e = e.parent;
    return new cl(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, n, r, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, t) {
    let n = e <= this.p.parser.maxNode;
    n && this.storeNode(e, this.pos, t, 4), this.storeNode(0, this.pos, t, n ? 8 : 4), this.pos = this.reducePos = t, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let t = new KP(this); ; ) {
      let n = this.p.parser.stateSlot(
        t.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(t.state, e);
      if (n == 0)
        return !1;
      if ((n & 65536) == 0)
        return !0;
      t.reduce(n);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let t = this.p.parser.nextStates(this.state);
    if (t.length > 8 || this.stack.length >= 120) {
      let r = [];
      for (let s = 0, o; s < t.length; s += 2)
        (o = t[s + 1]) != this.state && this.p.parser.hasAction(o, e) && r.push(t[s], o);
      if (this.stack.length < 120)
        for (let s = 0; r.length < 8 && s < t.length; s += 2) {
          let o = t[s + 1];
          r.some((a, l) => l & 1 && a == o) || r.push(t[s], o);
        }
      t = r;
    }
    let n = [];
    for (let r = 0; r < t.length && n.length < 4; r += 2) {
      let s = t[r + 1];
      if (s == this.state)
        continue;
      let o = this.split();
      o.pushState(s, this.pos), o.storeNode(0, o.pos, o.pos, 4, !0), o.shiftContext(t[r], this.pos), o.reducePos = this.pos, o.score -= 200, n.push(o);
    }
    return n;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, t = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((t & 65536) == 0)
      return !1;
    if (!e.validAction(this.state, t)) {
      let n = t >> 19, r = t & 65535, s = this.stack.length - n * 3;
      if (s < 0 || e.getGoto(this.stack[s], r, !1) < 0) {
        let o = this.findForcedReduction();
        if (o == null)
          return !1;
        t = o;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(t), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, t = [], n = (r, s) => {
      if (!t.includes(r))
        return t.push(r), e.allActions(r, (o) => {
          if (!(o & 393216)) if (o & 65536) {
            let a = (o >> 19) - s;
            if (a > 1) {
              let l = o & 65535, c = this.stack.length - a * 3;
              if (c >= 0 && e.getGoto(this.stack[c], l, !1) >= 0)
                return a << 19 | 65536 | l;
            }
          } else {
            let a = n(o, s + 1);
            if (a != null)
              return a;
          }
        });
    };
    return n(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let t = 0; t < this.stack.length; t += 3)
      if (this.stack[t] != e.stack[t])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  reduceContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let t = new uO(this.curContext.tracker, e);
      t.hash != this.curContext.hash && this.emitContext(), this.curContext = t;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class uO {
  constructor(e, t) {
    this.tracker = e, this.context = t, this.hash = e.strict ? e.hash(t) : 0;
  }
}
class KP {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let t = e & 65535, n = e >> 19;
    n == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (n - 1) * 3;
    let r = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
    this.state = r;
  }
}
class hl {
  constructor(e, t, n) {
    this.stack = e, this.pos = t, this.index = n, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, t = e.bufferBase + e.buffer.length) {
    return new hl(e, t, t - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new hl(this.stack, this.pos, this.index);
  }
}
function Vs(i, e = Uint16Array) {
  if (typeof i != "string")
    return i;
  let t = null;
  for (let n = 0, r = 0; n < i.length; ) {
    let s = 0;
    for (; ; ) {
      let o = i.charCodeAt(n++), a = !1;
      if (o == 126) {
        s = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let l = o - 32;
      if (l >= 46 && (l -= 46, a = !0), s += l, a)
        break;
      s *= 46;
    }
    t ? t[r++] = s : t = new e(s);
  }
  return t;
}
class Aa {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const dO = new Aa();
class JP {
  /**
  @internal
  */
  constructor(e, t) {
    this.input = e, this.ranges = t, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = dO, this.rangeIndex = 0, this.pos = this.chunkPos = t[0].from, this.range = t[0], this.end = t[t.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, t) {
    let n = this.range, r = this.rangeIndex, s = this.pos + e;
    for (; s < n.from; ) {
      if (!r)
        return null;
      let o = this.ranges[--r];
      s -= n.from - o.to, n = o;
    }
    for (; t < 0 ? s > n.to : s >= n.to; ) {
      if (r == this.ranges.length - 1)
        return null;
      let o = this.ranges[++r];
      s += o.from - n.to, n = o;
    }
    return s;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let t of this.ranges)
      if (t.to > e)
        return Math.max(e, t.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingâ€”when looking forwardâ€”or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let t = this.chunkOff + e, n, r;
    if (t >= 0 && t < this.chunk.length)
      n = this.pos + e, r = this.chunk.charCodeAt(t);
    else {
      let s = this.resolveOffset(e, 1);
      if (s == null)
        return -1;
      if (n = s, n >= this.chunk2Pos && n < this.chunk2Pos + this.chunk2.length)
        r = this.chunk2.charCodeAt(n - this.chunk2Pos);
      else {
        let o = this.rangeIndex, a = this.range;
        for (; a.to <= n; )
          a = this.ranges[++o];
        this.chunk2 = this.input.chunk(this.chunk2Pos = n), n + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - n)), r = this.chunk2.charCodeAt(0);
      }
    }
    return n >= this.token.lookAhead && (this.token.lookAhead = n + 1), r;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, t = 0) {
    let n = t ? this.resolveOffset(t, -1) : this.pos;
    if (n == null || n < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = n;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, t) {
    this.token.value = e, this.token.end = t;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: t } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = t, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), t = this.pos + e.length;
      this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, t) {
    if (t ? (this.token = t, t.start = e, t.lookAhead = e + 1, t.value = t.extended = -1) : this.token = dO, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, t) {
    if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
    if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
    if (e >= this.range.from && t <= this.range.to)
      return this.input.read(e, t);
    let n = "";
    for (let r of this.ranges) {
      if (r.from >= t)
        break;
      r.to > e && (n += this.input.read(Math.max(r.from, e), Math.min(r.to, t)));
    }
    return n;
  }
}
class qr {
  constructor(e, t) {
    this.data = e, this.id = t;
  }
  token(e, t) {
    let { parser: n } = t.p;
    vb(this.data, e, t, this.id, n.data, n.tokenPrecTable);
  }
}
qr.prototype.contextual = qr.prototype.fallback = qr.prototype.extend = !1;
class fl {
  constructor(e, t, n) {
    this.precTable = t, this.elseToken = n, this.data = typeof e == "string" ? Vs(e) : e;
  }
  token(e, t) {
    let n = e.pos, r = 0;
    for (; ; ) {
      let s = e.next < 0, o = e.resolveOffset(1, 1);
      if (vb(this.data, e, t, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (s || r++, o == null)
        break;
      e.reset(o, e.token);
    }
    r && (e.reset(n, e.token), e.acceptToken(this.elseToken, r));
  }
}
fl.prototype.contextual = qr.prototype.fallback = qr.prototype.extend = !1;
class si {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, t = {}) {
    this.token = e, this.contextual = !!t.contextual, this.fallback = !!t.fallback, this.extend = !!t.extend;
  }
}
function vb(i, e, t, n, r, s) {
  let o = 0, a = 1 << n, { dialect: l } = t.p.parser;
  e: for (; (a & i[o]) != 0; ) {
    let c = i[o + 1];
    for (let d = o + 3; d < c; d += 2)
      if ((i[d + 1] & a) > 0) {
        let p = i[d];
        if (l.allows(p) && (e.token.value == -1 || e.token.value == p || e$(p, e.token.value, r, s))) {
          e.acceptToken(p);
          break;
        }
      }
    let h = e.next, f = 0, u = i[o + 2];
    if (e.next < 0 && u > f && i[c + u * 3 - 3] == 65535) {
      o = i[c + u * 3 - 1];
      continue e;
    }
    for (; f < u; ) {
      let d = f + u >> 1, p = c + d + (d << 1), O = i[p], m = i[p + 1] || 65536;
      if (h < O)
        u = d;
      else if (h >= m)
        f = d + 1;
      else {
        o = i[p + 2], e.advance();
        continue e;
      }
    }
    break;
  }
}
function pO(i, e, t) {
  for (let n = e, r; (r = i[n]) != 65535; n++)
    if (r == t)
      return n - e;
  return -1;
}
function e$(i, e, t, n) {
  let r = pO(t, n, e);
  return r < 0 || pO(t, n, i) < r;
}
const Ft = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let Mc = null;
function OO(i, e, t) {
  let n = i.cursor(Ye.IncludeAnonymous);
  for (n.moveTo(e); ; )
    if (!(t < 0 ? n.childBefore(e) : n.childAfter(e)))
      for (; ; ) {
        if ((t < 0 ? n.to < e : n.from > e) && !n.type.isError)
          return t < 0 ? Math.max(0, Math.min(
            n.to - 1,
            e - 25
            /* Lookahead.Margin */
          )) : Math.min(i.length, Math.max(
            n.from + 1,
            e + 25
            /* Lookahead.Margin */
          ));
        if (t < 0 ? n.prevSibling() : n.nextSibling())
          break;
        if (!n.parent())
          return t < 0 ? 0 : i.length;
      }
}
class t$ {
  constructor(e, t) {
    this.fragments = e, this.nodeSet = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? OO(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? OO(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let t = this.trees.length - 1;
      if (t < 0)
        return this.nextFragment(), null;
      let n = this.trees[t], r = this.index[t];
      if (r == n.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let s = n.children[r], o = this.start[t] + n.positions[r];
      if (o > e)
        return this.nextStart = o, null;
      if (s instanceof He) {
        if (o == e) {
          if (o < this.safeFrom)
            return null;
          let a = o + s.length;
          if (a <= this.safeTo) {
            let l = s.prop(Se.lookAhead);
            if (!l || a + l < this.fragment.to)
              return s;
          }
        }
        this.index[t]++, o + s.length >= Math.max(this.safeFrom, e) && (this.trees.push(s), this.start.push(o), this.index.push(0));
      } else
        this.index[t]++, this.nextStart = o + s.length;
    }
  }
}
class i$ {
  constructor(e, t) {
    this.stream = t, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((n) => new Aa());
  }
  getActions(e) {
    let t = 0, n = null, { parser: r } = e.p, { tokenizers: s } = r, o = r.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), a = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let c = 0; c < s.length; c++) {
      if ((1 << c & o) == 0)
        continue;
      let h = s[c], f = this.tokens[c];
      if (!(n && !h.fallback) && ((h.contextual || f.start != e.pos || f.mask != o || f.context != a) && (this.updateCachedToken(f, h, e), f.mask = o, f.context = a), f.lookAhead > f.end + 25 && (l = Math.max(f.lookAhead, l)), f.value != 0)) {
        let u = t;
        if (f.extended > -1 && (t = this.addActions(e, f.extended, f.end, t)), t = this.addActions(e, f.value, f.end, t), !h.extend && (n = f, t > u))
          break;
      }
    }
    for (; this.actions.length > t; )
      this.actions.pop();
    return l && e.setLookAhead(l), !n && e.pos == this.stream.end && (n = new Aa(), n.value = e.p.parser.eofTerm, n.start = n.end = e.pos, t = this.addActions(e, n.value, n.end, t)), this.mainToken = n, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let t = new Aa(), { pos: n, p: r } = e;
    return t.start = n, t.end = Math.min(n + 1, r.stream.end), t.value = n == r.stream.end ? r.parser.eofTerm : 0, t;
  }
  updateCachedToken(e, t, n) {
    let r = this.stream.clipPos(n.pos);
    if (t.token(this.stream.reset(r, e), n), e.value > -1) {
      let { parser: s } = n.p;
      for (let o = 0; o < s.specialized.length; o++)
        if (s.specialized[o] == e.value) {
          let a = s.specializers[o](this.stream.read(e.start, e.end), n);
          if (a >= 0 && n.p.parser.dialect.allows(a >> 1)) {
            (a & 1) == 0 ? e.value = a >> 1 : e.extended = a >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(r + 1);
  }
  putAction(e, t, n, r) {
    for (let s = 0; s < r; s += 3)
      if (this.actions[s] == e)
        return r;
    return this.actions[r++] = e, this.actions[r++] = t, this.actions[r++] = n, r;
  }
  addActions(e, t, n, r) {
    let { state: s } = e, { parser: o } = e.p, { data: a } = o;
    for (let l = 0; l < 2; l++)
      for (let c = o.stateSlot(
        s,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; c += 3) {
        if (a[c] == 65535)
          if (a[c + 1] == 1)
            c = dn(a, c + 2);
          else {
            r == 0 && a[c + 1] == 2 && (r = this.putAction(dn(a, c + 2), t, n, r));
            break;
          }
        a[c] == t && (r = this.putAction(dn(a, c + 1), t, n, r));
      }
    return r;
  }
}
class n$ {
  constructor(e, t, n, r) {
    this.parser = e, this.input = t, this.ranges = r, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new JP(t, r), this.tokens = new i$(e, this.stream), this.topTerm = e.top[1];
    let { from: s } = r[0];
    this.stacks = [cl.start(this, e.top[0], s)], this.fragments = n.length && this.stream.end - s > e.bufferLength * 4 ? new t$(n, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, t = this.minStackPos, n = this.stacks = [], r, s;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [o] = e;
      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > t)
          n.push(a);
        else {
          if (this.advanceStack(a, n, e))
            continue;
          {
            r || (r = [], s = []), r.push(a);
            let l = this.tokens.getMainToken(a);
            s.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!n.length) {
      let o = r && s$(r);
      if (o)
        return Ft && console.log("Finish with " + this.stackID(o)), this.stackToTree(o);
      if (this.parser.strict)
        throw Ft && r && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + t);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && r) {
      let o = this.stoppedAt != null && r[0].pos > this.stoppedAt ? r[0] : this.runRecovery(r, s, n);
      if (o)
        return Ft && console.log("Force-finish " + this.stackID(o)), this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (n.length > o)
        for (n.sort((a, l) => l.score - a.score); n.length > o; )
          n.pop();
      n.some((a) => a.reducePos > t) && this.recovering--;
    } else if (n.length > 1) {
      e: for (let o = 0; o < n.length - 1; o++) {
        let a = n[o];
        for (let l = o + 1; l < n.length; l++) {
          let c = n[l];
          if (a.sameState(c) || a.buffer.length > 500 && c.buffer.length > 500)
            if ((a.score - c.score || a.buffer.length - c.buffer.length) > 0)
              n.splice(l--, 1);
            else {
              n.splice(o--, 1);
              continue e;
            }
        }
      }
      n.length > 12 && n.splice(
        12,
        n.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = n[0].pos;
    for (let o = 1; o < n.length; o++)
      n[o].pos < this.minStackPos && (this.minStackPos = n[o].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, t, n) {
    let r = e.pos, { parser: s } = this, o = Ft ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && r > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict, h = c ? e.curContext.hash : 0;
      for (let f = this.fragments.nodeAt(r); f; ) {
        let u = this.parser.nodeSet.types[f.type.id] == f.type ? s.getGoto(e.state, f.type.id) : -1;
        if (u > -1 && f.length && (!c || (f.prop(Se.contextHash) || 0) == h))
          return e.useNode(f, u), Ft && console.log(o + this.stackID(e) + ` (via reuse of ${s.getName(f.type.id)})`), !0;
        if (!(f instanceof He) || f.children.length == 0 || f.positions[0] > 0)
          break;
        let d = f.children[0];
        if (d instanceof He && f.positions[0] == 0)
          f = d;
        else
          break;
      }
    }
    let a = s.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a > 0)
      return e.reduce(a), Ft && console.log(o + this.stackID(e) + ` (via always-reduce ${s.getName(
        a & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let c = 0; c < l.length; ) {
      let h = l[c++], f = l[c++], u = l[c++], d = c == l.length || !n, p = d ? e : e.split(), O = this.tokens.mainToken;
      if (p.apply(h, f, O ? O.start : p.pos, u), Ft && console.log(o + this.stackID(p) + ` (via ${(h & 65536) == 0 ? "shift" : `reduce of ${s.getName(
        h & 65535
        /* Action.ValueMask */
      )}`} for ${s.getName(f)} @ ${r}${p == e ? "" : ", split"})`), d)
        return !0;
      p.pos > r ? t.push(p) : n.push(p);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, t) {
    let n = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > n)
        return mO(e, t), !0;
    }
  }
  runRecovery(e, t, n) {
    let r = null, s = !1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o], l = t[o << 1], c = t[(o << 1) + 1], h = Ft ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (s || (s = !0, a.restart(), Ft && console.log(h + this.stackID(a) + " (restarted)"), this.advanceFully(a, n))))
        continue;
      let f = a.split(), u = h;
      for (let d = 0; d < 10 && f.forceReduce() && (Ft && console.log(u + this.stackID(f) + " (via force-reduce)"), !this.advanceFully(f, n)); d++)
        Ft && (u = this.stackID(f) + " -> ");
      for (let d of a.recoverByInsert(l))
        Ft && console.log(h + this.stackID(d) + " (via recover-insert)"), this.advanceFully(d, n);
      this.stream.end > a.pos ? (c == a.pos && (c++, l = 0), a.recoverByDelete(l, c), Ft && console.log(h + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`), mO(a, n)) : (!r || r.score < a.score) && (r = a);
    }
    return r;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), He.build({
      buffer: hl.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let t = (Mc || (Mc = /* @__PURE__ */ new WeakMap())).get(e);
    return t || Mc.set(e, t = String.fromCodePoint(this.nextStackID++)), t + e;
  }
}
function mO(i, e) {
  for (let t = 0; t < e.length; t++) {
    let n = e[t];
    if (n.pos == i.pos && n.sameState(i)) {
      e[t].score < i.score && (e[t] = i);
      return;
    }
  }
  e.push(i);
}
class r$ {
  constructor(e, t, n) {
    this.source = e, this.flags = t, this.disabled = n;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const Zc = (i) => i;
class Sb {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || Zc, this.reduce = e.reduce || Zc, this.reuse = e.reuse || Zc, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class ss extends W0 {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let t = e.nodeNames.split(" ");
    this.minRepeatTerm = t.length;
    for (let a = 0; a < e.repeatNodeCount; a++)
      t.push("");
    let n = Object.keys(e.topRules).map((a) => e.topRules[a][1]), r = [];
    for (let a = 0; a < t.length; a++)
      r.push([]);
    function s(a, l, c) {
      r[a].push([l, l.deserialize(String(c))]);
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let l = a[0];
        typeof l == "string" && (l = Se[l]);
        for (let c = 1; c < a.length; ) {
          let h = a[c++];
          if (h >= 0)
            s(h, l, a[c++]);
          else {
            let f = a[c + -h];
            for (let u = -h; u > 0; u--)
              s(a[c++], l, f);
            c++;
          }
        }
      }
    this.nodeSet = new Jf(t.map((a, l) => Dt.define({
      name: l >= this.minRepeatTerm ? void 0 : a,
      id: l,
      props: r[l],
      top: n.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = B0;
    let o = Vs(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(gO), this.states = Vs(e.states, Uint32Array), this.data = Vs(e.stateData), this.goto = Vs(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((a) => typeof a == "number" ? new qr(o, a) : a), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, t, n) {
    let r = new n$(this, e, t, n);
    for (let s of this.wrappers)
      r = s(r, e, t, n);
    return r;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, t, n = !1) {
    let r = this.goto;
    if (t >= r[0])
      return -1;
    for (let s = r[t + 1]; ; ) {
      let o = r[s++], a = o & 1, l = r[s++];
      if (a && n)
        return l;
      for (let c = s + (o >> 1); s < c; s++)
        if (r[s] == e)
          return l;
      if (a)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, t) {
    let n = this.data;
    for (let r = 0; r < 2; r++)
      for (let s = this.stateSlot(
        e,
        r ? 2 : 1
        /* ParseState.Actions */
      ), o; ; s += 3) {
        if ((o = n[s]) == 65535)
          if (n[s + 1] == 1)
            o = n[s = dn(n, s + 2)];
          else {
            if (n[s + 1] == 2)
              return dn(n, s + 2);
            break;
          }
        if (o == t || o == 0)
          return dn(n, s + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, t) {
    return this.states[e * 6 + t];
  }
  /**
  @internal
  */
  stateFlag(e, t) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & t) > 0;
  }
  /**
  @internal
  */
  validAction(e, t) {
    return !!this.allActions(e, (n) => n == t ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, t) {
    let n = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), r = n ? t(n) : void 0;
    for (let s = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); r == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1)
          s = dn(this.data, s + 2);
        else
          break;
      r = t(dn(this.data, s + 1));
    }
    return r;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let t = [];
    for (let n = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; n += 3) {
      if (this.data[n] == 65535)
        if (this.data[n + 1] == 1)
          n = dn(this.data, n + 2);
        else
          break;
      if ((this.data[n + 2] & 1) == 0) {
        let r = this.data[n + 1];
        t.some((s, o) => o & 1 && s == r) || t.push(this.data[n], r);
      }
    }
    return t;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let t = Object.assign(Object.create(ss.prototype), this);
    if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let n = this.topRules[e.top];
      if (!n)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      t.top = n;
    }
    return e.tokenizers && (t.tokenizers = this.tokenizers.map((n) => {
      let r = e.tokenizers.find((s) => s.from == n);
      return r ? r.to : n;
    })), e.specializers && (t.specializers = this.specializers.slice(), t.specializerSpecs = this.specializerSpecs.map((n, r) => {
      let s = e.specializers.find((a) => a.from == n.external);
      if (!s)
        return n;
      let o = Object.assign(Object.assign({}, n), { external: s.to });
      return t.specializers[r] = gO(o), o;
    })), e.contextTracker && (t.context = e.contextTracker), e.dialect && (t.dialect = this.parseDialect(e.dialect)), e.strict != null && (t.strict = e.strict), e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)), e.bufferLength != null && (t.bufferLength = e.bufferLength), t;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let t = this.dynamicPrecedences;
    return t == null ? 0 : t[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let t = Object.keys(this.dialects), n = t.map(() => !1);
    if (e)
      for (let s of e.split(" ")) {
        let o = t.indexOf(s);
        o >= 0 && (n[o] = !0);
      }
    let r = null;
    for (let s = 0; s < t.length; s++)
      if (!n[s])
        for (let o = this.dialects[t[s]], a; (a = this.data[o++]) != 65535; )
          (r || (r = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new r$(e, n, r);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new ss(e);
  }
}
function dn(i, e) {
  return i[e] | i[e + 1] << 16;
}
function s$(i) {
  let e = null;
  for (let t of i) {
    let n = t.p.stoppedAt;
    (t.pos == t.p.stream.end || n != null && t.pos > n) && t.p.parser.stateFlag(
      t.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < t.score) && (e = t);
  }
  return e;
}
function gO(i) {
  if (i.external) {
    let e = i.extend ? 1 : 0;
    return (t, n) => i.external(t, n) << 1 | e;
  }
  return i.get;
}
const o$ = 55, a$ = 1, l$ = 56, c$ = 2, h$ = 57, f$ = 3, bO = 4, u$ = 5, xu = 6, wb = 7, xb = 8, kb = 9, Qb = 10, d$ = 11, p$ = 12, O$ = 13, Xc = 58, m$ = 14, g$ = 15, yO = 59, _b = 21, b$ = 23, Pb = 24, y$ = 25, uf = 27, $b = 28, v$ = 29, S$ = 32, w$ = 35, x$ = 37, k$ = 38, Q$ = 0, _$ = 1, P$ = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, $$ = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, vO = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function T$(i) {
  return i == 45 || i == 46 || i == 58 || i >= 65 && i <= 90 || i == 95 || i >= 97 && i <= 122 || i >= 161;
}
let SO = null, wO = null, xO = 0;
function df(i, e) {
  let t = i.pos + e;
  if (xO == t && wO == i) return SO;
  let n = i.peek(e), r = "";
  for (; T$(n); )
    r += String.fromCharCode(n), n = i.peek(++e);
  return wO = i, xO = t, SO = r ? r.toLowerCase() : n == C$ || n == A$ ? void 0 : null;
}
const Tb = 60, ul = 62, ku = 47, C$ = 63, A$ = 33, R$ = 45;
function kO(i, e) {
  this.name = i, this.parent = e;
}
const E$ = [xu, Qb, wb, xb, kb], M$ = new Sb({
  start: null,
  shift(i, e, t, n) {
    return E$.indexOf(e) > -1 ? new kO(df(n, 1) || "", i) : i;
  },
  reduce(i, e) {
    return e == _b && i ? i.parent : i;
  },
  reuse(i, e, t, n) {
    let r = e.type.id;
    return r == xu || r == x$ ? new kO(df(n, 1) || "", i) : i;
  },
  strict: !1
}), Z$ = new si((i, e) => {
  if (i.next != Tb) {
    i.next < 0 && e.context && i.acceptToken(Xc);
    return;
  }
  i.advance();
  let t = i.next == ku;
  t && i.advance();
  let n = df(i, 0);
  if (n === void 0) return;
  if (!n) return i.acceptToken(t ? g$ : m$);
  let r = e.context ? e.context.name : null;
  if (t) {
    if (n == r) return i.acceptToken(d$);
    if (r && $$[r]) return i.acceptToken(Xc, -2);
    if (e.dialectEnabled(Q$)) return i.acceptToken(p$);
    for (let s = e.context; s; s = s.parent) if (s.name == n) return;
    i.acceptToken(O$);
  } else {
    if (n == "script") return i.acceptToken(wb);
    if (n == "style") return i.acceptToken(xb);
    if (n == "textarea") return i.acceptToken(kb);
    if (P$.hasOwnProperty(n)) return i.acceptToken(Qb);
    r && vO[r] && vO[r][n] ? i.acceptToken(Xc, -1) : i.acceptToken(xu);
  }
}, { contextual: !0 }), X$ = new si((i) => {
  for (let e = 0, t = 0; ; t++) {
    if (i.next < 0) {
      t && i.acceptToken(yO);
      break;
    }
    if (i.next == R$)
      e++;
    else if (i.next == ul && e >= 2) {
      t >= 3 && i.acceptToken(yO, -2);
      break;
    } else
      e = 0;
    i.advance();
  }
});
function z$(i) {
  for (; i; i = i.parent)
    if (i.name == "svg" || i.name == "math") return !0;
  return !1;
}
const D$ = new si((i, e) => {
  if (i.next == ku && i.peek(1) == ul) {
    let t = e.dialectEnabled(_$) || z$(e.context);
    i.acceptToken(t ? u$ : bO, 2);
  } else i.next == ul && i.acceptToken(bO, 1);
});
function Qu(i, e, t) {
  let n = 2 + i.length;
  return new si((r) => {
    for (let s = 0, o = 0, a = 0; ; a++) {
      if (r.next < 0) {
        a && r.acceptToken(e);
        break;
      }
      if (s == 0 && r.next == Tb || s == 1 && r.next == ku || s >= 2 && s < n && r.next == i.charCodeAt(s - 2))
        s++, o++;
      else if (s == n && r.next == ul) {
        a > o ? r.acceptToken(e, -o) : r.acceptToken(t, -(o - 2));
        break;
      } else if ((r.next == 10 || r.next == 13) && a) {
        r.acceptToken(e, 1);
        break;
      } else
        s = o = 0;
      r.advance();
    }
  });
}
const L$ = Qu("script", o$, a$), I$ = Qu("style", l$, c$), B$ = Qu("textarea", h$, f$), Y$ = El({
  "Text RawText IncompleteTag IncompleteCloseTag": T.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": T.angleBracket,
  TagName: T.tagName,
  "MismatchedCloseTag/TagName": [T.tagName, T.invalid],
  AttributeName: T.attributeName,
  "AttributeValue UnquotedAttributeValue": T.attributeValue,
  Is: T.definitionOperator,
  "EntityReference CharacterReference": T.character,
  Comment: T.blockComment,
  ProcessingInst: T.processingInstruction,
  DoctypeDecl: T.documentMeta
}), N$ = ss.deserialize({
  version: 14,
  states: ",xOVO!rOOO!ZQ#tO'#CrO!`Q#tO'#C{O!eQ#tO'#DOO!jQ#tO'#DRO!oQ#tO'#DTO!tOaO'#CqO#PObO'#CqO#[OdO'#CqO$kO!rO'#CqOOO`'#Cq'#CqO$rO$fO'#DUO$zQ#tO'#DWO%PQ#tO'#DXOOO`'#Dl'#DlOOO`'#DZ'#DZQVO!rOOO%UQ&rO,59^O%aQ&rO,59gO%lQ&rO,59jO%wQ&rO,59mO&SQ&rO,59oOOOa'#D_'#D_O&_OaO'#CyO&jOaO,59]OOOb'#D`'#D`O&rObO'#C|O&}ObO,59]OOOd'#Da'#DaO'VOdO'#DPO'bOdO,59]OOO`'#Db'#DbO'jO!rO,59]O'qQ#tO'#DSOOO`,59],59]OOOp'#Dc'#DcO'vO$fO,59pOOO`,59p,59pO(OQ#|O,59rO(TQ#|O,59sOOO`-E7X-E7XO(YQ&rO'#CtOOQW'#D['#D[O(hQ&rO1G.xOOOa1G.x1G.xOOO`1G/Z1G/ZO(sQ&rO1G/ROOOb1G/R1G/RO)OQ&rO1G/UOOOd1G/U1G/UO)ZQ&rO1G/XOOO`1G/X1G/XO)fQ&rO1G/ZOOOa-E7]-E7]O)qQ#tO'#CzOOO`1G.w1G.wOOOb-E7^-E7^O)vQ#tO'#C}OOOd-E7_-E7_O){Q#tO'#DQOOO`-E7`-E7`O*QQ#|O,59nOOOp-E7a-E7aOOO`1G/[1G/[OOO`1G/^1G/^OOO`1G/_1G/_O*VQ,UO,59`OOQW-E7Y-E7YOOOa7+$d7+$dOOO`7+$u7+$uOOOb7+$m7+$mOOOd7+$p7+$pOOO`7+$s7+$sO*bQ#|O,59fO*gQ#|O,59iO*lQ#|O,59lOOO`1G/Y1G/YO*qO7[O'#CwO+SOMhO'#CwOOQW1G.z1G.zOOO`1G/Q1G/QOOO`1G/T1G/TOOO`1G/W1G/WOOOO'#D]'#D]O+eO7[O,59cOOQW,59c,59cOOOO'#D^'#D^O+vOMhO,59cOOOO-E7Z-E7ZOOQW1G.}1G.}OOOO-E7[-E7[",
  stateData: ",c~O!_OS~OUSOVPOWQOXROYTO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O|_O!eZO~OgaO~OgbO~OgcO~OgdO~OgeO~O!XfOPmP![mP~O!YiOQpP![pP~O!ZlORsP![sP~OUSOVPOWQOXROYTOZqO[]O][O^^O_^Oa^Ob^Oc^Od^Oy^O!eZO~O![rO~P#gO!]sO!fuO~OgvO~OgwO~OS|OT}OiyO~OS!POT}OiyO~OS!ROT}OiyO~OS!TOT}OiyO~OS}OT}OiyO~O!XfOPmX![mX~OP!WO![!XO~O!YiOQpX![pX~OQ!ZO![!XO~O!ZlORsX![sX~OR!]O![!XO~O![!XO~P#gOg!_O~O!]sO!f!aO~OS!bO~OS!cO~Oj!dOShXThXihX~OS!fOT!gOiyO~OS!hOT!gOiyO~OS!iOT!gOiyO~OS!jOT!gOiyO~OS!gOT!gOiyO~Og!kO~Og!lO~Og!mO~OS!nO~Ol!qO!a!oO!c!pO~OS!rO~OS!sO~OS!tO~Ob!uOc!uOd!uO!a!wO!b!uO~Ob!xOc!xOd!xO!c!wO!d!xO~Ob!uOc!uOd!uO!a!{O!b!uO~Ob!xOc!xOd!xO!c!{O!d!xO~OT~cbd!ey|!e~",
  goto: "%q!aPPPPPPPPPPPPPPPPPPPPP!b!hP!nPP!zP!}#Q#T#Z#^#a#g#j#m#s#y!bP!b!bP$P$V$m$s$y%P%V%]%cPPPPPPPP%iX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "âš  StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 68,
  context: M$,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 22, 31, 34, 37, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 30, 33, 36, 38, "OpenTag"],
    ["group", -10, 14, 15, 18, 19, 20, 21, 40, 41, 42, 43, "Entity", 17, "Entity TextContent", -3, 29, 32, 35, "TextContent Entity"],
    ["isolate", -11, 22, 30, 31, 33, 34, 36, 37, 38, 39, 42, 43, "ltr", -3, 27, 28, 40, ""]
  ],
  propSources: [Y$],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|caPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bXaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UVaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pTaPOv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!dpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({WaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!b`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!b`!dpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYlWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]`aP!b`!dp!_^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebiSlWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXiSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vciSaP!b`!dpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!ahaP!dpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WiiSlWd!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zblWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOb!R!R7tP;=`<%l7S!Z8OYlWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{iiSlWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbiSlWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QciSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXiSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TalWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOc!R!RAwP;=`<%lAY!ZBRYlWc!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhiSlWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbiSlWc!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbiSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXiSc!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!cxaP!b`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYliSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_kiSaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_XaP!b`!dp!fQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZiSgQaPlW!b`!dpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!b`!dpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!b`!dpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!b`!dp!ePOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!b`!dpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!b`!dpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!b`!dpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!b`!dpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!b`!dpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!b`!dpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!b`!dpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!dpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO|PP!-nP;=`<%l!-Sq!-xS!dp|POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!b`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!b`|POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!b`!dp|POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!b`!dpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!b`!dpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!b`!dpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!b`!dpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!b`!dpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!b`!dpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!dpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOyPP!7TP;=`<%l!6Vq!7]V!dpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!dpyPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!b`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!b`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!b`yPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!b`!dpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!b`!dpyPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXjSaP!b`!dpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [L$, I$, B$, D$, Z$, X$, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 16] },
  dialects: { noMatch: 0, selfClosing: 515 },
  tokenPrec: 517
});
function Cb(i, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n of i.getChildren(Pb)) {
    let r = n.getChild(y$), s = n.getChild(uf) || n.getChild($b);
    r && (t[e.read(r.from, r.to)] = s ? s.type.id == uf ? e.read(s.from + 1, s.to - 1) : e.read(s.from, s.to) : "");
  }
  return t;
}
function QO(i, e) {
  let t = i.getChild(b$);
  return t ? e.read(t.from, t.to) : " ";
}
function zc(i, e, t) {
  let n;
  for (let r of t)
    if (!r.attrs || r.attrs(n || (n = Cb(i.node.parent.firstChild, e))))
      return { parser: r.parser };
  return null;
}
function Ab(i = [], e = []) {
  let t = [], n = [], r = [], s = [];
  for (let a of i)
    (a.tag == "script" ? t : a.tag == "style" ? n : a.tag == "textarea" ? r : s).push(a);
  let o = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let a of e) (o[a.name] || (o[a.name] = [])).push(a);
  return eQ((a, l) => {
    let c = a.type.id;
    if (c == v$) return zc(a, l, t);
    if (c == S$) return zc(a, l, n);
    if (c == w$) return zc(a, l, r);
    if (c == _b && s.length) {
      let h = a.node, f = h.firstChild, u = f && QO(f, l), d;
      if (u) {
        for (let p of s)
          if (p.tag == u && (!p.attrs || p.attrs(d || (d = Cb(f, l))))) {
            let O = h.lastChild, m = O.type.id == k$ ? O.from : h.to;
            if (m > f.to)
              return { parser: p.parser, overlay: [{ from: f.to, to: m }] };
          }
      }
    }
    if (o && c == Pb) {
      let h = a.node, f;
      if (f = h.firstChild) {
        let u = o[l.read(f.from, f.to)];
        if (u) for (let d of u) {
          if (d.tagName && d.tagName != QO(h.parent, l)) continue;
          let p = h.lastChild;
          if (p.type.id == uf) {
            let O = p.from + 1, m = p.lastChild, g = p.to - (m && m.isError ? 0 : 1);
            if (g > O) return { parser: d.parser, overlay: [{ from: O, to: g }] };
          } else if (p.type.id == $b)
            return { parser: d.parser, overlay: [{ from: p.from, to: p.to }] };
        }
      }
    }
    return null;
  });
}
const V$ = 122, _O = 1, q$ = 123, W$ = 124, Rb = 2, j$ = 125, U$ = 3, G$ = 4, Eb = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], F$ = 58, H$ = 40, Mb = 95, K$ = 91, Ra = 45, J$ = 46, eT = 35, tT = 37, iT = 38, nT = 92, rT = 10, sT = 42;
function wo(i) {
  return i >= 65 && i <= 90 || i >= 97 && i <= 122 || i >= 161;
}
function _u(i) {
  return i >= 48 && i <= 57;
}
function PO(i) {
  return _u(i) || i >= 97 && i <= 102 || i >= 65 && i <= 70;
}
const Zb = (i, e, t) => (n, r) => {
  for (let s = !1, o = 0, a = 0; ; a++) {
    let { next: l } = n;
    if (wo(l) || l == Ra || l == Mb || s && _u(l))
      !s && (l != Ra || a > 0) && (s = !0), o === a && l == Ra && o++, n.advance();
    else if (l == nT && n.peek(1) != rT) {
      if (n.advance(), PO(n.next)) {
        do
          n.advance();
        while (PO(n.next));
        n.next == 32 && n.advance();
      } else n.next > -1 && n.advance();
      s = !0;
    } else {
      s && n.acceptToken(
        o == 2 && r.canShift(Rb) ? e : l == H$ ? t : i
      );
      break;
    }
  }
}, oT = new si(
  Zb(q$, Rb, W$)
), aT = new si(
  Zb(j$, U$, G$)
), lT = new si((i) => {
  if (Eb.includes(i.peek(-1))) {
    let { next: e } = i;
    (wo(e) || e == Mb || e == eT || e == J$ || e == sT || e == K$ || e == F$ && wo(i.peek(1)) || e == Ra || e == iT) && i.acceptToken(V$);
  }
}), cT = new si((i) => {
  if (!Eb.includes(i.peek(-1))) {
    let { next: e } = i;
    if (e == tT && (i.advance(), i.acceptToken(_O)), wo(e)) {
      do
        i.advance();
      while (wo(i.next) || _u(i.next));
      i.acceptToken(_O);
    }
  }
}), hT = El({
  "AtKeyword import charset namespace keyframes media supports": T.definitionKeyword,
  "from to selector": T.keyword,
  NamespaceName: T.namespace,
  KeyframeName: T.labelName,
  KeyframeRangeName: T.operatorKeyword,
  TagName: T.tagName,
  ClassName: T.className,
  PseudoClassName: T.constant(T.className),
  IdName: T.labelName,
  "FeatureName PropertyName": T.propertyName,
  AttributeName: T.attributeName,
  NumberLiteral: T.number,
  KeywordQuery: T.keyword,
  UnaryQueryOp: T.operatorKeyword,
  "CallTag ValueName": T.atom,
  VariableName: T.variableName,
  Callee: T.operatorKeyword,
  Unit: T.unit,
  "UniversalSelector NestingSelector": T.definitionOperator,
  "MatchOp CompareOp": T.compareOperator,
  "ChildOp SiblingOp, LogicOp": T.logicOperator,
  BinOp: T.arithmeticOperator,
  Important: T.modifier,
  Comment: T.blockComment,
  ColorLiteral: T.color,
  "ParenthesizedContent StringLiteral": T.string,
  ":": T.punctuation,
  "PseudoOp #": T.derefOperator,
  "; ,": T.separator,
  "( )": T.paren,
  "[ ]": T.squareBracket,
  "{ }": T.brace
}), fT = { __proto__: null, lang: 38, "nth-child": 38, "nth-last-child": 38, "nth-of-type": 38, "nth-last-of-type": 38, dir: 38, "host-context": 38, if: 84, url: 124, "url-prefix": 124, domain: 124, regexp: 124 }, uT = { __proto__: null, or: 98, and: 98, not: 106, only: 106, layer: 170 }, dT = { __proto__: null, selector: 112, layer: 166 }, pT = { __proto__: null, "@import": 162, "@media": 174, "@charset": 178, "@namespace": 182, "@keyframes": 188, "@supports": 200, "@scope": 204 }, OT = { __proto__: null, to: 207 }, mT = ss.deserialize({
  version: 14,
  states: "EbQYQdOOO#qQdOOP#xO`OOOOQP'#Cf'#CfOOQP'#Ce'#CeO#}QdO'#ChO$nQaO'#CcO$xQdO'#CkO%TQdO'#DpO%YQdO'#DrO%_QdO'#DuO%_QdO'#DxOOQP'#FV'#FVO&eQhO'#EhOOQS'#FU'#FUOOQS'#Ek'#EkQYQdOOO&lQdO'#EOO&PQhO'#EUO&lQdO'#EWO'aQdO'#EYO'lQdO'#E]O'tQhO'#EcO(VQdO'#EeO(bQaO'#CfO)VQ`O'#D{O)[Q`O'#F`O)gQdO'#F`QOQ`OOP)qO&jO'#CaPOOO)C@t)C@tOOQP'#Cj'#CjOOQP,59S,59SO#}QdO,59SO)|QdO,59VO%TQdO,5:[O%YQdO,5:^O%_QdO,5:aO%_QdO,5:cO%_QdO,5:dO%_QdO'#ErO*XQ`O,58}O*aQdO'#DzOOQS,58},58}OOQP'#Cn'#CnOOQO'#Dn'#DnOOQP,59V,59VO*hQ`O,59VO*mQ`O,59VOOQP'#Dq'#DqOOQP,5:[,5:[OOQO'#Ds'#DsO*rQpO,5:^O+]QaO,5:aO+sQaO,5:dOOQW'#DZ'#DZO,ZQhO'#DdO,xQhO'#FaO'tQhO'#DbO-WQ`O'#DhOOQW'#F['#F[O-]Q`O,5;SO-eQ`O'#DeOOQS-E8i-E8iOOQ['#Cs'#CsO-jQdO'#CtO.QQdO'#CzO.hQdO'#C}O/OQ!pO'#DPO1RQ!jO,5:jOOQO'#DU'#DUO*mQ`O'#DTO1cQ!nO'#FXO3`Q`O'#DVO3eQ`O'#DkOOQ['#FX'#FXO-`Q`O,5:pO3jQ!bO,5:rOOQS'#E['#E[O3rQ`O,5:tO3wQdO,5:tOOQO'#E_'#E_O4PQ`O,5:wO4UQhO,5:}O%_QdO'#DgOOQS,5;P,5;PO-eQ`O,5;PO4^QdO,5;PO4fQdO,5:gO4vQdO'#EtO5TQ`O,5;zO5TQ`O,5;zPOOO'#Ej'#EjP5`O&jO,58{POOO,58{,58{OOQP1G.n1G.nOOQP1G.q1G.qO*hQ`O1G.qO*mQ`O1G.qOOQP1G/v1G/vO5kQpO1G/xO5sQaO1G/{O6ZQaO1G/}O6qQaO1G0OO7XQaO,5;^OOQO-E8p-E8pOOQS1G.i1G.iO7cQ`O,5:fO7hQdO'#DoO7oQdO'#CrOOQP1G/x1G/xO&lQdO1G/xO7vQ!jO'#DZO8UQ!bO,59vO8^QhO,5:OOOQO'#F]'#F]O8XQ!bO,59zO'tQhO,59xO8fQhO'#EvO8sQ`O,5;{O9OQhO,59|O9uQhO'#DiOOQW,5:S,5:SOOQS1G0n1G0nOOQW,5:P,5:PO9|Q!fO'#FYOOQS'#FY'#FYOOQS'#Em'#EmO;^QdO,59`OOQ[,59`,59`O;tQdO,59fOOQ[,59f,59fO<[QdO,59iOOQ[,59i,59iOOQ[,59k,59kO&lQdO,59mO<rQhO'#EQOOQW'#EQ'#EQO=WQ`O1G0UO1[QhO1G0UOOQ[,59o,59oO'tQhO'#DXOOQ[,59q,59qO=]Q#tO,5:VOOQS1G0[1G0[OOQS1G0^1G0^OOQS1G0`1G0`O=hQ`O1G0`O=mQdO'#E`OOQS1G0c1G0cOOQS1G0i1G0iO=xQaO,5:RO-`Q`O1G0kOOQS1G0k1G0kO-eQ`O1G0kO>PQ!fO1G0ROOQO1G0R1G0ROOQO,5;`,5;`O>gQdO,5;`OOQO-E8r-E8rO>tQ`O1G1fPOOO-E8h-E8hPOOO1G.g1G.gOOQP7+$]7+$]OOQP7+%d7+%dO&lQdO7+%dOOQS1G0Q1G0QO?PQaO'#F_O?ZQ`O,5:ZO?`Q!fO'#ElO@^QdO'#FWO@hQ`O,59^O@mQ!bO7+%dO&lQdO1G/bO@uQhO1G/fOOQW1G/j1G/jOOQW1G/d1G/dOAWQhO,5;bOOQO-E8t-E8tOAfQhO'#DZOAtQhO'#F^OBPQ`O'#F^OBUQ`O,5:TOOQS-E8k-E8kOOQ[1G.z1G.zOOQ[1G/Q1G/QOOQ[1G/T1G/TOOQ[1G/X1G/XOBZQdO,5:lOOQS7+%p7+%pOB`Q`O7+%pOBeQhO'#DYOBmQ`O,59sO'tQhO,59sOOQ[1G/q1G/qOBuQ`O1G/qOOQS7+%z7+%zOBzQbO'#DPOOQO'#Eb'#EbOCYQ`O'#EaOOQO'#Ea'#EaOCeQ`O'#EwOCmQdO,5:zOOQS,5:z,5:zOOQ[1G/m1G/mOOQS7+&V7+&VO-`Q`O7+&VOCxQ!fO'#EsO&lQdO'#EsOEPQdO7+%mOOQO7+%m7+%mOOQO1G0z1G0zOEdQ!bO<<IOOElQdO'#EqOEvQ`O,5;yOOQP1G/u1G/uOOQS-E8j-E8jOFOQdO'#EpOFYQ`O,5;rOOQ]1G.x1G.xOOQP<<IO<<IOOFbQdO7+$|OOQO'#D]'#D]OFiQ!bO7+%QOFqQhO'#EoOF{Q`O,5;xO&lQdO,5;xOOQW1G/o1G/oOOQO'#ES'#ESOGTQ`O1G0WOOQS<<I[<<I[O&lQdO,59tOGnQhO1G/_OOQ[1G/_1G/_OGuQ`O1G/_OOQW-E8l-E8lOOQ[7+%]7+%]OOQO,5:{,5:{O=pQdO'#ExOCeQ`O,5;cOOQS,5;c,5;cOOQS-E8u-E8uOOQS1G0f1G0fOOQS<<Iq<<IqOG}Q!fO,5;_OOQS-E8q-E8qOOQO<<IX<<IXOOQPAN>jAN>jOIUQaO,5;]OOQO-E8o-E8oOI`QdO,5;[OOQO-E8n-E8nOOQW<<Hh<<HhOOQW<<Hl<<HlOIjQhO<<HlOI{QhO,5;ZOJWQ`O,5;ZOOQO-E8m-E8mOJ]QdO1G1dOBZQdO'#EuOJgQ`O7+%rOOQW7+%r7+%rOJoQ!bO1G/`OOQ[7+$y7+$yOJzQhO7+$yPKRQ`O'#EnOOQO,5;d,5;dOOQO-E8v-E8vOOQS1G0}1G0}OKWQ`OAN>WO&lQdO1G0uOK]Q`O7+'OOOQO,5;a,5;aOOQO-E8s-E8sOOQW<<I^<<I^OOQ[<<He<<HePOQW,5;Y,5;YOOQWG23rG23rOKeQdO7+&a",
  stateData: "Kx~O#sOS#tQQ~OW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#oRO~OQiOW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#ohO~O#m$SP~P!dO#tmO~O#ooO~O]qO`rOarOjsOmtO!juO!mwO#nvO~OpzO!^xO~P$SOc!QO#o|O#p}O~O#o!RO~O#o!TO~OW[OZ[O]TO`VOaVOjWOmXO!jYO!mZO#oRO~OS!]Oe!YO!V![O!Y!`O#q!XOp$TP~Ok$TP~P&POQ!jOe!cOm!dOp!eOr!mOt!mOz!kO!`!lO#o!bO#p!hO#}!fO~Ot!qO!`!lO#o!pO~Ot!sO#o!sO~OS!]Oe!YO!V![O!Y!`O#q!XO~Oe!vOpzO#Z!xO~O]YX`YX`!pXaYXjYXmYXpYX!^YX!jYX!mYX#nYX~O`!zO~Ok!{O#m$SXo$SX~O#m$SXo$SX~P!dO#u#OO#v#OO#w#QO~Oc#UO#o|O#p}O~OpzO!^xO~Oo$SP~P!dOe#`O~Oe#aO~Ol#bO!h#cO~O]qO`rOarOjsOmtO~Op!ia!^!ia!j!ia!m!ia#n!iad!ia~P*zOp!la!^!la!j!la!m!la#n!lad!la~P*zOR#gOS!]Oe!YOr#gOt#gO!V![O!Y!`O#q#dO#}!fO~O!R#iO!^#jOk$TXp$TX~Oe#mO~Ok#oOpzO~Oe!vO~O]#rO`#rOd#uOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl#wO~P&lO]#rO`#rOi#rOj#rOk#rOo#yO~P&lOP#zOSsXesXksXvsX!VsX!YsX!usX!wsX#qsX!TsXQsX]sX`sXdsXisXjsXmsXpsXrsXtsXzsX!`sX#osX#psX#}sXlsXosX!^sX!qsX#msX~Ov#{O!u#|O!w#}Ok$TP~P'tOe#aOS#{Xk#{Xv#{X!V#{X!Y#{X!u#{X!w#{X#q#{XQ#{X]#{X`#{Xd#{Xi#{Xj#{Xm#{Xp#{Xr#{Xt#{Xz#{X!`#{X#o#{X#p#{X#}#{Xl#{Xo#{X!^#{X!q#{X#m#{X~Oe$RO~Oe$TO~Ok$VOv#{O~Ok$WO~Ot$XO!`!lO~Op$YO~OpzO!R#iO~OpzO#Z$`O~O!q$bOk!oa#m!oao!oa~P&lOk#hX#m#hXo#hX~P!dOk!{O#m$Sao$Sa~O#u#OO#v#OO#w$hO~Ol$jO!h$kO~Op!ii!^!ii!j!ii!m!ii#n!iid!ii~P*zOp!ki!^!ki!j!ki!m!ki#n!kid!ki~P*zOp!li!^!li!j!li!m!li#n!lid!li~P*zOp#fa!^#fa~P$SOo$lO~Od$RP~P%_Od#zP~P&lO`!PXd}X!R}X!T!PX~O`$sO!T$tO~Od$uO!R#iO~Ok#jXp#jX!^#jX~P'tO!^#jOk$Tap$Ta~O!R#iOk!Uap!Ua!^!Uad!Ua`!Ua~OS!]Oe!YO!V![O!Y!`O#q$yO~Od$QP~P9dOv#{OQ#|X]#|X`#|Xd#|Xe#|Xi#|Xj#|Xk#|Xm#|Xp#|Xr#|Xt#|Xz#|X!`#|X#o#|X#p#|X#}#|Xl#|Xo#|X~O]#rO`#rOd%OOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl%PO~P&lO]#rO`#rOi#rOj#rOk#rOo%QO~P&lOe%SOS!tXk!tX!V!tX!Y!tX#q!tX~Ok%TO~Od%YOt%ZO!a%ZO~Ok%[O~Oo%cO#o%^O#}%]O~Od%dO~P$SOv#{O!^%hO!q%jOk!oi#m!oio!oi~P&lOk#ha#m#hao#ha~P!dOk!{O#m$Sio$Si~O!^%mOd$RX~P$SOd%oO~Ov#{OQ#`Xd#`Xe#`Xm#`Xp#`Xr#`Xt#`Xz#`X!^#`X!`#`X#o#`X#p#`X#}#`X~O!^%qOd#zX~P&lOd%sO~Ol%tOv#{O~OR#gOr#gOt#gO#q%vO#}!fO~O!R#iOk#jap#ja!^#ja~O`!PXd}X!R}X!^}X~O!R#iO!^%xOd$QX~O`%zO~Od%{O~O#o%|O~Ok&OO~O`&PO!R#iO~Od&ROk&QO~Od&UO~OP#zOpsX!^sXdsX~O#}%]Op#TX!^#TX~OpzO!^&WO~Oo&[O#o%^O#}%]O~Ov#{OQ#gXe#gXk#gXm#gXp#gXr#gXt#gXz#gX!^#gX!`#gX!q#gX#m#gX#o#gX#p#gX#}#gXo#gX~O!^%hO!q&`Ok!oq#m!oqo!oq~P&lOl&aOv#{O~Od#eX!^#eX~P%_O!^%mOd$Ra~Od#dX!^#dX~P&lO!^%qOd#za~Od&fO~P&lOd&gO!T&hO~Od#cX!^#cX~P9dO!^%xOd$Qa~O]&mOd&oO~OS#bae#ba!V#ba!Y#ba#q#ba~Od&qO~PG]Od&qOk&rO~Ov#{OQ#gae#gak#gam#gap#gar#gat#gaz#ga!^#ga!`#ga!q#ga#m#ga#o#ga#p#ga#}#gao#ga~Od#ea!^#ea~P$SOd#da!^#da~P&lOR#gOr#gOt#gO#q%vO#}%]O~O!R#iOd#ca!^#ca~O`&xO~O!^%xOd$Qi~P&lO]&mOd&|O~Ov#{Od|ik|i~Od&}O~PG]Ok'OO~Od'PO~O!^%xOd$Qq~Od#cq!^#cq~P&lO#s!a#t#}]#}v!m~",
  goto: "2h$UPPPPP$VP$YP$c$uP$cP%X$cPP%_PPP%e%o%oPPPPP%oPP%oP&]P%oP%o'W%oP't'w'}'}(^'}P'}P'}P'}'}P(m'}(yP(|PP)p)v$c)|$c*SP$cP$c$cP*Y*{+YP$YP+aP+dP$YP$YP$YP+j$YP+m+p+s+z$YP$YPP$YP,P,V,f,|-[-b-l-r-x.O.U.`.f.l.rPPPPPPPPPPP.x/R/w/z0|P1U1u2O2R2U2[RnQ_^OP`kz!{$dq[OPYZ`kuvwxz!v!{#`$d%mqSOPYZ`kuvwxz!v!{#`$d%mQpTR#RqQ!OVR#SrQ#S!QS$Q!i!jR$i#U!V!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'Q!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QU#g!Y$t&hU%`$Y%b&WR&V%_!V!iac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QR$S!kQ%W$RR&S%Xk!^]bf!Y![!g#i#j#m$P$R%X%xQ#e!YQ${#mQ%w$tQ&j%xR&w&hQ!ygQ#p!`Q$^!xR%f$`R#n!]!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QQ!qdR$X!rQ!PVR#TrQ#S!PR$i#TQ!SWR#VsQ!UXR#WtQ{UQ!wgQ#^yQ#o!_Q$U!nQ$[!uQ$_!yQ%e$^Q&Y%aQ&]%fR&v&XSjPzQ!}kQ$c!{R%k$dZiPkz!{$dR$P!gQ%}%SR&z&mR!rdR!teR$Z!tS%a$Y%bR&t&WV%_$Y%b&WQ#PmR$g#PQ`OSkPzU!a`k$dR$d!{Q$p#aY%p$p%u&d&l'QQ%u$sQ&d%qQ&l%zR'Q&xQ#t!cQ#v!dQ#x!eV$}#t#v#xQ%X$RR&T%XQ%y$zS&k%y&yR&y&lQ%r$pR&e%rQ%n$mR&c%nQyUR#]yQ%i$aR&_%iQ!|jS$e!|$fR$f!}Q&n%}R&{&nQ#k!ZR$x#kQ%b$YR&Z%bQ&X%aR&u&X__OP`kz!{$d^UOP`kz!{$dQ!VYQ!WZQ#XuQ#YvQ#ZwQ#[xQ$]!vQ$m#`R&b%mR$q#aQ!gaQ!oc[#q!c!d!e#t#v#xQ$a!zd$o#a$p$s%q%u%z&d&l&x'QQ$r#cQ%R#{S%g$a%iQ%l$kQ&^%hR&p&P]#s!c!d!e#t#v#xW!Z]b!g$PQ!ufQ#f!YQ#l![Q$v#iQ$w#jQ$z#mS%V$R%XR&i%xQ#h!YQ%w$tR&w&hR$|#mR$n#`QlPR#_zQ!_]Q!nbQ$O!gR%U$P",
  nodeNames: "âš  Unit VariableName VariableName QueryCallee Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue AtKeyword # ; ] [ BracketedValue } { BracedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee IfExpression if ArgList IfBranch KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp ComparisonQuery CompareOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector ParenthesizedSelector CallQuery ArgList , CallLiteral CallTag ParenthesizedContent PseudoClassName ArgList IdSelector IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp Block Declaration PropertyName Important ImportStatement import Layer layer LayerName layer MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports ScopeStatement scope to AtRule Styles",
  maxTerm: 143,
  nodeProps: [
    ["isolate", -2, 5, 36, ""],
    ["openedBy", 20, "(", 28, "[", 31, "{"],
    ["closedBy", 21, ")", 29, "]", 32, "}"]
  ],
  propSources: [hT],
  skippedNodes: [0, 5, 106],
  repeatNodeCount: 15,
  tokenData: "JQ~R!YOX$qX^%i^p$qpq%iqr({rs-ust/itu6Wuv$qvw7Qwx7cxy9Qyz9cz{9h{|:R|}>t}!O?V!O!P?t!P!Q@]!Q![AU![!]BP!]!^B{!^!_C^!_!`DY!`!aDm!a!b$q!b!cEn!c!}$q!}#OG{#O#P$q#P#QH^#Q#R6W#R#o$q#o#pHo#p#q6W#q#rIQ#r#sIc#s#y$q#y#z%i#z$f$q$f$g%i$g#BY$q#BY#BZ%i#BZ$IS$q$IS$I_%i$I_$I|$q$I|$JO%i$JO$JT$q$JT$JU%i$JU$KV$q$KV$KW%i$KW&FU$q&FU&FV%i&FV;'S$q;'S;=`Iz<%lO$q`$tSOy%Qz;'S%Q;'S;=`%c<%lO%Q`%VS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q`%fP;=`<%l%Q~%nh#s~OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Q~'ah#s~!a`OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Qj)OUOy%Qz#]%Q#]#^)b#^;'S%Q;'S;=`%c<%lO%Qj)gU!a`Oy%Qz#a%Q#a#b)y#b;'S%Q;'S;=`%c<%lO%Qj*OU!a`Oy%Qz#d%Q#d#e*b#e;'S%Q;'S;=`%c<%lO%Qj*gU!a`Oy%Qz#c%Q#c#d*y#d;'S%Q;'S;=`%c<%lO%Qj+OU!a`Oy%Qz#f%Q#f#g+b#g;'S%Q;'S;=`%c<%lO%Qj+gU!a`Oy%Qz#h%Q#h#i+y#i;'S%Q;'S;=`%c<%lO%Qj,OU!a`Oy%Qz#T%Q#T#U,b#U;'S%Q;'S;=`%c<%lO%Qj,gU!a`Oy%Qz#b%Q#b#c,y#c;'S%Q;'S;=`%c<%lO%Qj-OU!a`Oy%Qz#h%Q#h#i-b#i;'S%Q;'S;=`%c<%lO%Qj-iS!qY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q~-xWOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c<%lO-u~.gOt~~.jRO;'S-u;'S;=`.s;=`O-u~.vXOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c;=`<%l-u<%lO-u~/fP;=`<%l-uj/nYjYOy%Qz!Q%Q!Q![0^![!c%Q!c!i0^!i#T%Q#T#Z0^#Z;'S%Q;'S;=`%c<%lO%Qj0cY!a`Oy%Qz!Q%Q!Q![1R![!c%Q!c!i1R!i#T%Q#T#Z1R#Z;'S%Q;'S;=`%c<%lO%Qj1WY!a`Oy%Qz!Q%Q!Q![1v![!c%Q!c!i1v!i#T%Q#T#Z1v#Z;'S%Q;'S;=`%c<%lO%Qj1}YrY!a`Oy%Qz!Q%Q!Q![2m![!c%Q!c!i2m!i#T%Q#T#Z2m#Z;'S%Q;'S;=`%c<%lO%Qj2tYrY!a`Oy%Qz!Q%Q!Q![3d![!c%Q!c!i3d!i#T%Q#T#Z3d#Z;'S%Q;'S;=`%c<%lO%Qj3iY!a`Oy%Qz!Q%Q!Q![4X![!c%Q!c!i4X!i#T%Q#T#Z4X#Z;'S%Q;'S;=`%c<%lO%Qj4`YrY!a`Oy%Qz!Q%Q!Q![5O![!c%Q!c!i5O!i#T%Q#T#Z5O#Z;'S%Q;'S;=`%c<%lO%Qj5TY!a`Oy%Qz!Q%Q!Q![5s![!c%Q!c!i5s!i#T%Q#T#Z5s#Z;'S%Q;'S;=`%c<%lO%Qj5zSrY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qd6ZUOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qd6tS!hS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qb7VSZQOy%Qz;'S%Q;'S;=`%c<%lO%Q~7fWOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z<%lO7c~8RRO;'S7c;'S;=`8[;=`O7c~8_XOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z;=`<%l7c<%lO7c~8}P;=`<%l7cj9VSeYOy%Qz;'S%Q;'S;=`%c<%lO%Q~9hOd~n9oUWQvWOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qj:YWvW!mQOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj:wU!a`Oy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Qj;bY!a`#}YOy%Qz!Q%Q!Q![;Z![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj<VY!a`Oy%Qz{%Q{|<u|}%Q}!O<u!O!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj<zU!a`Oy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj=eU!a`#}YOy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj>O[!a`#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj>yS!^YOy%Qz;'S%Q;'S;=`%c<%lO%Qj?[WvWOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj?yU]YOy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Q~@bTvWOy%Qz{@q{;'S%Q;'S;=`%c<%lO%Q~@xS!a`#t~Oy%Qz;'S%Q;'S;=`%c<%lO%QjAZ[#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%QjBUU`YOy%Qz![%Q![!]Bh!];'S%Q;'S;=`%c<%lO%QbBoSaQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjCQSkYOy%Qz;'S%Q;'S;=`%c<%lO%QhCcU!TWOy%Qz!_%Q!_!`Cu!`;'S%Q;'S;=`%c<%lO%QhC|S!TW!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QlDaS!TW!hSOy%Qz;'S%Q;'S;=`%c<%lO%QjDtV!jQ!TWOy%Qz!_%Q!_!`Cu!`!aEZ!a;'S%Q;'S;=`%c<%lO%QbEbS!jQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjEqYOy%Qz}%Q}!OFa!O!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjFfW!a`Oy%Qz!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjGV[iY!a`Oy%Qz}%Q}!OGO!O!Q%Q!Q![GO![!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjHQSmYOy%Qz;'S%Q;'S;=`%c<%lO%QnHcSl^Oy%Qz;'S%Q;'S;=`%c<%lO%QjHtSpYOy%Qz;'S%Q;'S;=`%c<%lO%QjIVSoYOy%Qz;'S%Q;'S;=`%c<%lO%QfIhU!mQOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Q`I}P;=`<%l$q",
  tokenizers: [lT, cT, oT, aT, 1, 2, 3, 4, new fl("m~RRYZ[z{a~~g~aO#v~~dP!P!Qg~lO#w~~", 28, 129)],
  topRules: { StyleSheet: [0, 6], Styles: [1, 105] },
  specialized: [{ term: 124, get: (i) => fT[i] || -1 }, { term: 125, get: (i) => uT[i] || -1 }, { term: 4, get: (i) => dT[i] || -1 }, { term: 25, get: (i) => pT[i] || -1 }, { term: 123, get: (i) => OT[i] || -1 }],
  tokenPrec: 1963
});
let Dc = null;
function Lc() {
  if (!Dc && typeof document == "object" && document.body) {
    let { style: i } = document.body, e = [], t = /* @__PURE__ */ new Set();
    for (let n in i)
      n != "cssText" && n != "cssFloat" && typeof i[n] == "string" && (/[A-Z]/.test(n) && (n = n.replace(/[A-Z]/g, (r) => "-" + r.toLowerCase())), t.has(n) || (e.push(n), t.add(n)));
    Dc = e.sort().map((n) => ({ type: "property", label: n, apply: n + ": " }));
  }
  return Dc || [];
}
const $O = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((i) => ({ type: "class", label: i })), TO = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((i) => ({ type: "keyword", label: i })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((i) => ({ type: "constant", label: i }))), gT = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((i) => ({ type: "type", label: i })), bT = /* @__PURE__ */ [
  "@charset",
  "@color-profile",
  "@container",
  "@counter-style",
  "@font-face",
  "@font-feature-values",
  "@font-palette-values",
  "@import",
  "@keyframes",
  "@layer",
  "@media",
  "@namespace",
  "@page",
  "@position-try",
  "@property",
  "@scope",
  "@starting-style",
  "@supports",
  "@view-transition"
].map((i) => ({ type: "keyword", label: i })), cn = /^(\w[\w-]*|-\w[\w-]*|)$/, yT = /^-(-[\w-]*)?$/;
function vT(i, e) {
  var t;
  if ((i.name == "(" || i.type.isError) && (i = i.parent || i), i.name != "ArgList")
    return !1;
  let n = (t = i.parent) === null || t === void 0 ? void 0 : t.firstChild;
  return n?.name != "Callee" ? !1 : e.sliceString(n.from, n.to) == "var";
}
const CO = /* @__PURE__ */ new q0(), ST = ["Declaration"];
function wT(i) {
  for (let e = i; ; ) {
    if (e.type.isTop)
      return e;
    if (!(e = e.parent))
      return i;
  }
}
function Xb(i, e, t) {
  if (e.to - e.from > 4096) {
    let n = CO.get(e);
    if (n)
      return n;
    let r = [], s = /* @__PURE__ */ new Set(), o = e.cursor(Ye.IncludeAnonymous);
    if (o.firstChild())
      do
        for (let a of Xb(i, o.node, t))
          s.has(a.label) || (s.add(a.label), r.push(a));
      while (o.nextSibling());
    return CO.set(e, r), r;
  } else {
    let n = [], r = /* @__PURE__ */ new Set();
    return e.cursor().iterate((s) => {
      var o;
      if (t(s) && s.matchContext(ST) && ((o = s.node.nextSibling) === null || o === void 0 ? void 0 : o.name) == ":") {
        let a = i.sliceString(s.from, s.to);
        r.has(a) || (r.add(a), n.push({ label: a, type: "variable" }));
      }
    }), n;
  }
}
const xT = (i) => (e) => {
  let { state: t, pos: n } = e, r = Ke(t).resolveInner(n, -1), s = r.type.isError && r.from == r.to - 1 && t.doc.sliceString(r.from, r.to) == "-";
  if (r.name == "PropertyName" || (s || r.name == "TagName") && /^(Block|Styles)$/.test(r.resolve(r.to).name))
    return { from: r.from, options: Lc(), validFor: cn };
  if (r.name == "ValueName")
    return { from: r.from, options: TO, validFor: cn };
  if (r.name == "PseudoClassName")
    return { from: r.from, options: $O, validFor: cn };
  if (i(r) || (e.explicit || s) && vT(r, t.doc))
    return {
      from: i(r) || s ? r.from : n,
      options: Xb(t.doc, wT(r), i),
      validFor: yT
    };
  if (r.name == "TagName") {
    for (let { parent: l } = r; l; l = l.parent)
      if (l.name == "Block")
        return { from: r.from, options: Lc(), validFor: cn };
    return { from: r.from, options: gT, validFor: cn };
  }
  if (r.name == "AtKeyword")
    return { from: r.from, options: bT, validFor: cn };
  if (!e.explicit)
    return null;
  let o = r.resolve(n), a = o.childBefore(n);
  return a && a.name == ":" && o.name == "PseudoClassSelector" ? { from: n, options: $O, validFor: cn } : a && a.name == ":" && o.name == "Declaration" || o.name == "ArgList" ? { from: n, options: TO, validFor: cn } : o.name == "Block" || o.name == "Styles" ? { from: n, options: Lc(), validFor: cn } : null;
}, kT = /* @__PURE__ */ xT((i) => i.name == "VariableName"), dl = /* @__PURE__ */ ts.define({
  name: "css",
  parser: /* @__PURE__ */ mT.configure({
    props: [
      /* @__PURE__ */ Xl.add({
        Declaration: /* @__PURE__ */ Ca()
      }),
      /* @__PURE__ */ zl.add({
        "Block KeyframeList": J0
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function QT() {
  return new ru(dl, dl.data.of({ autocomplete: kT }));
}
const _T = 316, PT = 317, AO = 1, $T = 2, TT = 3, CT = 4, AT = 318, RT = 320, ET = 321, MT = 5, ZT = 6, XT = 0, pf = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], zb = 125, zT = 59, Of = 47, DT = 42, LT = 43, IT = 45, BT = 60, YT = 44, NT = 63, VT = 46, qT = 91, WT = new Sb({
  start: !1,
  shift(i, e) {
    return e == MT || e == ZT || e == RT ? i : e == ET;
  },
  strict: !1
}), jT = new si((i, e) => {
  let { next: t } = i;
  (t == zb || t == -1 || e.context) && i.acceptToken(AT);
}, { contextual: !0, fallback: !0 }), UT = new si((i, e) => {
  let { next: t } = i, n;
  pf.indexOf(t) > -1 || t == Of && ((n = i.peek(1)) == Of || n == DT) || t != zb && t != zT && t != -1 && !e.context && i.acceptToken(_T);
}, { contextual: !0 }), GT = new si((i, e) => {
  i.next == qT && !e.context && i.acceptToken(PT);
}, { contextual: !0 }), FT = new si((i, e) => {
  let { next: t } = i;
  if (t == LT || t == IT) {
    if (i.advance(), t == i.next) {
      i.advance();
      let n = !e.context && e.canShift(AO);
      i.acceptToken(n ? AO : $T);
    }
  } else t == NT && i.peek(1) == VT && (i.advance(), i.advance(), (i.next < 48 || i.next > 57) && i.acceptToken(TT));
}, { contextual: !0 });
function Ic(i, e) {
  return i >= 65 && i <= 90 || i >= 97 && i <= 122 || i == 95 || i >= 192 || !e && i >= 48 && i <= 57;
}
const HT = new si((i, e) => {
  if (i.next != BT || !e.dialectEnabled(XT) || (i.advance(), i.next == Of)) return;
  let t = 0;
  for (; pf.indexOf(i.next) > -1; )
    i.advance(), t++;
  if (Ic(i.next, !0)) {
    for (i.advance(), t++; Ic(i.next, !1); )
      i.advance(), t++;
    for (; pf.indexOf(i.next) > -1; )
      i.advance(), t++;
    if (i.next == YT) return;
    for (let n = 0; ; n++) {
      if (n == 7) {
        if (!Ic(i.next, !0)) return;
        break;
      }
      if (i.next != "extends".charCodeAt(n)) break;
      i.advance(), t++;
    }
  }
  i.acceptToken(CT, -t);
}), KT = El({
  "get set async static": T.modifier,
  "for while do if else switch try catch finally return throw break continue default case defer": T.controlKeyword,
  "in of await yield void typeof delete instanceof as satisfies": T.operatorKeyword,
  "let var const using function class extends": T.definitionKeyword,
  "import export from": T.moduleKeyword,
  "with debugger new": T.keyword,
  TemplateString: T.special(T.string),
  super: T.atom,
  BooleanLiteral: T.bool,
  this: T.self,
  null: T.null,
  Star: T.modifier,
  VariableName: T.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": T.function(T.variableName),
  VariableDefinition: T.definition(T.variableName),
  Label: T.labelName,
  PropertyName: T.propertyName,
  PrivatePropertyName: T.special(T.propertyName),
  "CallExpression/MemberExpression/PropertyName": T.function(T.propertyName),
  "FunctionDeclaration/VariableDefinition": T.function(T.definition(T.variableName)),
  "ClassDeclaration/VariableDefinition": T.definition(T.className),
  "NewExpression/VariableName": T.className,
  PropertyDefinition: T.definition(T.propertyName),
  PrivatePropertyDefinition: T.definition(T.special(T.propertyName)),
  UpdateOp: T.updateOperator,
  "LineComment Hashbang": T.lineComment,
  BlockComment: T.blockComment,
  Number: T.number,
  String: T.string,
  Escape: T.escape,
  ArithOp: T.arithmeticOperator,
  LogicOp: T.logicOperator,
  BitOp: T.bitwiseOperator,
  CompareOp: T.compareOperator,
  RegExp: T.regexp,
  Equals: T.definitionOperator,
  Arrow: T.function(T.punctuation),
  ": Spread": T.punctuation,
  "( )": T.paren,
  "[ ]": T.squareBracket,
  "{ }": T.brace,
  "InterpolationStart InterpolationEnd": T.special(T.brace),
  ".": T.derefOperator,
  ", ;": T.separator,
  "@": T.meta,
  TypeName: T.typeName,
  TypeDefinition: T.definition(T.typeName),
  "type enum interface implements namespace module declare": T.definitionKeyword,
  "abstract global Privacy readonly override": T.modifier,
  "is keyof unique infer asserts": T.operatorKeyword,
  JSXAttributeValue: T.attributeValue,
  JSXText: T.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": T.angleBracket,
  "JSXIdentifier JSXNameSpacedName": T.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": T.attributeName,
  "JSXBuiltin/JSXIdentifier": T.standard(T.tagName)
}), JT = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, in: 52, out: 55, const: 56, extends: 60, this: 64, true: 72, false: 72, null: 84, void: 88, typeof: 92, super: 108, new: 142, delete: 154, yield: 163, await: 167, class: 172, public: 235, private: 235, protected: 235, readonly: 237, instanceof: 256, satisfies: 259, import: 292, keyof: 349, unique: 353, infer: 359, asserts: 395, is: 397, abstract: 417, implements: 419, type: 421, let: 424, var: 426, using: 429, interface: 435, enum: 439, namespace: 445, module: 447, declare: 451, global: 455, defer: 471, for: 476, of: 485, while: 488, with: 492, do: 496, if: 500, else: 502, switch: 506, case: 512, try: 518, catch: 522, finally: 526, return: 530, throw: 534, break: 538, continue: 542, debugger: 546 }, e5 = { __proto__: null, async: 129, get: 131, set: 133, declare: 195, public: 197, private: 197, protected: 197, static: 199, abstract: 201, override: 203, readonly: 209, accessor: 211, new: 401 }, t5 = { __proto__: null, "<": 193 }, i5 = ss.deserialize({
  version: 14,
  states: "$F|Q%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Il'#IlO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JrO6[Q!0MxO'#JsO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO9XQMhO'#F|O9`Q`O'#F{OOQ!0Lf'#Js'#JsOOQ!0Lb'#Jr'#JrO9eQ`O'#GwOOQ['#K_'#K_O9pQ`O'#IYO9uQ!0LrO'#IZOOQ['#J`'#J`OOQ['#I_'#I_Q`QlOOQ`QlOOO9}Q!L^O'#DvO:UQlO'#EOO:]QlO'#EQO9kQ`O'#GsO:dQMhO'#CoO:rQ`O'#EnO:}Q`O'#EyO;hQMhO'#FeO;xQ`O'#GsOOQO'#K`'#K`O;}Q`O'#K`O<]Q`O'#G{O<]Q`O'#G|O<]Q`O'#HOO9kQ`O'#HRO=SQ`O'#HUO>kQ`O'#CeO>{Q`O'#HcO?TQ`O'#HiO?TQ`O'#HkO`QlO'#HmO?TQ`O'#HoO?TQ`O'#HrO?YQ`O'#HxO?_Q!0LsO'#IOO%[QlO'#IQO?jQ!0LsO'#ISO?uQ!0LsO'#IUO9uQ!0LrO'#IWO@QQ!0MxO'#CiOASQpO'#DlQOQ`OOO%[QlO'#EQOAjQ`O'#ETO:dQMhO'#EnOAuQ`O'#EnOBQQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Jv'#JvO%[QlO'#JvOOQO'#Jy'#JyOOQO'#Ih'#IhOCQQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J}'#J}OC|Q!0MSO'#EgODWQpO'#EWOOQO'#Jx'#JxODlQpO'#JyOEyQpO'#EWODWQpO'#EgPFWO&2DjO'#CbPOOO)CD})CD}OOOO'#I`'#I`OFcO#tO,59UOOQ!0Lh,59U,59UOOOO'#Ia'#IaOFqO&jO,59UOGPQ!L^O'#DcOOOO'#Ic'#IcOGWO#@ItO,59{OOQ!0Lf,59{,59{OGfQlO'#IdOGyQ`O'#JtOIxQ!fO'#JtO+}QlO'#JtOJPQ`O,5:ROJgQ`O'#EpOJtQ`O'#KTOKPQ`O'#KSOKPQ`O'#KSOKXQ`O,5;^OK^Q`O'#KROOQ!0Ln,5:^,5:^OKeQlO,5:^OMcQ!0MxO,5:fONSQ`O,5:nONmQ!0LrO'#KQONtQ`O'#KPO9eQ`O'#KPO! YQ`O'#KPO! bQ`O,5;]O! gQ`O'#KPO!#lQ!fO'#JsOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$[Q!fO,5:sOOQS'#Jz'#JzOOQO-E<j-E<jO9kQ`O,5=_O!$rQ`O,5=_O!$wQlO,5;ZO!&zQMhO'#EkO!(eQ`O,5;ZO!(jQlO'#DyO!(tQpO,5;dO!(|QpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)[QlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IpO!+_Q!0LrO,5<iO%[QlO,5;eO!&zQMhO,5;eO!+|QMhO,5;eO!-nQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-uQ,UO'#FjO!.rQ,UO'#KXO!.^Q,UO'#KXO!.yQ,UO'#KXOOQO'#KX'#KXO!/_Q,UO,5<SOOOW,5<`,5<`O!/pQlO'#FvOOOW'#Io'#IoO7VO7dO,5<QO!/wQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0hQ$IUO'#CyOOQ!0Lh'#C}'#C}O!0{O#@ItO'#DRO!1iQMjO,5<eO!1pQ`O,5<hO!3YQ(CWO'#GXO!3jQ`O'#GYO!3oQ`O'#GYO!5_Q(CWO'#G^O!6dQpO'#GbOOQO'#Gn'#GnO!,TQMhO'#GmOOQO'#Gp'#GpO!,TQMhO'#GoO!7VQ$IUO'#JlOOQ!0Lh'#Jl'#JlO!7aQ`O'#JkO!7oQ`O'#JjO!7wQ`O'#CuOOQ!0Lh'#C{'#C{O!8YQ`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO!8_Q`O,5<eO1SQ`O'#DZO!,TQMhO'#GPO!,TQMhO'#GRO!8gQ`O'#GTO!8lQ`O'#GUO!3oQ`O'#G[O!,TQMhO'#GaO<]Q`O'#JkO!8qQ`O'#EqO!9`Q`O,5<gOOQ!0Lb'#Cr'#CrO!9hQ`O'#ErO!:bQpO'#EsOOQ!0Lb'#KR'#KRO!:iQ!0LrO'#KaO9uQ!0LrO,5=cO`QlO,5>tOOQ['#Jh'#JhOOQ[,5>u,5>uOOQ[-E<]-E<]O!<hQ!0MxO,5:bO!:]QpO,5:`O!?RQ!0MxO,5:jO%[QlO,5:jO!AiQ!0MxO,5:lOOQO,5@z,5@zO!BYQMhO,5=_O!BhQ!0LrO'#JiO9`Q`O'#JiO!ByQ!0LrO,59ZO!CUQpO,59ZO!C^QMhO,59ZO:dQMhO,59ZO!CiQ`O,5;ZO!CqQ`O'#HbO!DVQ`O'#KdO%[QlO,5;}O!:]QpO,5<PO!D_Q`O,5=zO!DdQ`O,5=zO!DiQ`O,5=zO!DwQ`O,5=zO9uQ!0LrO,5=zO<]Q`O,5=jOOQO'#Cy'#CyO!EOQpO,5=gO!EWQMhO,5=hO!EcQ`O,5=jO!EhQ!bO,5=mO!EpQ`O'#K`O?YQ`O'#HWO9kQ`O'#HYO!EuQ`O'#HYO:dQMhO'#H[O!EzQ`O'#H[OOQ[,5=p,5=pO!FPQ`O'#H]O!FbQ`O'#CoO!FgQ`O,59PO!FqQ`O,59PO!HvQlO,59POOQ[,59P,59PO!IWQ!0LrO,59PO%[QlO,59PO!KcQlO'#HeOOQ['#Hf'#HfOOQ['#Hg'#HgO`QlO,5=}O!KyQ`O,5=}O`QlO,5>TO`QlO,5>VO!LOQ`O,5>XO`QlO,5>ZO!LTQ`O,5>^O!LYQlO,5>dOOQ[,5>j,5>jO%[QlO,5>jO9uQ!0LrO,5>lOOQ[,5>n,5>nO#!dQ`O,5>nOOQ[,5>p,5>pO#!dQ`O,5>pOOQ[,5>r,5>rO##QQpO'#D_O%[QlO'#JvO##sQpO'#JvO##}QpO'#DmO#$`QpO'#DmO#&qQlO'#DmO#&xQ`O'#JuO#'QQ`O,5:WO#'VQ`O'#EtO#'eQ`O'#KUO#'mQ`O,5;_O#'rQpO'#DmO#(PQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#(WQ`O,5:oO?YQ`O,5;YO!CUQpO,5;YO!C^QMhO,5;YO:dQMhO,5;YO#(`Q`O,5@bO#(eQ07dO,5:sOOQO-E<f-E<fO#)kQ!0MSO,5;RODWQpO,5:rO#)uQpO,5:rODWQpO,5;RO!ByQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#*SQ!0LrO,5;RO#*_Q!0LrO,5;RO!CUQpO,5:rOOQO,5;X,5;XO#*mQ!0LrO,5;RPOOO'#I^'#I^P#+RO&2DjO,58|POOO,58|,58|OOOO-E<^-E<^OOQ!0Lh1G.p1G.pOOOO-E<_-E<_OOOO,59},59}O#+^Q!bO,59}OOOO-E<a-E<aOOQ!0Lf1G/g1G/gO#+cQ!fO,5?OO+}QlO,5?OOOQO,5?U,5?UO#+mQlO'#IdOOQO-E<b-E<bO#+zQ`O,5@`O#,SQ!fO,5@`O#,ZQ`O,5@nOOQ!0Lf1G/m1G/mO%[QlO,5@oO#,cQ`O'#IjOOQO-E<h-E<hO#,ZQ`O,5@nOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@lO#,wQ!0LrO,5@lO#-YQ!0LrO,5@lO#-aQ`O,5@kO9eQ`O,5@kO#-iQ`O,5@kO#-wQ`O'#ImO#-aQ`O,5@kOOQ!0Lb1G0w1G0wO!(tQpO,5:uO!)PQpO,5:uOOQS,5:w,5:wO#.iQdO,5:wO#.qQMhO1G2yO9kQ`O1G2yOOQ!0Lf1G0u1G0uO#/PQ!0MxO1G0uO#0UQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0rQ!0MzO'#JlO!$wQlO1G0uO#2}Q!fO'#JwO%[QlO'#JwO#3XQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#3^Q`O1G1OO#5rQ!0MxO1G1PO#5yQ!0MxO1G1PO#8aQ!0MxO1G1PO#8hQ!0MxO1G1PO#;OQ!0MxO1G1PO#=fQ!0MxO1G1PO#=mQ!0MxO1G1PO#=tQ!0MxO1G1PO#@[Q!0MxO1G1PO#@cQ!0MxO1G1PO#BpQ?MtO'#CiO#DkQ?MtO1G1`O#DrQ?MtO'#JsO#EVQ!0MxO,5?[OOQ!0Lb-E<n-E<nO#GdQ!0MxO1G1PO#HaQ!0MzO1G1POOQ!0Lf1G1P1G1PO#IdQMjO'#J|O#InQ`O,5:xO#IsQ!0MxO1G1cO#JgQ,UO,5<WO#JoQ,UO,5<XO#JwQ,UO'#FoO#K`Q`O'#FnOOQO'#KY'#KYOOQO'#In'#InO#KeQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#KvQ?MtO'#JrO#LQQ`O,5<bO!)[QlO,5<bOOOW-E<m-E<mOOQ!0Lf1G1l1G1lO#LVQpO'#KXOOQ!0Lf,5<d,5<dO#L_QpO,5<dO#LdQMhO'#DTOOOO'#Ib'#IbO#LkO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8lQ`O'#IrO#LvQ`O,5<zOOQ!0Lh,5<w,5<wO!,TQMhO'#IuO#MdQMjO,5=XO!,TQMhO'#IwO#NVQMjO,5=ZO!&zQMhO,5=]OOQO1G2S1G2SO#NaQ!dO'#CrO#NtQ(CWO'#ErO$ |QpO'#GbO$!dQ!dO,5<sO$!kQ`O'#K[O9eQ`O'#K[O$!yQ`O,5<uO$#aQ!dO'#C{O!,TQMhO,5<tO$#kQ`O'#GZO$$PQ`O,5<tO$$UQ!dO'#GWO$$cQ!dO'#K]O$$mQ`O'#K]O!&zQMhO'#K]O$$rQ`O,5<xO$$wQlO'#JvO$%RQpO'#GcO#$`QpO'#GcO$%dQ`O'#GgO!3oQ`O'#GkO$%iQ!0LrO'#ItO$%tQpO,5<|OOQ!0Lp,5<|,5<|O$%{QpO'#GcO$&YQpO'#GdO$&kQpO'#GdO$&pQMjO,5=XO$'QQMjO,5=ZOOQ!0Lh,5=^,5=^O!,TQMhO,5@VO!,TQMhO,5@VO$'bQ`O'#IyO$'vQ`O,5@UO$(OQ`O,59aOOQ!0Lh,59i,59iO$(TQ`O,5@VO$)TQ$IYO,59uOOQ!0Lh'#Jp'#JpO$)vQMjO,5<kO$*iQMjO,5<mO@zQ`O,5<oOOQ!0Lh,5<p,5<pO$*sQ`O,5<vO$*xQMjO,5<{O$+YQ`O'#KPO!$wQlO1G2RO$+_Q`O1G2RO9eQ`O'#KSO9eQ`O'#EtO%[QlO'#EtO9eQ`O'#I{O$+dQ!0LrO,5@{OOQ[1G2}1G2}OOQ[1G4`1G4`OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$-fQ!0MxO1G0UOOQ[1G2y1G2yO!&zQMhO1G2yO%[QlO1G2yO#.tQ`O1G2yO$/jQMhO'#EkOOQ!0Lb,5@T,5@TO$/wQ!0LrO,5@TOOQ[1G.u1G.uO!ByQ!0LrO1G.uO!CUQpO1G.uO!C^QMhO1G.uO$0YQ`O1G0uO$0_Q`O'#CiO$0jQ`O'#KeO$0rQ`O,5=|O$0wQ`O'#KeO$0|Q`O'#KeO$1[Q`O'#JRO$1jQ`O,5AOO$1rQ!fO1G1iOOQ!0Lf1G1k1G1kO9kQ`O1G3fO@zQ`O1G3fO$1yQ`O1G3fO$2OQ`O1G3fO!DiQ`O1G3fO9uQ!0LrO1G3fOOQ[1G3f1G3fO!EcQ`O1G3UO!&zQMhO1G3RO$2TQ`O1G3ROOQ[1G3S1G3SO!&zQMhO1G3SO$2YQ`O1G3SO$2bQpO'#HQOOQ[1G3U1G3UO!6_QpO'#I}O!EhQ!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$2jQMhO,5=tO9kQ`O,5=tO$%dQ`O,5=vO9`Q`O,5=vO!CUQpO,5=vO!C^QMhO,5=vO:dQMhO,5=vO$2xQ`O'#KcO$3TQ`O,5=wOOQ[1G.k1G.kO$3YQ!0LrO1G.kO@zQ`O1G.kO$3eQ`O1G.kO9uQ!0LrO1G.kO$5mQ!fO,5AQO$5zQ`O,5AQO9eQ`O,5AQO$6VQlO,5>PO$6^Q`O,5>POOQ[1G3i1G3iO`QlO1G3iOOQ[1G3o1G3oOOQ[1G3q1G3qO?TQ`O1G3sO$6cQlO1G3uO$:gQlO'#HtOOQ[1G3x1G3xO$:tQ`O'#HzO?YQ`O'#H|OOQ[1G4O1G4OO$:|QlO1G4OO9uQ!0LrO1G4UOOQ[1G4W1G4WOOQ!0Lb'#G_'#G_O9uQ!0LrO1G4YO9uQ!0LrO1G4[O$?TQ`O,5@bO!)[QlO,5;`O9eQ`O,5;`O?YQ`O,5:XO!)[QlO,5:XO!CUQpO,5:XO$?YQ?MtO,5:XOOQO,5;`,5;`O$?dQpO'#IeO$?zQ`O,5@aOOQ!0Lf1G/r1G/rO$@SQpO'#IkO$@^Q`O,5@pOOQ!0Lb1G0y1G0yO#$`QpO,5:XOOQO'#Ig'#IgO$@fQpO,5:qOOQ!0Ln,5:q,5:qO#(ZQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO?YQ`O1G0tO!CUQpO1G0tO!C^QMhO1G0tOOQ!0Lb1G5|1G5|O!ByQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$@mQ!0LrO1G0mO$@xQ!0LrO1G0mO!CUQpO1G0^ODWQpO1G0^O$AWQ!0LrO1G0mOOQO1G0^1G0^O$AlQ!0MxO1G0mPOOO-E<[-E<[POOO1G.h1G.hOOOO1G/i1G/iO$AvQ!bO,5<iO$BOQ!fO1G4jOOQO1G4p1G4pO%[QlO,5?OO$BYQ`O1G5zO$BbQ`O1G6YO$BjQ!fO1G6ZO9eQ`O,5?UO$BtQ!0MxO1G6WO%[QlO1G6WO$CUQ!0LrO1G6WO$CgQ`O1G6VO$CgQ`O1G6VO9eQ`O1G6VO$CoQ`O,5?XO9eQ`O,5?XOOQO,5?X,5?XO$DTQ`O,5?XO$+YQ`O,5?XOOQO-E<k-E<kOOQS1G0a1G0aOOQS1G0c1G0cO#.lQ`O1G0cOOQ[7+(e7+(eO!&zQMhO7+(eO%[QlO7+(eO$DcQ`O7+(eO$DnQMhO7+(eO$D|Q!0MzO,5=XO$GXQ!0MzO,5=ZO$IdQ!0MzO,5=XO$KuQ!0MzO,5=ZO$NWQ!0MzO,59uO%!]Q!0MzO,5<kO%$hQ!0MzO,5<mO%&sQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%)UQ!0MxO7+&aO%)xQlO'#IfO%*VQ`O,5@cO%*_Q!fO,5@cOOQ!0Lf1G0P1G0PO%*iQ`O7+&jOOQ!0Lf7+&j7+&jO%*nQ?MtO,5:fO%[QlO7+&zO%*xQ?MtO,5:bO%+VQ?MtO,5:jO%+aQ?MtO,5:lO%+kQMhO'#IiO%+uQ`O,5@hOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%+}Q!jO,5<ZO!)[QlO,5<YOOQO-E<l-E<lOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%,YQ`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%,_Q!dO,59oOOOO-E<`-E<`OOQ!0Lh1G/X1G/XO%,fQ!0MxO7+'kOOQ!0Lh,5?^,5?^O%-YQMhO1G2fP%-aQ`O'#IrPOQ!0Lh-E<p-E<pO%-}QMjO,5?aOOQ!0Lh-E<s-E<sO%.pQMjO,5?cOOQ!0Lh-E<u-E<uO%.zQ!dO1G2wO%/RQ!dO'#CrO%/iQMhO'#KSO$$wQlO'#JvOOQ!0Lh1G2_1G2_O%/sQ`O'#IqO%0[Q`O,5@vO%0[Q`O,5@vO%0dQ`O,5@vO%0oQ`O,5@vOOQO1G2a1G2aO%0}QMjO1G2`O$+YQ`O'#K[O!,TQMhO1G2`O%1_Q(CWO'#IsO%1lQ`O,5@wO!&zQMhO,5@wO%1tQ!dO,5@wOOQ!0Lh1G2d1G2dO%4UQ!fO'#CiO%4`Q`O,5=POOQ!0Lb,5<},5<}O%4hQpO,5<}OOQ!0Lb,5=O,5=OOCwQ`O,5<}O%4sQpO,5<}OOQ!0Lb,5=R,5=RO$+YQ`O,5=VOOQO,5?`,5?`OOQO-E<r-E<rOOQ!0Lp1G2h1G2hO#$`QpO,5<}O$$wQlO,5=PO%5RQ`O,5=OO%5^QpO,5=OO!,TQMhO'#IuO%6WQMjO1G2sO!,TQMhO'#IwO%6yQMjO1G2uO%7TQMjO1G5qO%7_QMjO1G5qOOQO,5?e,5?eOOQO-E<w-E<wOOQO1G.{1G.{O!,TQMhO1G5qO!,TQMhO1G5qO!:]QpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%7lQ`O1G2ZO!,TQMhO1G2bO%7qQ!0MxO7+'mOOQ!0Lf7+'m7+'mO!$wQlO7+'mO%8eQ`O,5;`OOQ!0Lb,5?g,5?gOOQ!0Lb-E<y-E<yO%8jQ!dO'#K^O#(ZQ`O7+(eO4UQ!fO7+(eO$DfQ`O7+(eO%8tQ!0MvO'#CiO%9XQ!0MvO,5=SO%9lQ`O,5=SO%9tQ`O,5=SOOQ!0Lb1G5o1G5oOOQ[7+$a7+$aO!ByQ!0LrO7+$aO!CUQpO7+$aO!$wQlO7+&aO%9yQ`O'#JQO%:bQ`O,5APOOQO1G3h1G3hO9kQ`O,5APO%:bQ`O,5APO%:jQ`O,5APOOQO,5?m,5?mOOQO-E=P-E=POOQ!0Lf7+'T7+'TO%:oQ`O7+)QO9uQ!0LrO7+)QO9kQ`O7+)QO@zQ`O7+)QO%:tQ`O7+)QOOQ[7+)Q7+)QOOQ[7+(p7+(pO%:yQ!0MvO7+(mO!&zQMhO7+(mO!E^Q`O7+(nOOQ[7+(n7+(nO!&zQMhO7+(nO%;TQ`O'#KbO%;`Q`O,5=lOOQO,5?i,5?iOOQO-E<{-E<{OOQ[7+(s7+(sO%<rQpO'#HZOOQ[1G3`1G3`O!&zQMhO1G3`O%[QlO1G3`O%<yQ`O1G3`O%=UQMhO1G3`O9uQ!0LrO1G3bO$%dQ`O1G3bO9`Q`O1G3bO!CUQpO1G3bO!C^QMhO1G3bO%=dQ`O'#JPO%=xQ`O,5@}O%>QQpO,5@}OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@zQ`O7+$VO9uQ!0LrO7+$VO%>]Q`O7+$VO%[QlO1G6lO%[QlO1G6mO%>bQ!0LrO1G6lO%>lQlO1G3kO%>sQ`O1G3kO%>xQlO1G3kOOQ[7+)T7+)TO9uQ!0LrO7+)_O`QlO7+)aOOQ['#Kh'#KhOOQ['#JS'#JSO%?PQlO,5>`OOQ[,5>`,5>`O%[QlO'#HuO%?^Q`O'#HwOOQ[,5>f,5>fO9eQ`O,5>fOOQ[,5>h,5>hOOQ[7+)j7+)jOOQ[7+)p7+)pOOQ[7+)t7+)tOOQ[7+)v7+)vO%?cQpO1G5|O%?}Q?MtO1G0zO%@XQ`O1G0zOOQO1G/s1G/sO%@dQ?MtO1G/sO?YQ`O1G/sO!)[QlO'#DmOOQO,5?P,5?POOQO-E<c-E<cOOQO,5?V,5?VOOQO-E<i-E<iO!CUQpO1G/sOOQO-E<e-E<eOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#(ZQ`O7+%uOOQ!0Lf7+&`7+&`O?YQ`O7+&`O!CUQpO7+&`OOQO7+%x7+%xO$AlQ!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%@nQ!0LrO7+&XO!ByQ!0LrO7+%xO!CUQpO7+%xO%@yQ!0LrO7+&XO%AXQ!0MxO7++rO%[QlO7++rO%AiQ`O7++qO%AiQ`O7++qOOQO1G4s1G4sO9eQ`O1G4sO%AqQ`O1G4sOOQS7+%}7+%}O#(ZQ`O<<LPO4UQ!fO<<LPO%BPQ`O<<LPOOQ[<<LP<<LPO!&zQMhO<<LPO%[QlO<<LPO%BXQ`O<<LPO%BdQ!0MzO,5?aO%DoQ!0MzO,5?cO%FzQ!0MzO1G2`O%I]Q!0MzO1G2sO%KhQ!0MzO1G2uO%MsQ!fO,5?QO%[QlO,5?QOOQO-E<d-E<dO%M}Q`O1G5}OOQ!0Lf<<JU<<JUO%NVQ?MtO1G0uO&!^Q?MtO1G1PO&!eQ?MtO1G1PO&$fQ?MtO1G1PO&$mQ?MtO1G1PO&&nQ?MtO1G1PO&(oQ?MtO1G1PO&(vQ?MtO1G1PO&(}Q?MtO1G1PO&+OQ?MtO1G1PO&+VQ?MtO1G1PO&+^Q!0MxO<<JfO&-UQ?MtO1G1PO&.RQ?MvO1G1PO&/UQ?MvO'#JlO&1[Q?MtO1G1cO&1iQ?MtO1G0UO&1sQMjO,5?TOOQO-E<g-E<gO!)[QlO'#FqOOQO'#KZ'#KZOOQO1G1u1G1uO&1}Q`O1G1tO&2SQ?MtO,5?[OOOW7+'h7+'hOOOO1G/Z1G/ZO&2^Q!dO1G4xOOQ!0Lh7+(Q7+(QP!&zQMhO,5?^O!,TQMhO7+(cO&2eQ`O,5?]O9eQ`O,5?]O$+YQ`O,5?]OOQO-E<o-E<oO&2sQ`O1G6bO&2sQ`O1G6bO&2{Q`O1G6bO&3WQMjO7+'zO&3hQ!dO,5?_O&3rQ`O,5?_O!&zQMhO,5?_OOQO-E<q-E<qO&3wQ!dO1G6cO&4RQ`O1G6cO&4ZQ`O1G2kO!&zQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%4hQpO1G2iO!CUQpO1G2iOCwQ`O1G2iOOQ!0Lb1G2q1G2qO&4`QpO1G2iO&4nQ`O1G2kO$+YQ`O1G2jOCwQ`O1G2jO$$wQlO1G2kO&4vQ`O1G2jO&5jQMjO,5?aOOQ!0Lh-E<t-E<tO&6]QMjO,5?cOOQ!0Lh-E<v-E<vO!,TQMhO7++]O&6gQMjO7++]O&6qQMjO7++]OOQ!0Lh1G/c1G/cO&7OQ`O1G/cOOQ!0Lh7+'u7+'uO&7TQMjO7+'|O&7eQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&8XQ`O1G0zO!&zQMhO'#IzO&8^Q`O,5@xO&:`Q!fO<<LPO!&zQMhO1G2nO&:gQ!0LrO1G2nOOQ[<<G{<<G{O!ByQ!0LrO<<G{O&:xQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?l,5?lO&;lQ`O,5?lO&;qQ`O,5?lOOQO-E=O-E=OO&<PQ`O1G6kO&<PQ`O1G6kO9kQ`O1G6kO@zQ`O<<LlOOQ[<<Ll<<LlO&<XQ`O<<LlO9uQ!0LrO<<LlO9kQ`O<<LlOOQ[<<LX<<LXO%:yQ!0MvO<<LXOOQ[<<LY<<LYO!E^Q`O<<LYO&<^QpO'#I|O&<iQ`O,5@|O!)[QlO,5@|OOQ[1G3W1G3WOOQO'#JO'#JOO9uQ!0LrO'#JOO&<qQpO,5=uOOQ[,5=u,5=uO&<xQpO'#EgO&=PQpO'#GeO&=UQ`O7+(zO&=ZQ`O7+(zOOQ[7+(z7+(zO!&zQMhO7+(zO%[QlO7+(zO&=cQ`O7+(zOOQ[7+(|7+(|O9uQ!0LrO7+(|O$%dQ`O7+(|O9`Q`O7+(|O!CUQpO7+(|O&=nQ`O,5?kOOQO-E<}-E<}OOQO'#H^'#H^O&=yQ`O1G6iO9uQ!0LrO<<GqOOQ[<<Gq<<GqO@zQ`O<<GqO&>RQ`O7+,WO&>WQ`O7+,XO%[QlO7+,WO%[QlO7+,XOOQ[7+)V7+)VO&>]Q`O7+)VO&>bQlO7+)VO&>iQ`O7+)VOOQ[<<Ly<<LyOOQ[<<L{<<L{OOQ[-E=Q-E=QOOQ[1G3z1G3zO&>nQ`O,5>aOOQ[,5>c,5>cO&>sQ`O1G4QO9eQ`O7+&fO!)[QlO7+&fOOQO7+%_7+%_O&>xQ?MtO1G6ZO?YQ`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO?YQ`O<<IzOOQO<<Is<<IsO$AlQ!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!ByQ!0LrO<<IdO&?SQ!0LrO<<IsO&?_Q!0MxO<= ^O&?oQ`O<= ]OOQO7+*_7+*_O9eQ`O7+*_OOQ[ANAkANAkO&?wQ!fOANAkO!&zQMhOANAkO#(ZQ`OANAkO4UQ!fOANAkO&@OQ`OANAkO%[QlOANAkO&@WQ!0MzO7+'zO&BiQ!0MzO,5?aO&DtQ!0MzO,5?cO&GPQ!0MzO7+'|O&IbQ!fO1G4lO&IlQ?MtO7+&aO&KpQ?MvO,5=XO&MwQ?MvO,5=ZO&NXQ?MvO,5=XO&NiQ?MvO,5=ZO&NyQ?MvO,59uO'#PQ?MvO,5<kO'%SQ?MvO,5<mO''hQ?MvO,5<{O')^Q?MtO7+'kO')kQ?MtO7+'mO')xQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*d7+*dO')}QMjO<<K}OOQO1G4w1G4wO'*UQ`O1G4wO'*aQ`O1G4wO'*oQ`O7++|O'*oQ`O7++|O!&zQMhO1G4yO'*wQ!dO1G4yO'+RQ`O7++}O'+ZQ`O7+(VO'+fQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!CUQpO7+(TOCwQ`O7+(TO'+pQ`O7+(VO!&zQMhO7+(VO$+YQ`O7+(UO'+uQ`O7+(VOCwQ`O7+(UO'+}QMjO<<NwO!,TQMhO<<NwOOQ!0Lh7+$}7+$}O',XQ!dO,5?fOOQO-E<x-E<xO',cQ!0MvO7+(YO!&zQMhO7+(YOOQ[AN=gAN=gO9kQ`O1G5WOOQO1G5W1G5WO',sQ`O1G5WO',xQ`O7+,VO',xQ`O7+,VO9uQ!0LrOANBWO@zQ`OANBWOOQ[ANBWANBWO'-QQ`OANBWOOQ[ANAsANAsOOQ[ANAtANAtO'-VQ`O,5?hOOQO-E<z-E<zO'-bQ?MtO1G6hOOQO,5?j,5?jOOQO-E<|-E<|OOQ[1G3a1G3aO'-lQ`O,5=POOQ[<<Lf<<LfO!&zQMhO<<LfO&=UQ`O<<LfO'-qQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9uQ!0LrO<<LhO$%dQ`O<<LhO9`Q`O<<LhO'-yQpO1G5VO'.UQ`O7+,TOOQ[AN=]AN=]O9uQ!0LrOAN=]OOQ[<= r<= rOOQ[<= s<= sO'.^Q`O<= rO'.cQ`O<= sOOQ[<<Lq<<LqO'.hQ`O<<LqO'.mQlO<<LqOOQ[1G3{1G3{O?YQ`O7+)lO'.tQ`O<<JQO'/PQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$AlQ!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<My<<MyOOQ[G27VG27VO!&zQMhOG27VO#(ZQ`OG27VO'/ZQ!fOG27VO4UQ!fOG27VO'/bQ`OG27VO'/jQ?MtO<<JfO'/wQ?MvO1G2`O'1mQ?MvO,5?aO'3pQ?MvO,5?cO'5sQ?MvO1G2sO'7vQ?MvO1G2uO'9yQ?MtO<<KXO':WQ?MtO<<I{OOQO1G1w1G1wO!,TQMhOANAiOOQO7+*c7+*cO':eQ`O7+*cO':pQ`O<= hO':xQ!dO7+*eOOQ!0Lb<<Kq<<KqO$+YQ`O<<KqOCwQ`O<<KqO';SQ`O<<KqO!&zQMhO<<KqOOQ!0Lb<<Ko<<KoO!CUQpO<<KoO';_Q!dO<<KqOOQ!0Lb<<Kp<<KpO';iQ`O<<KqO!&zQMhO<<KqO$+YQ`O<<KpO';nQMjOANDcO';xQ!0MvO<<KtOOQO7+*r7+*rO9kQ`O7+*rO'<YQ`O<= qOOQ[G27rG27rO9uQ!0LrOG27rO@zQ`OG27rO!)[QlO1G5SO'<bQ`O7+,SO'<jQ`O1G2kO&=UQ`OANBQOOQ[ANBQANBQO!&zQMhOANBQO'<oQ`OANBQOOQ[ANBSANBSO9uQ!0LrOANBSO$%dQ`OANBSOOQO'#H_'#H_OOQO7+*q7+*qOOQ[G22wG22wOOQ[ANE^ANE^OOQ[ANE_ANE_OOQ[ANB]ANB]O'<wQ`OANB]OOQ[<<MW<<MWO!)[QlOAN?lOOQOG24yG24yO$AlQ!0MxOG24yO#(ZQ`OLD,qOOQ[LD,qLD,qO!&zQMhOLD,qO'<|Q!fOLD,qO'=TQ?MvO7+'zO'>yQ?MvO,5?aO'@|Q?MvO,5?cO'CPQ?MvO7+'|O'DuQMjOG27TOOQO<<M}<<M}OOQ!0LbANA]ANA]O$+YQ`OANA]OCwQ`OANA]O'EVQ!dOANA]OOQ!0LbANAZANAZO'E^Q`OANA]O!&zQMhOANA]O'EiQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N^<<N^OOQ[LD-^LD-^O9uQ!0LrOLD-^O'EsQ?MtO7+*nOOQO'#Gf'#GfOOQ[G27lG27lO&=UQ`OG27lO!&zQMhOG27lOOQ[G27nG27nO9uQ!0LrOG27nOOQ[G27wG27wO'E}Q?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#(ZQ`O!$(!]O!&zQMhO!$(!]O'FXQ!0MzOG27TOOQ!0LbG26wG26wO$+YQ`OG26wO'HjQ`OG26wOCwQ`OG26wO'HuQ!dOG26wO!&zQMhOG26wOOQ[!$(!x!$(!xOOQ[LD-WLD-WO&=UQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#(ZQ`O!)9EwOOQ!0LbLD,cLD,cO$+YQ`OLD,cOCwQ`OLD,cO'H|Q`OLD,cO'IXQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'I`Q?MvOG27TOOQ!0Lb!$( }!$( }O$+YQ`O!$( }OCwQ`O!$( }O'KUQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$+YQ`O!)9EiOCwQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$+YQ`O!.K;TOOQ!0Lb!4/0o!4/0oO!)[QlO'#DzO1PQ`O'#EXO'KaQ!fO'#JrO'KhQ!L^O'#DvO'KoQlO'#EOO'KvQ!fO'#CiO'N^Q!fO'#CiO!)[QlO'#EQO'NnQlO,5;ZO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO'#IpO(!qQ`O,5<iO!)[QlO,5;eO(!yQMhO,5;eO($dQMhO,5;eO!)[QlO,5;wO!&zQMhO'#GmO(!yQMhO'#GmO!&zQMhO'#GoO(!yQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&zQMhO'#GPO(!yQMhO'#GPO!&zQMhO'#GRO(!yQMhO'#GRO!&zQMhO'#GaO(!yQMhO'#GaO!)[QlO,5:jO($kQpO'#D_O($uQpO'#JvO!)[QlO,5@oO'NnQlO1G0uO(%PQ?MtO'#CiO!)[QlO1G2PO!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO(%ZQ!dO'#CrO!&zQMhO,5<tO(!yQMhO,5<tO'NnQlO1G2RO!)[QlO7+&zO!&zQMhO1G2`O(!yQMhO1G2`O!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO!&zQMhO1G2bO(!yQMhO1G2bO'NnQlO7+'mO'NnQlO7+&aO!&zQMhOANAiO(!yQMhOANAiO(%nQ`O'#EoO(%sQ`O'#EoO(%{Q`O'#F]O(&QQ`O'#EyO(&VQ`O'#KTO(&bQ`O'#KRO(&mQ`O,5;ZO(&rQMjO,5<eO(&yQ`O'#GYO('OQ`O'#GYO('TQ`O,5<eO(']Q`O,5<gO('eQ`O,5;ZO('mQ?MtO1G1`O('tQ`O,5<tO('yQ`O,5<tO((OQ`O,5<vO((TQ`O,5<vO((YQ`O1G2RO((_Q`O1G0uO((dQMjO<<K}O((kQMjO<<K}O((rQMhO'#F|O9`Q`O'#F{OAuQ`O'#EnO!)[QlO,5;tO!3oQ`O'#GYO!3oQ`O'#GYO!3oQ`O'#G[O!3oQ`O'#G[O!,TQMhO7+(cO!,TQMhO7+(cO%.zQ!dO1G2wO%.zQ!dO1G2wO!&zQMhO,5=]O!&zQMhO,5=]",
  stateData: "()x~O'|OS'}OSTOS(ORQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&W!WO&^!XO&`!YO&b!ZO&d![O&g!]O&m!^O&s!_O&u!`O&w!aO&y!bO&{!cO(TSO(VTO(YUO(aVO(o[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O(O!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'z]X(a]X(r]X(y]X(z]X~O!g%RX~P(qO_!}O(V#PO(W!}O(X#PO~O_#QO(X#PO(Y#PO(Z#QO~Ox#SO!U#TO(b#TO(c#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T<ZO(VTO(YUO(aVO(o[O~O![#ZO!]#WO!Y(hP!Y(vP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(VTO(YUO(aVO(o[O~Op#mO![#iO!|]O#i#lO#j#iO(T<[O!k(sP~P.iO!l#oO(T#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa(fX'z(fX'w(fX!k(fX!Y(fX!_(fX%i(fX!g(fX~P1qO#S$dO#`$eO$Q$eOP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX!_(gX%i(gX~Oa(gX'z(gX'w(gX!Y(gX!k(gXv(gX!g(gX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%dOk%dOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T$sO(VTO(YUO(a$uO(y$}O(z%POg(^P~Ol%[O~P7eO!l%eO~O!S%hO!_%iO(T%gO~O!g%mO~Oa%nO'z%nO~O!Q%rO~P%[O(U!lO~P%[O%n%vO~P%[Oh%VO!l%eO(T%gO(U!lO~Oe%}O!l%eO(T%gO~Oj$RO~O!_&PO(T%gO(U!lO(VTO(YUO`)WP~O!Q&SO!l&RO%j&VO&T&WO~P;SO!x#sO~O%s&YO!S)SX!_)SX(T)SX~O(T&ZO~Ol!PO!u&`O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&eOe&dO!x&bO%h&cO%{&aO~P<bOd&hOeyOl!PO!_&gO!u&`O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&kO#`&nO%j&iO(U!lO~P=gO!l&oO!u&sO~O!l#oO~O!_XO~Oa%nO'x&{O'z%nO~Oa%nO'x'OO'z%nO~Oa%nO'x'QO'z%nO~O'w]X!Y]Xv]X!k]X&[]X!_]X%i]X!g]X~P(qO!b'_O!c'WO!d'WO(U!lO(VTO(YUO~Os'UO!S'TO!['XO(e'SO!^(iP!^(xP~P@nOn'bO!_'`O(T%gO~Oe'gO!l%eO(T%gO~O!Q&SO!l&RO~Os!nO!S!oO!|<VO#T!pO#U!pO#W!pO#X!pO(U!lO(VTO(YUO(e!mO(o!sO~O!b'mO!c'lO!d'lO#V!pO#['nO#]'nO~PBYOa%nOh%VO!g#vO!l%eO'z%nO(r'pO~O!p'tO#`'rO~PChOs!nO!S!oO(VTO(YUO(e!mO(o!sO~O!_XOs(mX!S(mX!b(mX!c(mX!d(mX!|(mX#T(mX#U(mX#V(mX#W(mX#X(mX#[(mX#](mX(U(mX(V(mX(Y(mX(e(mX(o(mX~O!c'lO!d'lO(U!lO~PDWO(P'xO(Q'xO(R'zO~O_!}O(V'|O(W!}O(X'|O~O_#QO(X'|O(Y'|O(Z#QO~Ov(OO~P%[Ox#SO!U#TO(b#TO(c(RO~O![(TO!Y'WX!Y'^X!]'WX!]'^X~P+}O!](VO!Y(hX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](VO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~O!Y(hX~PHRO!Y([O~O!Y(uX!](uX!g(uX!k(uX(r(uX~O#`(uX#k#dX!^(uX~PJUO#`(]O!Y(wX!](wX~O!](^O!Y(vX~O!Y(aO~O#`$eO~PJUO!^(bO~P`OR#zO!Q#yO!S#{O!l#xO(aVOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(r!na(y!na(z!na~Oa!na'z!na'w!na!Y!na!k!nav!na!_!na%i!na!g!na~PKlO!k(cO~O!g#vO#`(dO(r'pO!](tXa(tX'z(tX~O!k(tX~PNXO!S%hO!_%iO!|]O#i(iO#j(hO(T%gO~O!](jO!k(sX~O!k(lO~O!S%hO!_%iO#j(hO(T%gO~OP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~O!g#vO!k(gX~P! uOR(nO!Q(mO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(T!{a~P!#vO!x(rO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~O#k(xO~O![(zO!k(kP~P%[O(e(|O(o[O~O!S)OO!l#xO(e(|O(o[O~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]$_Oa$qa'z$qa'w$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)dO~P!&zOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Og(pP~P!,TO!Q)iO!g)hO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)hO!_({X$Z({X$]({X$_({X$f({X~O!Q)iO~P!.^O!Q)iO!_({X$Z({X$]({X$_({X$f({X~O!_)kO$Z)oO$])jO$_)jO$f)pO~O![)sO~P!)[O$]$hO$_$gO$f)wO~On$zX!Q$zX#S$zX'y$zX(y$zX(z$zX~OgmXg$zXnmX!]mX#`mX~P!0SOx)yO(b)zO(c)|O~On*VO!Q*OO'y*PO(y$}O(z%PO~Og)}O~P!1WOg*WO~Oh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S*YO!_*ZO!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op*`O![*^O(T*XO!k)OP~P!1uO#k*aO~O!l*bO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T*dO(VTO(YUO(a$uO(y$}O(z%PO~O![*gO!Y)PP~P!3tOr*sOs!nO!S*iO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO(e!mO~O!^*pO~P!5iO#S$dOn(`X!Q(`X'y(`X(y(`X(z(`X!](`X#`(`X~Og(`X$O(`X~P!6kOn*xO#`*wOg(_X!](_X~O!]*yOg(^X~Oj%dOk%dOl%dO(T&ZOg(^P~Os*|O~Og)}O(T&ZO~O!l+SO~O(T(vO~Op+WO!S%hO![#iO!_%iO!|]O#i#lO#j#iO(T%gO!k(sP~O!g#vO#k+XO~O!S%hO![+ZO!](^O!_%iO(T%gO!Y(vP~Os'[O!S+]O![+[O(VTO(YUO(e(|O~O!^(xP~P!9|O!]+^Oa)TX'z)TX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa!ja!]!ja'z!ja'w!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:tOR#zO!Q#yO!S#{O!l#xO(aVOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(r!ra(y!ra(z!ra~Oa!ra'z!ra'w!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!=[OR#zO!Q#yO!S#{O!l#xO(aVOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(r!ta(y!ta(z!ta~Oa!ta'z!ta'w!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?rOh%VOn+gO!_'`O%i+fO~O!g+iOa(]X!_(]X'z(]X!](]X~Oa%nO!_XO'z%nO~Oh%VO!l%eO~Oh%VO!l%eO(T%gO~O!g#vO#k(xO~Ob+tO%j+uO(T+qO(VTO(YUO!^)XP~O!]+vO`)WX~O[+zO~O`+{O~O!_&PO(T%gO(U!lO`)WP~O%j,OO~P;SOh%VO#`,SO~Oh%VOn,VO!_$|O~O!_,XO~O!Q,ZO!_XO~O%n%vO~O!x,`O~Oe,eO~Ob,fO(T#nO(VTO(YUO!^)VP~Oe%}O~O%j!QO(T&ZO~P=gO[,kO`,jO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(VTO(YUO(aVO(o[O~O!_!eO!u!gO$W!kO(T!dO~P!FyO`,jOa%nO'z%nO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa,pOl!OO!uwO%l!OO%m!OO%n!OO~P!IcO!l&oO~O&^,vO~O!_,xO~O&o,zO&q,{OP&laQ&laS&laY&laa&lad&lae&lal&lap&lar&las&lat&laz&la|&la!O&la!S&la!W&la!X&la!_&la!i&la!l&la!o&la!p&la!q&la!s&la!u&la!x&la!|&la$W&la$n&la%h&la%j&la%l&la%m&la%n&la%q&la%s&la%v&la%w&la%y&la&W&la&^&la&`&la&b&la&d&la&g&la&m&la&s&la&u&la&w&la&y&la&{&la'w&la(T&la(V&la(Y&la(a&la(o&la!^&la&e&lab&la&j&la~O(T-QO~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P#!iO!g-VO#`-UOh(jX!]#hX!^#hX!g(jX!l(jX~O!](jX!^(jX~P##[Oh%VO!g-XO!l%eO!]!aX!^!aX~Os!nO!S!oO(VTO(YUO(e!mO~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(VTO(YUO(aVO(o[O~O(T=QO~P#$qO!]-]O!^(iX~O!^-_O~O!g-VO#`-UO!]#hX!^#hX~O!]-`O!^(xX~O!^-bO~O!c-cO!d-cO(U!lO~P#$`O!^-fO~P'_On-iO!_'`O~O!Y-nO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(U!{a(V!{a(Y!{a(e!{a(o!{a~P!#vO!p-sO#`-qO~PChO!c-uO!d-uO(U!lO~PDWOa%nO#`-qO'z%nO~Oa%nO!g#vO#`-qO'z%nO~Oa%nO!g#vO!p-sO#`-qO'z%nO(r'pO~O(P'xO(Q'xO(R-zO~Ov-{O~O!Y'Wa!]'Wa~P!:tO![.PO!Y'WX!]'WX~P%[O!](VO!Y(ha~O!Y(ha~PHRO!](^O!Y(va~O!S%hO![.TO!_%iO(T%gO!Y'^X!]'^X~O#`.VO!](ta!k(taa(ta'z(ta~O!g#vO~P#,wO!](jO!k(sa~O!S%hO!_%iO#j.ZO(T%gO~Op.`O!S%hO![.]O!_%iO!|]O#i._O#j.]O(T%gO!]'aX!k'aX~OR.dO!l#xO~Oh%VOn.gO!_'`O%i.fO~Oa#ci!]#ci'z#ci'w#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:tOn>]O!Q*OO'y*PO(y$}O(z%PO~O#k#_aa#_a#`#_a'z#_a!]#_a!k#_a!_#_a!Y#_a~P#/sO#k(`XP(`XR(`X[(`Xa(`Xj(`Xr(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X'z(`X(a(`X(r(`X!k(`X!Y(`X'w(`Xv(`X!_(`X%i(`X!g(`X~P!6kO!].tO!k(kX~P!:tO!k.wO~O!Y.yO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#3cO#n$OO~P#3cOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#6QO#r$QO~P#6QOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(aVOa#mi!]#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(aVO(z#}Oa#mi!]#mi#z#mi#{#mi'z#mi(r#mi(y#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#;VO#x#mi~P#;VO#v$SO~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(aVO(y#|O(z#}Oa#mi!]#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#={O#z$WO~P#={OP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X!]]X!^]X~O$O]X~P#@jOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO#z<gO#{<hO(aVO(r$YO(y#|O(z#}O~O$O.{O~P#BwO#S$dO#`<nO$Q<nO$O(gX!^(gX~P! uOa'da!]'da'z'da'w'da!k'da!Y'dav'da!_'da%i'da!g'da~P!:tO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO(y#mi(z#mi~P#EyOn>]O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P#EyO!]/POg(pX~P!1WOg/RO~Oa$Pi!]$Pi'z$Pi'w$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:tO$]/SO$_/SO~O$]/TO$_/TO~O!g)hO#`/UO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/VO~O!_)kO$Z/XO$])jO$_)jO$f/YO~O!]<iO!^(fX~P#BwO!^/ZO~O!g)hO$f({X~O$f/]O~Ov/^O~P!&zOx)yO(b)zO(c/aO~O!S/dO~O(y$}On%aa!Q%aa'y%aa(z%aa!]%aa#`%aa~Og%aa$O%aa~P#L{O(z%POn%ca!Q%ca'y%ca(y%ca!]%ca#`%ca~Og%ca$O%ca~P#MnO!]fX!gfX!kfX!k$zX(rfX~P!0SOp%WO![/mO!](^O(T/lO!Y(vP!Y)PP~P!1uOr*sO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO~Os<}O!S/nO![+[O!^*pO(e<|O!^(xP~P$ [O!k/oO~P#/sO!]/pO!g#vO(r'pO!k)OX~O!k/uO~OnoX!QoX'yoX(yoX(zoX~O!g#vO!koX~P$#OOp/wO!S%hO![*^O!_%iO(T%gO!k)OP~O#k/xO~O!Y$zX!]$zX!g%RX~P!0SO!]/yO!Y)PX~P#/sO!g/{O~O!Y/}O~OpkO(T0OO~P.iOh%VOr0TO!g#vO!l%eO(r'pO~O!g+iO~Oa%nO!]0XO'z%nO~O!^0ZO~P!5iO!c0[O!d0[O(U!lO~P#$`Os!nO!S0]O(VTO(YUO(e!mO~O#[0_O~Og%aa!]%aa#`%aa$O%aa~P!1WOg%ca!]%ca#`%ca$O%ca~P!1WOj%dOk%dOl%dO(T&ZOg'mX!]'mX~O!]*yOg(^a~Og0hO~On0jO#`0iOg(_a!](_a~OR0kO!Q0kO!S0lO#S$dOn}a'y}a(y}a(z}a!]}a#`}a~Og}a$O}a~P$(cO!Q*OO'y*POn$sa(y$sa(z$sa!]$sa#`$sa~Og$sa$O$sa~P$)_O!Q*OO'y*POn$ua(y$ua(z$ua!]$ua#`$ua~Og$ua$O$ua~P$*QO#k0oO~Og%Ta!]%Ta#`%Ta$O%Ta~P!1WO!g#vO~O#k0rO~O!]+^Oa)Ta'z)Ta~OR#zO!Q#yO!S#{O!l#xO(aVOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(r!ri(y!ri(z!ri~Oa!ri'z!ri'w!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$+oOh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op0{O%]0|O(T0zO~P$.VO!g+iOa(]a!_(]a'z(]a!](]a~O#k1SO~O[]X!]fX!^fX~O!]1TO!^)XX~O!^1VO~O[1WO~Ob1YO(T+qO(VTO(YUO~O!_&PO(T%gO`'uX!]'uX~O!]+vO`)Wa~O!k1]O~P!:tO[1`O~O`1aO~O#`1fO~On1iO!_$|O~O(e(|O!^)UP~Oh%VOn1rO!_1oO%i1qO~O[1|O!]1zO!^)VX~O!^1}O~O`2POa%nO'z%nO~O(T#nO(VTO(YUO~O#S$dO#`$eO$Q$eOP(gXR(gX[(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~Oj2SO&[2TOa(gX~P$3pOj2SO#`$eO&[2TO~Oa2VO~P%[Oa2XO~O&e2[OP&ciQ&ciS&ciY&cia&cid&cie&cil&cip&cir&cis&cit&ciz&ci|&ci!O&ci!S&ci!W&ci!X&ci!_&ci!i&ci!l&ci!o&ci!p&ci!q&ci!s&ci!u&ci!x&ci!|&ci$W&ci$n&ci%h&ci%j&ci%l&ci%m&ci%n&ci%q&ci%s&ci%v&ci%w&ci%y&ci&W&ci&^&ci&`&ci&b&ci&d&ci&g&ci&m&ci&s&ci&u&ci&w&ci&y&ci&{&ci'w&ci(T&ci(V&ci(Y&ci(a&ci(o&ci!^&cib&ci&j&ci~Ob2bO!^2`O&j2aO~P`O!_XO!l2dO~O&q,{OP&liQ&liS&liY&lia&lid&lie&lil&lip&lir&lis&lit&liz&li|&li!O&li!S&li!W&li!X&li!_&li!i&li!l&li!o&li!p&li!q&li!s&li!u&li!x&li!|&li$W&li$n&li%h&li%j&li%l&li%m&li%n&li%q&li%s&li%v&li%w&li%y&li&W&li&^&li&`&li&b&li&d&li&g&li&m&li&s&li&u&li&w&li&y&li&{&li'w&li(T&li(V&li(Y&li(a&li(o&li!^&li&e&lib&li&j&li~O!Y2jO~O!]!aa!^!aa~P#BwOs!nO!S!oO![2pO(e!mO!]'XX!^'XX~P@nO!]-]O!^(ia~O!]'_X!^'_X~P!9|O!]-`O!^(xa~O!^2wO~P'_Oa%nO#`3QO'z%nO~Oa%nO!g#vO#`3QO'z%nO~Oa%nO!g#vO!p3UO#`3QO'z%nO(r'pO~Oa%nO'z%nO~P!:tO!]$_Ov$qa~O!Y'Wi!]'Wi~P!:tO!](VO!Y(hi~O!](^O!Y(vi~O!Y(wi!](wi~P!:tO!](ti!k(tia(ti'z(ti~P!:tO#`3WO!](ti!k(tia(ti'z(ti~O!](jO!k(si~O!S%hO!_%iO!|]O#i3]O#j3[O(T%gO~O!S%hO!_%iO#j3[O(T%gO~On3dO!_'`O%i3cO~Oh%VOn3dO!_'`O%i3cO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aav%aa!_%aa%i%aa!g%aa~P#L{O#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%cav%ca!_%ca%i%ca!g%ca~P#MnO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/sO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/sO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'z}a(a}a(r}a!k}a!Y}a'w}av}a!_}a%i}a!g}a~P$(cO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'z$sa(a$sa(r$sa!k$sa!Y$sa'w$sav$sa!_$sa%i$sa!g$sa~P$)_O#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'z$ua(a$ua(r$ua!k$ua!Y$ua'w$uav$ua!_$ua%i$ua!g$ua~P$*QO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'z%Ta(a%Ta(r%Ta!k%Ta!Y%Ta'w%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/sOa#cq!]#cq'z#cq'w#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:tO![3lO!]'YX!k'YX~P%[O!].tO!k(ka~O!].tO!k(ka~P!:tO!Y3oO~O$O!na!^!na~PKlO$O!ja!]!ja!^!ja~P#BwO$O!ra!^!ra~P!=[O$O!ta!^!ta~P!?rOg']X!]']X~P!,TO!]/POg(pa~OSfO!_4TO$d4UO~O!^4YO~Ov4ZO~P#/sOa$mq!]$mq'z$mq'w$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:tO!Y4]O~P!&zO!S4^O~O!Q*OO'y*PO(z%POn'ia(y'ia!]'ia#`'ia~Og'ia$O'ia~P%-fO!Q*OO'y*POn'ka(y'ka(z'ka!]'ka#`'ka~Og'ka$O'ka~P%.XO(r$YO~P#/sO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!0SOp%WO(T=WO~P!1uOp4bO!S%hO![4aO!_%iO(T%gO!]'eX!k'eX~O!]/pO!k)Oa~O!]/pO!g#vO!k)Oa~O!]/pO!g#vO(r'pO!k)Oa~Og$|i!]$|i#`$|i$O$|i~P!1WO![4jO!Y'gX!]'gX~P!3tO!]/yO!Y)Pa~O!]/yO!Y)Pa~P#/sOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~Oj%YX!g%YX~P%2OOj4oO!g#vO~Oh%VO!g#vO!l%eO~Oh%VOr4tO!l%eO(r'pO~Or4yO!g#vO(r'pO~Os!nO!S4zO(VTO(YUO(e!mO~O(y$}On%ai!Q%ai'y%ai(z%ai!]%ai#`%ai~Og%ai$O%ai~P%5oO(z%POn%ci!Q%ci'y%ci(y%ci!]%ci#`%ci~Og%ci$O%ci~P%6bOg(_i!](_i~P!1WO#`5QOg(_i!](_i~P!1WO!k5VO~Oa$oq!]$oq'z$oq'w$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:tO!Y5ZO~O!]5[O!_)QX~P#/sOa$zX!_$zX%^]X'z$zX!]$zX~P!0SO%^5_OaoX!_oX'zoX!]oX~P$#OOp5`O(T#nO~O%^5_O~Ob5fO%j5gO(T+qO(VTO(YUO!]'tX!^'tX~O!]1TO!^)Xa~O[5kO~O`5lO~O[5pO~Oa%nO'z%nO~P#/sO!]5uO#`5wO!^)UX~O!^5xO~Or6OOs!nO!S*iO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!pO#W!pO#X!pO#[5}O#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O!^5|O~P%;eOn6TO!_1oO%i6SO~Oh%VOn6TO!_1oO%i6SO~Ob6[O(T#nO(VTO(YUO!]'sX!^'sX~O!]1zO!^)Va~O(VTO(YUO(e6^O~O`6bO~Oj6eO&[6fO~PNXO!k6gO~P%[Oa6iO~Oa6iO~P%[Ob2bO!^6nO&j2aO~P`O!g6pO~O!g6rOh(ji!](ji!^(ji!g(ji!l(jir(ji(r(ji~O!]#hi!^#hi~P#BwO#`6sO!]#hi!^#hi~O!]!ai!^!ai~P#BwOa%nO#`6|O'z%nO~Oa%nO!g#vO#`6|O'z%nO~O!](tq!k(tqa(tq'z(tq~P!:tO!](jO!k(sq~O!S%hO!_%iO#j7TO(T%gO~O!_'`O%i7WO~On7[O!_'`O%i7WO~O#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'z'ia(a'ia(r'ia!k'ia!Y'ia'w'iav'ia!_'ia%i'ia!g'ia~P%-fO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'z'ka(a'ka(r'ka!k'ka!Y'ka'w'kav'ka!_'ka%i'ka!g'ka~P%.XO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'z$|i(a$|i(r$|i!k$|i!Y$|i'w$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/sO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'z%ai(a%ai(r%ai!k%ai!Y%ai'w%aiv%ai!_%ai%i%ai!g%ai~P%5oO#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'z%ci(a%ci(r%ci!k%ci!Y%ci'w%civ%ci!_%ci%i%ci!g%ci~P%6bO!]'Ya!k'Ya~P!:tO!].tO!k(ki~O$O#ci!]#ci!^#ci~P#BwOP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#n#mi~P%NdO#n<_O~P%NdOP$[OR#zOr<kO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#r#mi~P&!lO#r<aO~P&!lOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO(aVO#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#v#mi~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO(aVO(z#}O#z#mi#{#mi$O#mi(r#mi(y#mi!]#mi!^#mi~O#x<eO~P&&uO#x#mi~P&&uO#v<cO~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO(aVO(y#|O(z#}O#{#mi$O#mi(r#mi!]#mi!^#mi~O#z#mi~P&)UO#z<gO~P&)UOa#|y!]#|y'z#|y'w#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:tO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO(y#mi(z#mi~P&,QOn>^O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P&,QO#S$dOP(`XR(`X[(`Xj(`Xn(`Xr(`X!Q(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X$O(`X'y(`X(a(`X(r(`X(y(`X(z(`X!](`X!^(`X~O$O$Pi!]$Pi!^$Pi~P#BwO$O!ri!^!ri~P$+oOg']a!]']a~P!1WO!^7nO~O!]'da!^'da~P#BwO!Y7oO~P#/sO!g#vO(r'pO!]'ea!k'ea~O!]/pO!k)Oi~O!]/pO!g#vO!k)Oi~Og$|q!]$|q#`$|q$O$|q~P!1WO!Y'ga!]'ga~P#/sO!g7vO~O!]/yO!Y)Pi~P#/sO!]/yO!Y)Pi~O!Y7yO~Oh%VOr8OO!l%eO(r'pO~Oj8QO!g#vO~Or8TO!g#vO(r'pO~O!Q*OO'y*PO(z%POn'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P&5RO!Q*OO'y*POn'la(y'la(z'la!]'la#`'la~Og'la$O'la~P&5tOg(_q!](_q~P!1WO#`8VOg(_q!](_q~P!1WO!Y8WO~Og%Oq!]%Oq#`%Oq$O%Oq~P!1WOa$oy!]$oy'z$oy'w$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:tO!g6rO~O!]5[O!_)Qa~O!_'`OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(a$Ta(r$Ta(y$Ta(z$Ta~O%i7WO~P&8fO%^8[Oa%[i!_%[i'z%[i!]%[i~Oa#cy!]#cy'z#cy'w#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:tO[8^O~Ob8`O(T+qO(VTO(YUO~O!]1TO!^)Xi~O`8dO~O(e(|O!]'pX!^'pX~O!]5uO!^)Ua~O!^8nO~P%;eO(o!sO~P$&YO#[8oO~O!_1oO~O!_1oO%i8qO~On8tO!_1oO%i8qO~O[8yO!]'sa!^'sa~O!]1zO!^)Vi~O!k8}O~O!k9OO~O!k9RO~O!k9RO~P%[Oa9TO~O!g9UO~O!k9VO~O!](wi!^(wi~P#BwOa%nO#`9_O'z%nO~O!](ty!k(tya(ty'z(ty~P!:tO!](jO!k(sy~O%i9bO~P&8fO!_'`O%i9bO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'z$|q(a$|q(r$|q!k$|q!Y$|q'w$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/sO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'z'ja(a'ja(r'ja!k'ja!Y'ja'w'jav'ja!_'ja%i'ja!g'ja~P&5RO#k'laP'laR'la['laa'laj'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la'z'la(a'la(r'la!k'la!Y'la'w'lav'la!_'la%i'la!g'la~P&5tO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'z%Oq(a%Oq(r%Oq!k%Oq!Y%Oq'w%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/sO!]'Yi!k'Yi~P!:tO$O#cq!]#cq!^#cq~P#BwO(y$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(a%aa(r%aa!]%aa!^%aa~On%aa!Q%aa'y%aa(z%aa~P&IyO(z%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(a%ca(r%ca!]%ca!^%ca~On%ca!Q%ca'y%ca(y%ca~P&LQOn>^O!Q*OO'y*PO(z%PO~P&IyOn>^O!Q*OO'y*PO(y$}O~P&LQOR0kO!Q0kO!S0lO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'y}a(a}a(r}a(y}a(z}a!]}a!^}a~O!Q*OO'y*POP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(a$sa(r$sa(y$sa(z$sa!]$sa!^$sa~O!Q*OO'y*POP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(a$ua(r$ua(y$ua(z$ua!]$ua!^$ua~On>^O!Q*OO'y*PO(y$}O(z%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(a%Ta(r%Ta!]%Ta!^%Ta~P''VO$O$mq!]$mq!^$mq~P#BwO$O$oq!]$oq!^$oq~P#BwO!^9oO~O$O9pO~P!1WO!g#vO!]'ei!k'ei~O!g#vO(r'pO!]'ei!k'ei~O!]/pO!k)Oq~O!Y'gi!]'gi~P#/sO!]/yO!Y)Pq~Or9wO!g#vO(r'pO~O[9yO!Y9xO~P#/sO!Y9xO~Oj:PO!g#vO~Og(_y!](_y~P!1WO!]'na!_'na~P#/sOa%[q!_%[q'z%[q!]%[q~P#/sO[:UO~O!]1TO!^)Xq~O`:YO~O#`:ZO!]'pa!^'pa~O!]5uO!^)Ui~P#BwO!S:]O~O!_1oO%i:`O~O(VTO(YUO(e:eO~O!]1zO!^)Vq~O!k:hO~O!k:iO~O!k:jO~O!k:jO~P%[O#`:mO!]#hy!^#hy~O!]#hy!^#hy~P#BwO%i:rO~P&8fO!_'`O%i:rO~O$O#|y!]#|y!^#|y~P#BwOP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(a$|i(r$|i!]$|i!^$|i~P''VO!Q*OO'y*PO(z%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(a'ia(r'ia(y'ia!]'ia!^'ia~O!Q*OO'y*POP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(a'ka(r'ka(y'ka(z'ka!]'ka!^'ka~O(y$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'y%ai(a%ai(r%ai(z%ai!]%ai!^%ai~O(z%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'y%ci(a%ci(r%ci(y%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#BwO$O#cy!]#cy!^#cy~P#BwO!g#vO!]'eq!k'eq~O!]/pO!k)Oy~O!Y'gq!]'gq~P#/sOr:|O!g#vO(r'pO~O[;QO!Y;PO~P#/sO!Y;PO~Og(_!R!](_!R~P!1WOa%[y!_%[y'z%[y!]%[y~P#/sO!]1TO!^)Xy~O!]5uO!^)Uq~O(T;XO~O!_1oO%i;[O~O!k;_O~O%i;dO~P&8fOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(a$|q(r$|q!]$|q!^$|q~P''VO!Q*OO'y*PO(z%POP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(a'ja(r'ja(y'ja!]'ja!^'ja~O!Q*OO'y*POP'laR'la['laj'lan'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la$O'la(a'la(r'la(y'la(z'la!]'la!^'la~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(a%Oq(r%Oq!]%Oq!^%Oq~P''VOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!1WO!Y;hO~P#/sOr;iO!g#vO(r'pO~O[;kO!Y;hO~P#/sO!]'pq!^'pq~P#BwO!]#h!Z!^#h!Z~P#BwO#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'z%e!Z(a%e!Z(r%e!Z!k%e!Z!Y%e!Z'w%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/sOr;tO!g#vO(r'pO~O!Y;uO~P#/sOr;|O!g#vO(r'pO~O!Y;}O~P#/sOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(a%e!Z(r%e!Z!]%e!Z!^%e!Z~P''VOr<QO!g#vO(r'pO~Ov(fX~P1qO!Q%rO~P!)[O(U!lO~P!)[O!YfX!]fX#`fX~P%2OOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~O!gfX!k]X!kfX(rfX~P'LTOP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_XO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]<iO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<tO!S${O!_$|O!i>WO!l$xO#j<zO$W%`O$t<vO$v<xO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Ol)dO~P(!yOr!eX(r!eX~P#!iOr(jX(r(jX~P##[O!^]X!^fX~P'LTO!YfX!Y$zX!]fX!]$zX#`fX~P!0SO#k<^O~O!g#vO#k<^O~O#`<nO~Oj<bO~O#`=OO!](wX!^(wX~O#`<nO!](uX!^(uX~O#k=PO~Og=RO~P!1WO#k=XO~O#k=YO~Og=RO(T&ZO~O!g#vO#k=ZO~O!g#vO#k=PO~O$O=[O~P#BwO#k=]O~O#k=^O~O#k=cO~O#k=dO~O#k=eO~O#k=fO~O$O=gO~P!1WO$O=hO~P!1WOl=sO~P7eOk#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~(OT#o!X'|(U#ps#n#qr!Q'}$]'}(T$_(e~",
  goto: "$9Y)]PPPPPP)^PP)aP)rP+W/]PPPP6mPP7TPP=QPPP@tPA^PA^PPPA^PCfPA^PA^PA^PCjPCoPD^PIWPPPI[PPPPI[L_PPPLeMVPI[PI[PP! eI[PPPI[PI[P!#lI[P!'S!(X!(bP!)U!)Y!)U!,gPPPPPPP!-W!(XPP!-h!/YP!2iI[I[!2n!5z!:h!:h!>gPPP!>oI[PPPPPPPPP!BOP!C]PPI[!DnPI[PI[I[I[I[I[PI[!FQP!I[P!LbP!Lf!Lp!Lt!LtP!IXP!Lx!LxP#!OP#!SI[PI[#!Y#%_CjA^PA^PA^A^P#&lA^A^#)OA^#+vA^#.SA^A^#.r#1W#1W#1]#1f#1W#1qPP#1WPA^#2ZA^#6YA^A^6mPPP#:_PPP#:x#:xP#:xP#;`#:xPP#;fP#;]P#;]#;y#;]#<e#<k#<n)aP#<q)aP#<z#<z#<zP)aP)aP)aP)aPP)aP#=Q#=TP#=T)aP#=XP#=[P)aP)aP)aP)aP)aP)a)aPP#=b#=h#=s#=y#>P#>V#>]#>k#>q#>{#?R#?]#?c#?s#?y#@k#@}#AT#AZ#Ai#BO#Cs#DR#DY#Et#FS#Gt#HS#HY#H`#Hf#Hp#Hv#H|#IW#Ij#IpPPPPPPPPPPP#IvPPPPPPP#Jk#Mx$ b$ i$ qPPP$']P$'f$*_$0x$0{$1O$1}$2Q$2X$2aP$2g$2jP$3W$3[$4S$5b$5g$5}PP$6S$6Y$6^$6a$6e$6i$7e$7|$8e$8i$8l$8o$8y$8|$9Q$9UR!|RoqOXst!Z#d%m&r&t&u&w,s,x2[2_Y!vQ'`-e1o5{Q%tvQ%|yQ&T|Q&j!VS'W!e-]Q'f!iS'l!r!yU*k$|*Z*oQ+o%}S+|&V&WQ,d&dQ-c'_Q-m'gQ-u'mQ0[*qQ1b,OQ1y,eR<{<Y%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_S#q]<V!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU+P%]<s<tQ+t&PQ,f&gQ,m&oQ0x+gQ0}+iQ1Y+uQ2R,kQ3`.gQ5`0|Q5f1TQ6[1zQ7Y3dQ8`5gR9e7['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S!S!nQ!r!v!y!z$|'W'_'`'l'm'n*k*o*q*r-]-c-e-u0[0_1o5{5}%[$ti#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q&X|Q'U!eS'[%i-`Q+t&PQ,P&WQ,f&gQ0n+SQ1Y+uQ1_+{Q2Q,jQ2R,kQ5f1TQ5o1aQ6[1zQ6_1|Q6`2PQ8`5gQ8c5lQ8|6bQ:X8dQ:f8yQ;V:YR<}*ZrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R,h&k&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'b'r(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>R>S[#]WZ#W#Z'X(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ%wxQ%{yW&Q|&V&W,OQ&_!TQ'c!hQ'e!iQ(q#sS+n%|%}Q+r&PQ,_&bQ,c&dS-l'f'gQ.i(rQ1R+oQ1X+uQ1Z+vQ1^+zQ1t,`S1x,d,eQ2|-mQ5e1TQ5i1WQ5n1`Q6Z1yQ8_5gQ8b5kQ8f5pQ:T8^R;T:U!U$zi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y!^%yy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{Q+h%wQ,T&[Q,W&]Q,b&dQ.h(qQ1s,_U1w,c,d,eQ3e.iQ6U1tS6Y1x1yQ8x6Z#f>T#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o>U<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hW%Ti%V*y>PS&[!Q&iQ&]!RQ&^!SU*}%[%d=sR,R&Y%]%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^T)z$u){V+P%]<s<tW'[!e%i*Z-`S(}#y#zQ+c%rQ+y&SS.b(m(nQ1j,XQ5T0kR8i5u'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S$i$^c#Y#e%q%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.|.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ'Y!eR2q-]!W!nQ!e!r!v!y!z$|'W'_'`'l'm'n*Z*k*o*q*r-]-c-e-u0[0_1o5{5}R1l,ZnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&y!^Q'v!xS(s#u<^Q+l%zQ,]&_Q,^&aQ-j'dQ-w'oS.r(x=PS0q+X=ZQ1P+mQ1n,[Q2c,zQ2e,{Q2m-WQ2z-kQ2}-oS5Y0r=eQ5a1QS5d1S=fQ6t2oQ6x2{Q6}3SQ8]5bQ9Y6vQ9Z6yQ9^7OR:l9V$d$]c#Y#e%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vS(o#p'iQ)P#zS+b%q.|S.c(n(pR3^.d'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS#q]<VQ&t!XQ&u!YQ&w![Q&x!]R2Z,vQ'a!hQ+e%wQ-h'cS.e(q+hQ2x-gW3b.h.i0w0yQ6w2yW7U3_3a3e5^U9a7V7X7ZU:q9c9d9fS;b:p:sQ;p;cR;x;qU!wQ'`-eT5y1o5{!Q_OXZ`st!V!Z#d#h%e%m&i&k&r&t&u&w(j,s,x.[2[2_]!pQ!r'`-e1o5{T#q]<V%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S(}#y#zS.b(m(n!s=l$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU$fd)_,mS(p#p'iU*v%R(w4OU0m+O.n7gQ5^0xQ7V3`Q9d7YR:s9em!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}Q't!uS(f#g2US-s'k'wQ/s*]Q0R*jQ3U-vQ4f/tQ4r0TQ4s0UQ4x0^Q7r4`S7}4t4vS8R4y4{Q9r7sQ9v7yQ9{8OQ:Q8TS:{9w9xS;g:|;PS;s;h;iS;{;t;uS<P;|;}R<S<QQ#wbQ's!uS(e#g2US(g#m+WQ+Y%fQ+j%xQ+p&OU-r'k't'wQ.W(fU/r*]*`/wQ0S*jQ0V*lQ1O+kQ1u,aS3R-s-vQ3Z.`S4e/s/tQ4n0PS4q0R0^Q4u0WQ6W1vQ7P3US7q4`4bQ7u4fU7|4r4x4{Q8P4wQ8v6XS9q7r7sQ9u7yQ9}8RQ:O8SQ:c8wQ:y9rS:z9v9xQ;S:QQ;^:dS;f:{;PS;r;g;hS;z;s;uS<O;{;}Q<R<PQ<T<SQ=o=jQ={=tR=|=uV!wQ'`-e%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S#wz!j!r=i$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=o>R%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Q%fj!^%xy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{S&Oz!jQ+k%yQ,a&dW1v,b,c,d,eU6X1w1x1yS8w6Y6ZQ:d8x!r=j$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ=t>QR=u>R%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Y#bWZ#W#Z(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ,n&o!p=k$Z$n)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=n'XU']!e%i*ZR2s-`%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ,m&oQ0x+gQ3`.gQ7Y3dR9e7[!b$Tc#Y%q(S(Y(t(y)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!P<d)^)q-Z.|2k2n3p3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!f$Vc#Y%q(S(Y(t(y)W)X)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!T<f)^)q-Z.|2k2n3p3v3w3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!^$Zc#Y%q(S(Y(t(y)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<WQ4_/kz>S)^)q-Z.|2k2n3p4P4X6u7b7k7l8k9X9g9m9n;W;`=vQ>X>ZR>Y>['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS$oh$pR4U/U'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$kf$qQ$ifS)j$l)nR)v$qT$jf$qT)l$l)n'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$oh$pQ$rhR)u$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_!s>Q$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S#glOPXZst!Z!`!o#S#d#o#{$n%m&k&n&o&r&t&u&w&{'T'b)O)s*i+]+g,p,s,x-i.g/V/n0]0l1r2S2T2V2X2[2_2a3d4T4z6T6e6f6i7[8t9T!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^Q+T%aQ/c*Oo4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!U$yi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>YQ*c$zU*l$|*Z*oQ+U%bQ0W*m#f=q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n=r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hQ=w>TQ=x>UQ=y>VR=z>W!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hnoOXst!Z#d%m&r&t&u&w,s,x2[2_S*f${*YQ-R'OQ-S'QR4i/y%[%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q,U&]Q1h,WQ5s1gR8h5tV*n$|*Z*oU*n$|*Z*oT5z1o5{S0P*i/nQ4w0]T8S4z:]Q+j%xQ0V*lQ1O+kQ1u,aQ6W1vQ8v6XQ:c8wR;^:d!U%Oi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Yx*R$v)e*S*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>OS0`*t0a#f<o#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<p<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!d=S(u)c*[*e.j.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[`=T3}7c7f7j9h:t:w;yS=_.l3iT=`7e9k!U%Qi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y|*T$v)e*U*t+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>OS0b*u0c#f<q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!h=U(u)c*[*e.k.l.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[d=V3}7d7e7j9h9i:t:u:w;yS=a.m3jT=b7f9lrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q&f!UR,p&ornOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R&f!UQ,Y&^R1d,RsnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q1p,_S6R1s1tU8p6P6Q6US:_8r8sS;Y:^:aQ;m;ZR;w;nQ&m!VR,i&iR6_1|R:f8yW&Q|&V&W,OR1Z+vQ&r!WR,s&sR,y&xT2],x2_R,}&yQ,|&yR2f,}Q'y!{R-y'ySsOtQ#dXT%ps#dQ#OTR'{#OQ#RUR'}#RQ){$uR/`){Q#UVR(Q#UQ#XWU(W#X(X.QQ(X#YR.Q(YQ-^'YR2r-^Q.u(yS3m.u3nR3n.vQ-e'`R2v-eY!rQ'`-e1o5{R'j!rQ/Q)eR4S/QU#_W%h*YU(_#_(`.RQ(`#`R.R(ZQ-a']R2t-at`OXst!V!Z#d%m&i&k&r&t&u&w,s,x2[2_S#hZ%eU#r`#h.[R.[(jQ(k#jQ.X(gW.a(k.X3X7RQ3X.YR7R3YQ)n$lR/W)nQ$phR)t$pQ$`cU)a$`-|<jQ-|<WR<j)qQ/q*]W4c/q4d7t9sU4d/r/s/tS7t4e4fR9s7u$e*Q$v(u)c)e*[*e*t*u+Q+R+V.l.m.o.p.q/_/g/i/k/v/|0d0e0v1e3f3g3h3}4R4[4g4h4l4|5O5R5S5W5r7]7^7_7`7e7f7h7i7j7p7w7z8U8X8Z9h9i9j9t9|:R:S:t:u:v:w:x:};R;e;j;v;y=p=}>O>Z>[Q/z*eU4k/z4m7xQ4m/|R7x4lS*o$|*ZR0Y*ox*S$v)e*t*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>O!d.j(u)c*[*e.l.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/h*S.j7ca7c3}7e7f7j9h:t:w;yQ0a*tQ3i.lU4}0a3i9kR9k7e|*U$v)e*t*u+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>O!h.k(u)c*[*e.l.m.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/j*U.k7de7d3}7e7f7j9h9i:t:u:w;yQ0c*uQ3j.mU5P0c3j9lR9l7fQ*z%UR0g*zQ5]0vR8Y5]Q+_%kR0u+_Q5v1jS8j5v:[R:[8kQ,[&_R1m,[Q5{1oR8m5{Q1{,fS6]1{8zR8z6_Q1U+rW5h1U5j8a:VQ5j1XQ8a5iR:V8bQ+w&QR1[+wQ2_,xR6m2_YrOXst#dQ&v!ZQ+a%mQ,r&rQ,t&tQ,u&uQ,w&wQ2Y,sS2],x2_R6l2[Q%opQ&z!_Q&}!aQ'P!bQ'R!cQ'q!uQ+`%lQ+l%zQ,Q&XQ,h&mQ-P&|W-p'k's't'wQ-w'oQ0X*nQ1P+mQ1c,PS2O,i,lQ2g-OQ2h-RQ2i-SQ2}-oW3P-r-s-v-xQ5a1QQ5m1_Q5q1eQ6V1uQ6a2QQ6k2ZU6z3O3R3UQ6}3SQ8]5bQ8e5oQ8g5rQ8l5zQ8u6WQ8{6`S9[6{7PQ9^7OQ:W8cQ:b8vQ:g8|Q:n9]Q;U:XQ;]:cQ;a:oQ;l;VR;o;^Q%zyQ'd!iQ'o!uU+m%{%|%}Q-W'VU-k'e'f'gS-o'k'uQ0Q*jS1Q+n+oQ2o-YS2{-l-mQ3S-tS4p0R0UQ5b1RQ6v2uQ6y2|Q7O3TU7{4r4s4vQ9z7}R;O9{S$wi>PR*{%VU%Ui%V>PR0f*yQ$viS(u#v+iS)c$b$cQ)e$dQ*[$xS*e${*YQ*t%OQ*u%QQ+Q%^Q+R%_Q+V%cQ.l<oQ.m<qQ.o<uQ.p<wQ.q<yQ/_)yQ/g*RQ/i*TQ/k*VQ/v*aS/|*g/mQ0d*wQ0e*xl0v+f,V.f1i1q3c6S7W8q9b:`:r;[;dQ1e,SQ3f=SQ3g=UQ3h=XS3}<l<mQ4R/PS4[/d4^Q4g/xQ4h/yQ4l/{Q4|0`Q5O0bQ5R0iQ5S0jQ5W0oQ5r1fQ7]=]Q7^=_Q7_=aQ7`=cQ7e<pQ7f<rQ7h<vQ7i<xQ7j<zQ7p4_Q7w4jQ7z4oQ8U5QQ8X5[Q8Z5_Q9h=YQ9i=TQ9j=VQ9t7vQ9|8QQ:R8VQ:S8[Q:t=^Q:u=`Q:v=bQ:w=dQ:x9pQ:}9yQ;R:PQ;e=gQ;j;QQ;v;kQ;y=hQ=p>PQ=}>XQ>O>YQ>Z>]R>[>^Q+O%]Q.n<sR7g<tnpOXst!Z#d%m&r&t&u&w,s,x2[2_Q!fPS#fZ#oQ&|!`W'h!o*i0]4zQ(P#SQ)Q#{Q)r$nS,l&k&nQ,q&oQ-O&{S-T'T/nQ-g'bQ.x)OQ/[)sQ0s+]Q0y+gQ2W,pQ2y-iQ3a.gQ4W/VQ5U0lQ6Q1rQ6c2SQ6d2TQ6h2VQ6j2XQ6o2aQ7Z3dQ7m4TQ8s6TQ9P6eQ9Q6fQ9S6iQ9f7[Q:a8tR:k9T#[cOPXZst!Z!`!o#d#o#{%m&k&n&o&r&t&u&w&{'T'b)O*i+]+g,p,s,x-i.g/n0]0l1r2S2T2V2X2[2_2a3d4z6T6e6f6i7[8t9TQ#YWQ#eYQ%quQ%svS%uw!gS(S#W(VQ(Y#ZQ(t#uQ(y#xQ)R$OQ)S$PQ)T$QQ)U$RQ)V$SQ)W$TQ)X$UQ)Y$VQ)Z$WQ)[$XQ)^$ZQ)`$_Q)b$aQ)g$eW)q$n)s/V4TQ+d%tQ+x&RS-Z'X2pQ-x'rS-}(T.PQ.S(]Q.U(dQ.s(xQ.v(zQ.z<UQ.|<XQ.}<YQ/O<]Q/b)}Q0p+XQ2k-UQ2n-XQ3O-qQ3V.VQ3k.tQ3p<^Q3q<_Q3r<`Q3s<aQ3t<bQ3u<cQ3v<dQ3w<eQ3x<fQ3y<gQ3z<hQ3{.{Q3|<kQ4P<nQ4Q<{Q4X<iQ5X0rQ5c1SQ6u=OQ6{3QQ7Q3WQ7a3lQ7b=PQ7k=RQ7l=ZQ8k5wQ9X6sQ9]6|Q9g=[Q9m=eQ9n=fQ:o9_Q;W:ZQ;`:mQ<W#SR=v>SR#[WR'Z!el!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}S'V!e-]U*j$|*Z*oS-Y'W'_S0U*k*qQ0^*rQ2u-cQ4v0[R4{0_R({#xQ!fQT-d'`-e]!qQ!r'`-e1o5{Q#p]R'i<VR)f$dY!uQ'`-e1o5{Q'k!rS'u!v!yS'w!z5}S-t'l'mQ-v'nR3T-uT#kZ%eS#jZ%eS%km,oU(g#h#i#lS.Y(h(iQ.^(jQ0t+^Q3Y.ZU3Z.[.]._S7S3[3]R9`7Td#^W#W#Z%h(T(^*Y+Z.T/mr#gZm#h#i#l%e(h(i(j+^.Z.[.]._3[3]7TS*]$x*bQ/t*^Q2U,oQ2l-VQ4`/pQ6q2dQ7s4aQ9W6rT=m'X+[V#aW%h*YU#`W%h*YS(U#W(^U(Z#Z+Z/mS-['X+[T.O(T.TV'^!e%i*ZQ$lfR)x$qT)m$l)nR4V/UT*_$x*bT*h${*YQ0w+fQ1g,VQ3_.fQ5t1iQ6P1qQ7X3cQ8r6SQ9c7WQ:^8qQ:p9bQ;Z:`Q;c:rQ;n;[R;q;dnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&l!VR,h&itmOXst!U!V!Z#d%m&i&r&t&u&w,s,x2[2_R,o&oT%lm,oR1k,XR,g&gQ&U|S+}&V&WR1^,OR+s&PT&p!W&sT&q!W&sT2^,x2_",
  nodeNames: "âš  ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration defer ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 380,
  context: WT,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 37, 39, 51, 53, 55, ""],
    ["group", -26, 9, 17, 19, 68, 207, 211, 215, 216, 218, 221, 224, 234, 237, 243, 245, 247, 249, 252, 258, 264, 266, 268, 270, 272, 274, 275, "Statement", -34, 13, 14, 32, 35, 36, 42, 51, 54, 55, 57, 62, 70, 72, 76, 80, 82, 84, 85, 110, 111, 120, 121, 136, 139, 141, 142, 143, 144, 145, 147, 148, 167, 169, 171, "Expression", -23, 31, 33, 37, 41, 43, 45, 173, 175, 177, 178, 180, 181, 182, 184, 185, 186, 188, 189, 190, 201, 203, 205, 206, "Type", -3, 88, 103, 109, "ClassItem"],
    ["openedBy", 23, "<", 38, "InterpolationStart", 56, "[", 60, "{", 73, "(", 160, "JSXStartCloseTag"],
    ["closedBy", -2, 24, 168, ">", 40, "InterpolationEnd", 50, "]", 61, "}", 74, ")", 165, "JSXEndTag"]
  ],
  propSources: [KT],
  skippedNodes: [0, 5, 6, 278],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Wp(Z!b'|0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(X#S$i&j'}0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Wp(Z!b'}0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(V':f$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Z!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Wp(Z!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Wp(Z!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Z!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Z!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(WpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(WpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Wp(Z!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(o%1l(Wp(Z!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Wp(Z!b$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Wp(Z!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Wp(Z!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(z+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(Y';W$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(WpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Wp(Z!b(U%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Wp(Z!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Wp(Z!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Wp(Z!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Wp(Z!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Z!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Z!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Z!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Z!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Z!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Z!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Wp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Wp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Wp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Wp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(WpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(WpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Wp(Z!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Wp(Z!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Wp(Z!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Wp(Z!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Wp(Z!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Wp(Z!b(O0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Wp(Z!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Z!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Z!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(WpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(WpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Wp(Z!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Wp(Z!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(r(Ct$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Wp(Z!b(a+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Wp(Z!b(T,2j$_#t(e$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Wp(Z!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(y+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Wp(Z!b'|0/l$]#t(T,2j(e$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Wp(Z!b'}0/l$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [UT, GT, FT, HT, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, jT, new fl("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(c~~", 141, 340), new fl("j~RQYZXz{^~^O(Q~~aP!P!Qd~iO(R~~", 25, 323)],
  topRules: { Script: [0, 7], SingleExpression: [1, 276], SingleClassItem: [2, 277] },
  dialects: { jsx: 0, ts: 15175 },
  dynamicPrecedences: { 80: 1, 82: 1, 94: 1, 169: 1, 199: 1 },
  specialized: [{ term: 327, get: (i) => JT[i] || -1 }, { term: 343, get: (i) => e5[i] || -1 }, { term: 95, get: (i) => t5[i] || -1 }],
  tokenPrec: 15201
}), Db = [
  /* @__PURE__ */ Bt("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Bt("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Bt("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Bt("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Bt("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Bt(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ Bt("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Bt(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Bt(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Bt('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ Bt('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], n5 = /* @__PURE__ */ Db.concat([
  /* @__PURE__ */ Bt("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Bt("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Bt("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), RO = /* @__PURE__ */ new q0(), Lb = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function zs(i) {
  return (e, t) => {
    let n = e.node.getChild("VariableDefinition");
    return n && t(n, i), !0;
  };
}
const r5 = ["FunctionDeclaration"], s5 = {
  FunctionDeclaration: /* @__PURE__ */ zs("function"),
  ClassDeclaration: /* @__PURE__ */ zs("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ zs("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ zs("type"),
  NamespaceDeclaration: /* @__PURE__ */ zs("namespace"),
  VariableDefinition(i, e) {
    i.matchContext(r5) || e(i, "variable");
  },
  TypeDefinition(i, e) {
    e(i, "type");
  },
  __proto__: null
};
function Ib(i, e) {
  let t = RO.get(e);
  if (t)
    return t;
  let n = [], r = !0;
  function s(o, a) {
    let l = i.sliceString(o.from, o.to);
    n.push({ label: l, type: a });
  }
  return e.cursor(Ye.IncludeAnonymous).iterate((o) => {
    if (r)
      r = !1;
    else if (o.name) {
      let a = s5[o.name];
      if (a && a(o, s) || Lb.has(o.name))
        return !1;
    } else if (o.to - o.from > 8192) {
      for (let a of Ib(i, o.node))
        n.push(a);
      return !1;
    }
  }), RO.set(e, n), n;
}
const EO = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, Bb = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  "JSXText",
  "JSXAttributeValue",
  "JSXOpenTag",
  "JSXCloseTag",
  "JSXSelfClosingTag",
  ".",
  "?."
];
function o5(i) {
  let e = Ke(i.state).resolveInner(i.pos, -1);
  if (Bb.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && EO.test(i.state.sliceDoc(e.from, e.to));
  if (!t && !i.explicit)
    return null;
  let n = [];
  for (let r = e; r; r = r.parent)
    Lb.has(r.name) && (n = n.concat(Ib(i.state.doc, r)));
  return {
    options: n,
    from: t ? e.from : i.pos,
    validFor: EO
  };
}
const Fi = /* @__PURE__ */ ts.define({
  name: "javascript",
  parser: /* @__PURE__ */ i5.configure({
    props: [
      /* @__PURE__ */ Xl.add({
        IfStatement: /* @__PURE__ */ Ca({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ Ca({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: QQ,
        SwitchBody: (i) => {
          let e = i.textAfter, t = /^\s*\}/.test(e), n = /^\s*(case|default)\b/.test(e);
          return i.baseIndent + (t ? 0 : n ? 1 : 2) * i.unit;
        },
        Block: /* @__PURE__ */ kQ({ closing: "}" }),
        ArrowFunction: (i) => i.baseIndent + i.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ Ca({ except: /^\s*{/ }),
        JSXElement(i) {
          let e = /^\s*<\//.test(i.textAfter);
          return i.lineIndent(i.node.from) + (e ? 0 : i.unit);
        },
        JSXEscape(i) {
          let e = /\s*\}/.test(i.textAfter);
          return i.lineIndent(i.node.from) + (e ? 0 : i.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(i) {
          return i.column(i.node.from) + i.unit;
        }
      }),
      /* @__PURE__ */ zl.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": J0,
        BlockComment(i) {
          return { from: i.from + 2, to: i.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), Yb = {
  test: (i) => /^JSX/.test(i.name),
  facet: /* @__PURE__ */ G0({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, Nb = /* @__PURE__ */ Fi.configure({ dialect: "ts" }, "typescript"), Vb = /* @__PURE__ */ Fi.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ nu.add((i) => i.isTop ? [Yb] : void 0)]
}), qb = /* @__PURE__ */ Fi.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ nu.add((i) => i.isTop ? [Yb] : void 0)]
}, "typescript");
let Wb = (i) => ({ label: i, type: "keyword" });
const jb = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(Wb), a5 = /* @__PURE__ */ jb.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(Wb));
function l5(i = {}) {
  let e = i.jsx ? i.typescript ? qb : Vb : i.typescript ? Nb : Fi, t = i.typescript ? n5.concat(a5) : Db.concat(jb);
  return new ru(e, [
    Fi.data.of({
      autocomplete: Y_(Bb, rb(t))
    }),
    Fi.data.of({
      autocomplete: o5
    }),
    i.jsx ? f5 : []
  ]);
}
function c5(i) {
  for (; ; ) {
    if (i.name == "JSXOpenTag" || i.name == "JSXSelfClosingTag" || i.name == "JSXFragmentTag")
      return i;
    if (i.name == "JSXEscape" || !i.parent)
      return null;
    i = i.parent;
  }
}
function MO(i, e, t = i.length) {
  for (let n = e?.firstChild; n; n = n.nextSibling)
    if (n.name == "JSXIdentifier" || n.name == "JSXBuiltin" || n.name == "JSXNamespacedName" || n.name == "JSXMemberExpression")
      return i.sliceString(n.from, Math.min(n.to, t));
  return "";
}
const h5 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), f5 = /* @__PURE__ */ ae.inputHandler.of((i, e, t, n, r) => {
  if ((h5 ? i.composing : i.compositionStarted) || i.state.readOnly || e != t || n != ">" && n != "/" || !Fi.isActiveAt(i.state, e, -1))
    return !1;
  let s = r(), { state: o } = s, a = o.changeByRange((l) => {
    var c;
    let { head: h } = l, f = Ke(o).resolveInner(h - 1, -1), u;
    if (f.name == "JSXStartTag" && (f = f.parent), !(o.doc.sliceString(h - 1, h) != n || f.name == "JSXAttributeValue" && f.to > h)) {
      if (n == ">" && f.name == "JSXFragmentTag")
        return { range: l, changes: { from: h, insert: "</>" } };
      if (n == "/" && f.name == "JSXStartCloseTag") {
        let d = f.parent, p = d.parent;
        if (p && d.from == h - 2 && ((u = MO(o.doc, p.firstChild, h)) || ((c = p.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")) {
          let O = `${u}>`;
          return { range: q.cursor(h + O.length, -1), changes: { from: h, insert: O } };
        }
      } else if (n == ">") {
        let d = c5(f);
        if (d && d.name == "JSXOpenTag" && !/^\/?>|^<\//.test(o.doc.sliceString(h, h + 2)) && (u = MO(o.doc, d, h)))
          return { range: l, changes: { from: h, insert: `</${u}>` } };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (i.dispatch([
    s,
    o.update(a, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
}), Ds = ["_blank", "_self", "_top", "_parent"], Bc = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], Yc = ["get", "post", "put", "delete"], Nc = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Ht = ["true", "false"], ue = {}, u5 = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: Ds,
      hreflang: null
    }
  },
  abbr: ue,
  address: ue,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: ue,
  aside: ue,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: ue,
  base: { attrs: { href: null, target: Ds } },
  bdi: ue,
  bdo: ue,
  blockquote: { attrs: { cite: null } },
  body: ue,
  br: ue,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: Nc,
      formmethod: Yc,
      formnovalidate: ["novalidate"],
      formtarget: Ds,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: ue,
  center: ue,
  cite: ue,
  code: ue,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: ue,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: ue,
  div: ue,
  dl: ue,
  dt: ue,
  em: ue,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: ue,
  figure: ue,
  footer: ue,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Bc,
      autocomplete: ["on", "off"],
      enctype: Nc,
      method: Yc,
      novalidate: ["novalidate"],
      target: Ds
    }
  },
  h1: ue,
  h2: ue,
  h3: ue,
  h4: ue,
  h5: ue,
  h6: ue,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: ue,
  hgroup: ue,
  hr: ue,
  html: {
    attrs: { manifest: null }
  },
  i: ue,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: Nc,
      formmethod: Yc,
      formnovalidate: ["novalidate"],
      formtarget: Ds,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: ue,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: ue,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: ue,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Bc,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: ue,
  noscript: ue,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: ue,
  param: { attrs: { name: null, value: null } },
  pre: ue,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: ue,
  rt: ue,
  ruby: ue,
  samp: ue,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Bc
    }
  },
  section: ue,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: ue,
  source: { attrs: { src: null, type: null, media: null } },
  span: ue,
  strong: ue,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: ue,
  summary: ue,
  sup: ue,
  table: ue,
  tbody: ue,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: ue,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: ue,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: ue,
  time: { attrs: { datetime: null } },
  title: ue,
  tr: ue,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: ue,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: ue
}, Ub = {
  accesskey: null,
  class: null,
  contenteditable: Ht,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Ht,
  autocorrect: Ht,
  autocapitalize: Ht,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Ht,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Ht,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Ht,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Ht,
  "aria-hidden": Ht,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Ht,
  "aria-multiselectable": Ht,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Ht,
  "aria-relevant": null,
  "aria-required": Ht,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, Gb = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((i) => "on" + i);
for (let i of Gb)
  Ub[i] = null;
class pl {
  constructor(e, t) {
    this.tags = { ...u5, ...e }, this.globalAttrs = { ...Ub, ...t }, this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}
pl.default = /* @__PURE__ */ new pl();
function os(i, e, t = i.length) {
  if (!e)
    return "";
  let n = e.firstChild, r = n && n.getChild("TagName");
  return r ? i.sliceString(r.from, Math.min(r.to, t)) : "";
}
function as(i, e = !1) {
  for (; i; i = i.parent)
    if (i.name == "Element")
      if (e)
        e = !1;
      else
        return i;
  return null;
}
function Fb(i, e, t) {
  let n = t.tags[os(i, as(e))];
  return n?.children || t.allTags;
}
function Pu(i, e) {
  let t = [];
  for (let n = as(e); n && !n.type.isTop; n = as(n.parent)) {
    let r = os(i, n);
    if (r && n.lastChild.name == "CloseTag")
      break;
    r && t.indexOf(r) < 0 && (e.name == "EndTag" || e.from >= n.firstChild.to) && t.push(r);
  }
  return t;
}
const Hb = /^[:\-\.\w\u00b7-\uffff]*$/;
function ZO(i, e, t, n, r) {
  let s = /\s*>/.test(i.sliceDoc(r, r + 5)) ? "" : ">", o = as(t, t.name == "StartTag" || t.name == "TagName");
  return {
    from: n,
    to: r,
    options: Fb(i.doc, o, e).map((a) => ({ label: a, type: "type" })).concat(Pu(i.doc, t).map((a, l) => ({
      label: "/" + a,
      apply: "/" + a + s,
      type: "type",
      boost: 99 - l
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function XO(i, e, t, n) {
  let r = /\s*>/.test(i.sliceDoc(n, n + 5)) ? "" : ">";
  return {
    from: t,
    to: n,
    options: Pu(i.doc, e).map((s, o) => ({ label: s, apply: s + r, type: "type", boost: 99 - o })),
    validFor: Hb
  };
}
function d5(i, e, t, n) {
  let r = [], s = 0;
  for (let o of Fb(i.doc, t, e))
    r.push({ label: "<" + o, type: "type" });
  for (let o of Pu(i.doc, t))
    r.push({ label: "</" + o + ">", type: "type", boost: 99 - s++ });
  return { from: n, to: n, options: r, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function p5(i, e, t, n, r) {
  let s = as(t), o = s ? e.tags[os(i.doc, s)] : null, a = o && o.attrs ? Object.keys(o.attrs) : [], l = o && o.globalAttrs === !1 ? a : a.length ? a.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: n,
    to: r,
    options: l.map((c) => ({ label: c, type: "property" })),
    validFor: Hb
  };
}
function O5(i, e, t, n, r) {
  var s;
  let o = (s = t.parent) === null || s === void 0 ? void 0 : s.getChild("AttributeName"), a = [], l;
  if (o) {
    let c = i.sliceDoc(o.from, o.to), h = e.globalAttrs[c];
    if (!h) {
      let f = as(t), u = f ? e.tags[os(i.doc, f)] : null;
      h = u?.attrs && u.attrs[c];
    }
    if (h) {
      let f = i.sliceDoc(n, r).toLowerCase(), u = '"', d = '"';
      /^['"]/.test(f) ? (l = f[0] == '"' ? /^[^"]*$/ : /^[^']*$/, u = "", d = i.sliceDoc(r, r + 1) == f[0] ? "" : f[0], f = f.slice(1), n++) : l = /^[^\s<>='"]*$/;
      for (let p of h)
        a.push({ label: p, apply: u + p + d, type: "constant" });
    }
  }
  return { from: n, to: r, options: a, validFor: l };
}
function m5(i, e) {
  let { state: t, pos: n } = e, r = Ke(t).resolveInner(n, -1), s = r.resolve(n);
  for (let o = n, a; s == r && (a = r.childBefore(o)); ) {
    let l = a.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    s = r = a, o = l.from;
  }
  return r.name == "TagName" ? r.parent && /CloseTag$/.test(r.parent.name) ? XO(t, r, r.from, n) : ZO(t, i, r, r.from, n) : r.name == "StartTag" || r.name == "IncompleteTag" ? ZO(t, i, r, n, n) : r.name == "StartCloseTag" || r.name == "IncompleteCloseTag" ? XO(t, r, n, n) : r.name == "OpenTag" || r.name == "SelfClosingTag" || r.name == "AttributeName" ? p5(t, i, r, r.name == "AttributeName" ? r.from : n, n) : r.name == "Is" || r.name == "AttributeValue" || r.name == "UnquotedAttributeValue" ? O5(t, i, r, r.name == "Is" ? n : r.from, n) : e.explicit && (s.name == "Element" || s.name == "Text" || s.name == "Document") ? d5(t, i, r, n) : null;
}
function g5(i) {
  let { extraTags: e, extraGlobalAttributes: t } = i, n = t || e ? new pl(e, t) : pl.default;
  return (r) => m5(n, r);
}
const b5 = /* @__PURE__ */ Fi.parser.configure({ top: "SingleExpression" }), Kb = [
  {
    tag: "script",
    attrs: (i) => i.type == "text/typescript" || i.lang == "ts",
    parser: Nb.parser
  },
  {
    tag: "script",
    attrs: (i) => i.type == "text/babel" || i.type == "text/jsx",
    parser: Vb.parser
  },
  {
    tag: "script",
    attrs: (i) => i.type == "text/typescript-jsx",
    parser: qb.parser
  },
  {
    tag: "script",
    attrs(i) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(i.type);
    },
    parser: b5
  },
  {
    tag: "script",
    attrs(i) {
      return !i.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(i.type);
    },
    parser: Fi.parser
  },
  {
    tag: "style",
    attrs(i) {
      return (!i.lang || i.lang == "css") && (!i.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(i.type));
    },
    parser: dl.parser
  }
], Jb = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ dl.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ Gb.map((i) => ({ name: i, parser: Fi.parser }))), ey = /* @__PURE__ */ ts.define({
  name: "html",
  parser: /* @__PURE__ */ N$.configure({
    props: [
      /* @__PURE__ */ Xl.add({
        Element(i) {
          let e = /^(\s*)(<\/)?/.exec(i.textAfter);
          return i.node.to <= i.pos + e[0].length ? i.continue() : i.lineIndent(i.node.from) + (e[2] ? 0 : i.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(i) {
          return i.column(i.node.from) + i.unit;
        },
        Document(i) {
          if (i.pos + /\s*/.exec(i.textAfter)[0].length < i.node.to)
            return i.continue();
          let e = null, t;
          for (let n = i.node; ; ) {
            let r = n.lastChild;
            if (!r || r.name != "Element" || r.to != n.to)
              break;
            e = n = r;
          }
          return e && !((t = e.lastChild) && (t.name == "CloseTag" || t.name == "SelfClosingTag")) ? i.lineIndent(e.from) + i.unit : null;
        }
      }),
      /* @__PURE__ */ zl.add({
        Element(i) {
          let e = i.firstChild, t = i.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : i.to };
        }
      }),
      /* @__PURE__ */ u1.add({
        "OpenTag CloseTag": (i) => i.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-_"
  }
}), Ea = /* @__PURE__ */ ey.configure({
  wrap: /* @__PURE__ */ Ab(Kb, Jb)
});
function zO(i = {}) {
  let e = "", t;
  i.matchClosingTags === !1 && (e = "noMatch"), i.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"), (i.nestedLanguages && i.nestedLanguages.length || i.nestedAttributes && i.nestedAttributes.length) && (t = Ab((i.nestedLanguages || []).concat(Kb), (i.nestedAttributes || []).concat(Jb)));
  let n = t ? ey.configure({ wrap: t, dialect: e }) : e ? Ea.configure({ dialect: e }) : Ea;
  return new ru(n, [
    Ea.data.of({ autocomplete: g5(i) }),
    i.autoCloseTags !== !1 ? y5 : [],
    l5().support,
    QT().support
  ]);
}
const DO = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), y5 = /* @__PURE__ */ ae.inputHandler.of((i, e, t, n, r) => {
  if (i.composing || i.state.readOnly || e != t || n != ">" && n != "/" || !Ea.isActiveAt(i.state, e, -1))
    return !1;
  let s = r(), { state: o } = s, a = o.changeByRange((l) => {
    var c, h, f;
    let u = o.doc.sliceString(l.from - 1, l.to) == n, { head: d } = l, p = Ke(o).resolveInner(d, -1), O;
    if (u && n == ">" && p.name == "EndTag") {
      let m = p.parent;
      if (((h = (c = m.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || h === void 0 ? void 0 : h.name) != "CloseTag" && (O = os(o.doc, m.parent, d)) && !DO.has(O)) {
        let g = d + (o.doc.sliceString(d, d + 1) === ">" ? 1 : 0), v = `</${O}>`;
        return { range: l, changes: { from: d, to: g, insert: v } };
      }
    } else if (u && n == "/" && p.name == "IncompleteCloseTag") {
      let m = p.parent;
      if (p.from == d - 2 && ((f = m.lastChild) === null || f === void 0 ? void 0 : f.name) != "CloseTag" && (O = os(o.doc, m, d)) && !DO.has(O)) {
        let g = d + (o.doc.sliceString(d, d + 1) === ">" ? 1 : 0), v = `${O}>`;
        return {
          range: q.cursor(d + v.length, -1),
          changes: { from: d, to: g, insert: v }
        };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (i.dispatch([
    s,
    o.update(a, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
});
var v5 = /* @__PURE__ */ ri("<div></div>");
const S5 = {
  hash: "svelte-1q7873q",
  code: ".codemirror.svelte-1q7873q {display:contents;}.codemirror.hidden.svelte-1q7873q {display:none;}"
};
function LO(i, e) {
  us(e, !1), Hm(i, S5);
  const t = OS();
  let n = Cn(e, "hidden", 8, !1), r = /* @__PURE__ */ ah(), s = /* @__PURE__ */ ah(!1);
  ig(() => (Pe(s, !0), () => {
    Pe(s, !1);
  }));
  let o = Cn(e, "view", 12, null), a = Cn(e, "doc", 8), l = Cn(e, "verbose", 8, !1), c = null;
  function h(w) {
    o().dispatch({
      changes: { from: 0, to: o().state.doc.length, insert: w }
    });
  }
  const f = /* @__PURE__ */ new Set(), u = {
    ready: () => o() !== null,
    subscribe(w) {
      return f.add(w), this.ready() ? (c == null && (c = o().state.doc.toString()), w(c)) : w(null), () => void f.delete(w);
    },
    set(w) {
      if (!te(s))
        throw new Error("Cannot set docStore when the component is not mounted.");
      g(w) || h(w);
    }
  };
  let d = Cn(e, "extensions", 8, yb);
  function p() {
    o() !== null && o().dispatch({ effects: ge.reconfigure.of(d()) });
  }
  function O(w, x) {
    x.update(w), l() && t("update", w);
    let P;
    (P = w.findLast((k) => k.docChanged)) && (c = null, f.size && m(c = P.newDoc.toString()), t("change", { view: x, trs: w }));
  }
  function m(w) {
    for (const x of f)
      x(w);
  }
  function g(w) {
    return o() !== null ? !1 : (o(new ae({
      doc: w,
      extensions: d(),
      parent: te(r),
      dispatchTransactions: O
    })), !0);
  }
  dS(() => {
    o() !== null && o().destroy();
  }), ed(() => za(d()), () => {
    d(), p();
  }), ed(() => (te(s), za(a())), () => {
    te(s) && a() !== void 0 && (g(a()), m(a()));
  }), Rv();
  var v = { docStore: u };
  cS();
  var S = v5();
  return Pl(S, (w) => Pe(r, w), () => te(r)), xi(() => Jm(S, 1, `codemirror ${n() ? "hidden" : ""}`, "svelte-1q7873q")), qt(i, S), lS(e, "docStore", u), ds(v);
}
const w5 = "#e5c07b", IO = "#e06c75", x5 = "#56b6c2", k5 = "#ffffff", Ma = "#abb2bf", mf = "#7d8799", Q5 = "#61afef", _5 = "#98c379", BO = "#d19a66", P5 = "#c678dd", $5 = "#21252b", YO = "#2c313a", NO = "#282c34", Vc = "#353a42", T5 = "#3E4451", VO = "#528bff", C5 = /* @__PURE__ */ ae.theme({
  "&": {
    color: Ma,
    backgroundColor: NO
  },
  ".cm-content": {
    caretColor: VO
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: VO },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: T5 },
  ".cm-panels": { backgroundColor: $5, color: Ma },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: NO,
    color: mf,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: YO
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: Vc
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: Vc,
    borderBottomColor: Vc
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: YO,
      color: Ma
    }
  }
}, { dark: !0 }), A5 = /* @__PURE__ */ Eo.define([
  {
    tag: T.keyword,
    color: P5
  },
  {
    tag: [T.name, T.deleted, T.character, T.propertyName, T.macroName],
    color: IO
  },
  {
    tag: [/* @__PURE__ */ T.function(T.variableName), T.labelName],
    color: Q5
  },
  {
    tag: [T.color, /* @__PURE__ */ T.constant(T.name), /* @__PURE__ */ T.standard(T.name)],
    color: BO
  },
  {
    tag: [/* @__PURE__ */ T.definition(T.name), T.separator],
    color: Ma
  },
  {
    tag: [T.typeName, T.className, T.number, T.changed, T.annotation, T.modifier, T.self, T.namespace],
    color: w5
  },
  {
    tag: [T.operator, T.operatorKeyword, T.url, T.escape, T.regexp, T.link, /* @__PURE__ */ T.special(T.string)],
    color: x5
  },
  {
    tag: [T.meta, T.comment],
    color: mf
  },
  {
    tag: T.strong,
    fontWeight: "bold"
  },
  {
    tag: T.emphasis,
    fontStyle: "italic"
  },
  {
    tag: T.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: T.link,
    color: mf,
    textDecoration: "underline"
  },
  {
    tag: T.heading,
    fontWeight: "bold",
    color: IO
  },
  {
    tag: [T.atom, T.bool, /* @__PURE__ */ T.special(T.variableName)],
    color: BO
  },
  {
    tag: [T.processingInstruction, T.string, T.inserted],
    color: _5
  },
  {
    tag: T.invalid,
    color: k5
  }
]), qO = [C5, /* @__PURE__ */ au(A5)];
function R5(i) {
  const e = i - 1;
  return e * e * e + 1;
}
function WO(i) {
  const e = typeof i == "string" && i.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
  return e ? [parseFloat(e[1]), e[2] || "px"] : [
    /** @type {number} */
    i,
    "px"
  ];
}
function E5(i, { delay: e = 0, duration: t = 400, easing: n = R5, x: r = 0, y: s = 0, opacity: o = 0 } = {}) {
  const a = getComputedStyle(i), l = +a.opacity, c = a.transform === "none" ? "" : a.transform, h = l * (1 - o), [f, u] = WO(r), [d, p] = WO(s);
  return {
    delay: e,
    duration: t,
    easing: n,
    css: (O, m) => `
			transform: ${c} translate(${(1 - O) * f}${u}, ${(1 - O) * d}${p});
			opacity: ${l - h * m}`
  };
}
const { min: M5, max: Z5 } = Math, ur = (i, e = 0, t = 1) => M5(Z5(e, i), t), $u = (i) => {
  i._clipped = !1, i._unclipped = i.slice(0);
  for (let e = 0; e <= 3; e++)
    e < 3 ? ((i[e] < 0 || i[e] > 255) && (i._clipped = !0), i[e] = ur(i[e], 0, 255)) : e === 3 && (i[e] = ur(i[e], 0, 1));
  return i;
}, ty = {};
for (let i of [
  "Boolean",
  "Number",
  "String",
  "Function",
  "Array",
  "Date",
  "RegExp",
  "Undefined",
  "Null"
])
  ty[`[object ${i}]`] = i.toLowerCase();
function we(i) {
  return ty[Object.prototype.toString.call(i)] || "object";
}
const ve = (i, e = null) => i.length >= 3 ? Array.prototype.slice.call(i) : we(i[0]) == "object" && e ? e.split("").filter((t) => i[0][t] !== void 0).map((t) => i[0][t]) : i[0].slice(0), Ss = (i) => {
  if (i.length < 2) return null;
  const e = i.length - 1;
  return we(i[e]) == "string" ? i[e].toLowerCase() : null;
}, { PI: Vl, min: iy, max: ny } = Math, di = (i) => Math.round(i * 100) / 100, gf = (i) => Math.round(i * 100) / 100, pn = Vl * 2, qc = Vl / 3, X5 = Vl / 180, z5 = 180 / Vl;
function ry(i) {
  return [...i.slice(0, 3).reverse(), ...i.slice(3)];
}
const ye = {
  format: {},
  autodetect: []
};
class H {
  constructor(...e) {
    const t = this;
    if (we(e[0]) === "object" && e[0].constructor && e[0].constructor === this.constructor)
      return e[0];
    let n = Ss(e), r = !1;
    if (!n) {
      r = !0, ye.sorted || (ye.autodetect = ye.autodetect.sort((s, o) => o.p - s.p), ye.sorted = !0);
      for (let s of ye.autodetect)
        if (n = s.test(...e), n) break;
    }
    if (ye.format[n]) {
      const s = ye.format[n].apply(
        null,
        r ? e : e.slice(0, -1)
      );
      t._rgb = $u(s);
    } else
      throw new Error("unknown format: " + e);
    t._rgb.length === 3 && t._rgb.push(1);
  }
  toString() {
    return we(this.hex) == "function" ? this.hex() : `[${this._rgb.join(",")}]`;
  }
}
const D5 = "3.1.2", ke = (...i) => new H(...i);
ke.version = D5;
const ls = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
}, L5 = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, I5 = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/, sy = (i) => {
  if (i.match(L5)) {
    (i.length === 4 || i.length === 7) && (i = i.substr(1)), i.length === 3 && (i = i.split(""), i = i[0] + i[0] + i[1] + i[1] + i[2] + i[2]);
    const e = parseInt(i, 16), t = e >> 16, n = e >> 8 & 255, r = e & 255;
    return [t, n, r, 1];
  }
  if (i.match(I5)) {
    (i.length === 5 || i.length === 9) && (i = i.substr(1)), i.length === 4 && (i = i.split(""), i = i[0] + i[0] + i[1] + i[1] + i[2] + i[2] + i[3] + i[3]);
    const e = parseInt(i, 16), t = e >> 24 & 255, n = e >> 16 & 255, r = e >> 8 & 255, s = Math.round((e & 255) / 255 * 100) / 100;
    return [t, n, r, s];
  }
  throw new Error(`unknown hex color: ${i}`);
}, { round: ua } = Math, oy = (...i) => {
  let [e, t, n, r] = ve(i, "rgba"), s = Ss(i) || "auto";
  r === void 0 && (r = 1), s === "auto" && (s = r < 1 ? "rgba" : "rgb"), e = ua(e), t = ua(t), n = ua(n);
  let a = "000000" + (e << 16 | t << 8 | n).toString(16);
  a = a.substr(a.length - 6);
  let l = "0" + ua(r * 255).toString(16);
  switch (l = l.substr(l.length - 2), s.toLowerCase()) {
    case "rgba":
      return `#${a}${l}`;
    case "argb":
      return `#${l}${a}`;
    default:
      return `#${a}`;
  }
};
H.prototype.name = function() {
  const i = oy(this._rgb, "rgb");
  for (let e of Object.keys(ls))
    if (ls[e] === i) return e.toLowerCase();
  return i;
};
ye.format.named = (i) => {
  if (i = i.toLowerCase(), ls[i]) return sy(ls[i]);
  throw new Error("unknown color name: " + i);
};
ye.autodetect.push({
  p: 5,
  test: (i, ...e) => {
    if (!e.length && we(i) === "string" && ls[i.toLowerCase()])
      return "named";
  }
});
H.prototype.alpha = function(i, e = !1) {
  return i !== void 0 && we(i) === "number" ? e ? (this._rgb[3] = i, this) : new H([this._rgb[0], this._rgb[1], this._rgb[2], i], "rgb") : this._rgb[3];
};
H.prototype.clipped = function() {
  return this._rgb._clipped || !1;
};
const Hi = {
  // Corresponds roughly to RGB brighter/darker
  Kn: 18,
  // D65 standard referent
  labWhitePoint: "d65",
  Xn: 0.95047,
  Yn: 1,
  Zn: 1.08883,
  kE: 216 / 24389,
  kKE: 8,
  kK: 24389 / 27,
  RefWhiteRGB: {
    // sRGB
    X: 0.95047,
    Y: 1,
    Z: 1.08883
  },
  MtxRGB2XYZ: {
    m00: 0.4124564390896922,
    m01: 0.21267285140562253,
    m02: 0.0193338955823293,
    m10: 0.357576077643909,
    m11: 0.715152155287818,
    m12: 0.11919202588130297,
    m20: 0.18043748326639894,
    m21: 0.07217499330655958,
    m22: 0.9503040785363679
  },
  MtxXYZ2RGB: {
    m00: 3.2404541621141045,
    m01: -0.9692660305051868,
    m02: 0.055643430959114726,
    m10: -1.5371385127977166,
    m11: 1.8760108454466942,
    m12: -0.2040259135167538,
    m20: -0.498531409556016,
    m21: 0.041556017530349834,
    m22: 1.0572251882231791
  },
  // used in rgb2xyz
  As: 0.9414285350000001,
  Bs: 1.040417467,
  Cs: 1.089532651,
  MtxAdaptMa: {
    m00: 0.8951,
    m01: -0.7502,
    m02: 0.0389,
    m10: 0.2664,
    m11: 1.7135,
    m12: -0.0685,
    m20: -0.1614,
    m21: 0.0367,
    m22: 1.0296
  },
  MtxAdaptMaI: {
    m00: 0.9869929054667123,
    m01: 0.43230526972339456,
    m02: -0.008528664575177328,
    m10: -0.14705425642099013,
    m11: 0.5183602715367776,
    m12: 0.04004282165408487,
    m20: 0.15996265166373125,
    m21: 0.0492912282128556,
    m22: 0.9684866957875502
  }
}, B5 = /* @__PURE__ */ new Map([
  // ASTM E308-01
  ["a", [1.0985, 0.35585]],
  // Wyszecki & Stiles, p. 769
  ["b", [1.0985, 0.35585]],
  // C ASTM E308-01
  ["c", [0.98074, 1.18232]],
  // D50 (ASTM E308-01)
  ["d50", [0.96422, 0.82521]],
  // D55 (ASTM E308-01)
  ["d55", [0.95682, 0.92149]],
  // D65 (ASTM E308-01)
  ["d65", [0.95047, 1.08883]],
  // E (ASTM E308-01)
  ["e", [1, 1, 1]],
  // F2 (ASTM E308-01)
  ["f2", [0.99186, 0.67393]],
  // F7 (ASTM E308-01)
  ["f7", [0.95041, 1.08747]],
  // F11 (ASTM E308-01)
  ["f11", [1.00962, 0.6435]],
  ["icc", [0.96422, 0.82521]]
]);
function gn(i) {
  const e = B5.get(String(i).toLowerCase());
  if (!e)
    throw new Error("unknown Lab illuminant " + i);
  Hi.labWhitePoint = i, Hi.Xn = e[0], Hi.Zn = e[1];
}
function xo() {
  return Hi.labWhitePoint;
}
const Tu = (...i) => {
  i = ve(i, "lab");
  const [e, t, n] = i, [r, s, o] = Y5(e, t, n), [a, l, c] = ay(r, s, o);
  return [a, l, c, i.length > 3 ? i[3] : 1];
}, Y5 = (i, e, t) => {
  const { kE: n, kK: r, kKE: s, Xn: o, Yn: a, Zn: l } = Hi, c = (i + 16) / 116, h = 2e-3 * e + c, f = c - 5e-3 * t, u = h * h * h, d = f * f * f, p = u > n ? u : (116 * h - 16) / r, O = i > s ? Math.pow((i + 16) / 116, 3) : i / r, m = d > n ? d : (116 * f - 16) / r, g = p * o, v = O * a, S = m * l;
  return [g, v, S];
}, Wc = (i) => {
  const e = Math.sign(i);
  return i = Math.abs(i), (i <= 31308e-7 ? i * 12.92 : 1.055 * Math.pow(i, 1 / 2.4) - 0.055) * e;
}, ay = (i, e, t) => {
  const { MtxAdaptMa: n, MtxAdaptMaI: r, MtxXYZ2RGB: s, RefWhiteRGB: o, Xn: a, Yn: l, Zn: c } = Hi, h = a * n.m00 + l * n.m10 + c * n.m20, f = a * n.m01 + l * n.m11 + c * n.m21, u = a * n.m02 + l * n.m12 + c * n.m22, d = o.X * n.m00 + o.Y * n.m10 + o.Z * n.m20, p = o.X * n.m01 + o.Y * n.m11 + o.Z * n.m21, O = o.X * n.m02 + o.Y * n.m12 + o.Z * n.m22, m = (i * n.m00 + e * n.m10 + t * n.m20) * (d / h), g = (i * n.m01 + e * n.m11 + t * n.m21) * (p / f), v = (i * n.m02 + e * n.m12 + t * n.m22) * (O / u), S = m * r.m00 + g * r.m10 + v * r.m20, w = m * r.m01 + g * r.m11 + v * r.m21, x = m * r.m02 + g * r.m12 + v * r.m22, P = Wc(
    S * s.m00 + w * s.m10 + x * s.m20
  ), k = Wc(
    S * s.m01 + w * s.m11 + x * s.m21
  ), A = Wc(
    S * s.m02 + w * s.m12 + x * s.m22
  );
  return [P * 255, k * 255, A * 255];
}, Cu = (...i) => {
  const [e, t, n, ...r] = ve(i, "rgb"), [s, o, a] = ly(e, t, n), [l, c, h] = N5(s, o, a);
  return [l, c, h, ...r.length > 0 && r[0] < 1 ? [r[0]] : []];
};
function N5(i, e, t) {
  const { Xn: n, Yn: r, Zn: s, kE: o, kK: a } = Hi, l = i / n, c = e / r, h = t / s, f = l > o ? Math.pow(l, 1 / 3) : (a * l + 16) / 116, u = c > o ? Math.pow(c, 1 / 3) : (a * c + 16) / 116, d = h > o ? Math.pow(h, 1 / 3) : (a * h + 16) / 116;
  return [116 * u - 16, 500 * (f - u), 200 * (u - d)];
}
function jc(i) {
  const e = Math.sign(i);
  return i = Math.abs(i), (i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4)) * e;
}
const ly = (i, e, t) => {
  i = jc(i / 255), e = jc(e / 255), t = jc(t / 255);
  const { MtxRGB2XYZ: n, MtxAdaptMa: r, MtxAdaptMaI: s, Xn: o, Yn: a, Zn: l, As: c, Bs: h, Cs: f } = Hi;
  let u = i * n.m00 + e * n.m10 + t * n.m20, d = i * n.m01 + e * n.m11 + t * n.m21, p = i * n.m02 + e * n.m12 + t * n.m22;
  const O = o * r.m00 + a * r.m10 + l * r.m20, m = o * r.m01 + a * r.m11 + l * r.m21, g = o * r.m02 + a * r.m12 + l * r.m22;
  let v = u * r.m00 + d * r.m10 + p * r.m20, S = u * r.m01 + d * r.m11 + p * r.m21, w = u * r.m02 + d * r.m12 + p * r.m22;
  return v *= O / c, S *= m / h, w *= g / f, u = v * s.m00 + S * s.m10 + w * s.m20, d = v * s.m01 + S * s.m11 + w * s.m21, p = v * s.m02 + S * s.m12 + w * s.m22, [u, d, p];
};
H.prototype.lab = function() {
  return Cu(this._rgb);
};
const V5 = (...i) => new H(...i, "lab");
Object.assign(ke, { lab: V5, getLabWhitePoint: xo, setLabWhitePoint: gn });
ye.format.lab = Tu;
ye.autodetect.push({
  p: 2,
  test: (...i) => {
    if (i = ve(i, "lab"), we(i) === "array" && i.length === 3)
      return "lab";
  }
});
H.prototype.darken = function(i = 1) {
  const e = this, t = e.lab();
  return t[0] -= Hi.Kn * i, new H(t, "lab").alpha(e.alpha(), !0);
};
H.prototype.brighten = function(i = 1) {
  return this.darken(-i);
};
H.prototype.darker = H.prototype.darken;
H.prototype.brighter = H.prototype.brighten;
H.prototype.get = function(i) {
  const [e, t] = i.split("."), n = this[e]();
  if (t) {
    const r = e.indexOf(t) - (e.substr(0, 2) === "ok" ? 2 : 0);
    if (r > -1) return n[r];
    throw new Error(`unknown channel ${t} in mode ${e}`);
  } else
    return n;
};
const { pow: q5 } = Math, W5 = 1e-7, j5 = 20;
H.prototype.luminance = function(i, e = "rgb") {
  if (i !== void 0 && we(i) === "number") {
    if (i === 0)
      return new H([0, 0, 0, this._rgb[3]], "rgb");
    if (i === 1)
      return new H([255, 255, 255, this._rgb[3]], "rgb");
    let t = this.luminance(), n = j5;
    const r = (o, a) => {
      const l = o.interpolate(a, 0.5, e), c = l.luminance();
      return Math.abs(i - c) < W5 || !n-- ? l : c > i ? r(o, l) : r(l, a);
    }, s = (t > i ? r(new H([0, 0, 0]), this) : r(this, new H([255, 255, 255]))).rgb();
    return new H([...s, this._rgb[3]]);
  }
  return U5(...this._rgb.slice(0, 3));
};
const U5 = (i, e, t) => (i = Uc(i), e = Uc(e), t = Uc(t), 0.2126 * i + 0.7152 * e + 0.0722 * t), Uc = (i) => (i /= 255, i <= 0.03928 ? i / 12.92 : q5((i + 0.055) / 1.055, 2.4)), kt = {}, cs = (i, e, t = 0.5, ...n) => {
  let r = n[0] || "lrgb";
  if (!kt[r] && !n.length && (r = Object.keys(kt)[0]), !kt[r])
    throw new Error(`interpolation mode ${r} is not defined`);
  return we(i) !== "object" && (i = new H(i)), we(e) !== "object" && (e = new H(e)), kt[r](i, e, t).alpha(
    i.alpha() + t * (e.alpha() - i.alpha())
  );
};
H.prototype.mix = H.prototype.interpolate = function(i, e = 0.5, ...t) {
  return cs(this, i, e, ...t);
};
H.prototype.premultiply = function(i = !1) {
  const e = this._rgb, t = e[3];
  return i ? (this._rgb = [e[0] * t, e[1] * t, e[2] * t, t], this) : new H([e[0] * t, e[1] * t, e[2] * t, t], "rgb");
};
const { sin: G5, cos: F5 } = Math, cy = (...i) => {
  let [e, t, n] = ve(i, "lch");
  return isNaN(n) && (n = 0), n = n * X5, [e, F5(n) * t, G5(n) * t];
}, Au = (...i) => {
  i = ve(i, "lch");
  const [e, t, n] = i, [r, s, o] = cy(e, t, n), [a, l, c] = Tu(r, s, o);
  return [a, l, c, i.length > 3 ? i[3] : 1];
}, H5 = (...i) => {
  const e = ry(ve(i, "hcl"));
  return Au(...e);
}, { sqrt: K5, atan2: J5, round: eC } = Math, hy = (...i) => {
  const [e, t, n] = ve(i, "lab"), r = K5(t * t + n * n);
  let s = (J5(n, t) * z5 + 360) % 360;
  return eC(r * 1e4) === 0 && (s = Number.NaN), [e, r, s];
}, Ru = (...i) => {
  const [e, t, n, ...r] = ve(i, "rgb"), [s, o, a] = Cu(e, t, n), [l, c, h] = hy(s, o, a);
  return [l, c, h, ...r.length > 0 && r[0] < 1 ? [r[0]] : []];
};
H.prototype.lch = function() {
  return Ru(this._rgb);
};
H.prototype.hcl = function() {
  return ry(Ru(this._rgb));
};
const tC = (...i) => new H(...i, "lch"), iC = (...i) => new H(...i, "hcl");
Object.assign(ke, { lch: tC, hcl: iC });
ye.format.lch = Au;
ye.format.hcl = H5;
["lch", "hcl"].forEach(
  (i) => ye.autodetect.push({
    p: 2,
    test: (...e) => {
      if (e = ve(e, i), we(e) === "array" && e.length === 3)
        return i;
    }
  })
);
H.prototype.saturate = function(i = 1) {
  const e = this, t = e.lch();
  return t[1] += Hi.Kn * i, t[1] < 0 && (t[1] = 0), new H(t, "lch").alpha(e.alpha(), !0);
};
H.prototype.desaturate = function(i = 1) {
  return this.saturate(-i);
};
H.prototype.set = function(i, e, t = !1) {
  const [n, r] = i.split("."), s = this[n]();
  if (r) {
    const o = n.indexOf(r) - (n.substr(0, 2) === "ok" ? 2 : 0);
    if (o > -1) {
      if (we(e) == "string")
        switch (e.charAt(0)) {
          case "+":
            s[o] += +e;
            break;
          case "-":
            s[o] += +e;
            break;
          case "*":
            s[o] *= +e.substr(1);
            break;
          case "/":
            s[o] /= +e.substr(1);
            break;
          default:
            s[o] = +e;
        }
      else if (we(e) === "number")
        s[o] = e;
      else
        throw new Error("unsupported value for Color.set");
      const a = new H(s, n);
      return t ? (this._rgb = a._rgb, this) : a;
    }
    throw new Error(`unknown channel ${r} in mode ${n}`);
  } else
    return s;
};
H.prototype.tint = function(i = 0.5, ...e) {
  return cs(this, "white", i, ...e);
};
H.prototype.shade = function(i = 0.5, ...e) {
  return cs(this, "black", i, ...e);
};
const nC = (i, e, t) => {
  const n = i._rgb, r = e._rgb;
  return new H(
    n[0] + t * (r[0] - n[0]),
    n[1] + t * (r[1] - n[1]),
    n[2] + t * (r[2] - n[2]),
    "rgb"
  );
};
kt.rgb = nC;
const { sqrt: Gc, pow: Tr } = Math, rC = (i, e, t) => {
  const [n, r, s] = i._rgb, [o, a, l] = e._rgb;
  return new H(
    Gc(Tr(n, 2) * (1 - t) + Tr(o, 2) * t),
    Gc(Tr(r, 2) * (1 - t) + Tr(a, 2) * t),
    Gc(Tr(s, 2) * (1 - t) + Tr(l, 2) * t),
    "rgb"
  );
};
kt.lrgb = rC;
const sC = (i, e, t) => {
  const n = i.lab(), r = e.lab();
  return new H(
    n[0] + t * (r[0] - n[0]),
    n[1] + t * (r[1] - n[1]),
    n[2] + t * (r[2] - n[2]),
    "lab"
  );
};
kt.lab = sC;
const ws = (i, e, t, n) => {
  let r, s;
  n === "hsl" ? (r = i.hsl(), s = e.hsl()) : n === "hsv" ? (r = i.hsv(), s = e.hsv()) : n === "hcg" ? (r = i.hcg(), s = e.hcg()) : n === "hsi" ? (r = i.hsi(), s = e.hsi()) : n === "lch" || n === "hcl" ? (n = "hcl", r = i.hcl(), s = e.hcl()) : n === "oklch" && (r = i.oklch().reverse(), s = e.oklch().reverse());
  let o, a, l, c, h, f;
  (n.substr(0, 1) === "h" || n === "oklch") && ([o, l, h] = r, [a, c, f] = s);
  let u, d, p, O;
  return !isNaN(o) && !isNaN(a) ? (a > o && a - o > 180 ? O = a - (o + 360) : a < o && o - a > 180 ? O = a + 360 - o : O = a - o, d = o + t * O) : isNaN(o) ? isNaN(a) ? d = Number.NaN : (d = a, (h == 1 || h == 0) && n != "hsv" && (u = c)) : (d = o, (f == 1 || f == 0) && n != "hsv" && (u = l)), u === void 0 && (u = l + t * (c - l)), p = h + t * (f - h), n === "oklch" ? new H([p, u, d], n) : new H([d, u, p], n);
}, fy = (i, e, t) => ws(i, e, t, "lch");
kt.lch = fy;
kt.hcl = fy;
const oC = (i) => {
  if (we(i) == "number" && i >= 0 && i <= 16777215) {
    const e = i >> 16, t = i >> 8 & 255, n = i & 255;
    return [e, t, n, 1];
  }
  throw new Error("unknown num color: " + i);
}, aC = (...i) => {
  const [e, t, n] = ve(i, "rgb");
  return (e << 16) + (t << 8) + n;
};
H.prototype.num = function() {
  return aC(this._rgb);
};
const lC = (...i) => new H(...i, "num");
Object.assign(ke, { num: lC });
ye.format.num = oC;
ye.autodetect.push({
  p: 5,
  test: (...i) => {
    if (i.length === 1 && we(i[0]) === "number" && i[0] >= 0 && i[0] <= 16777215)
      return "num";
  }
});
const cC = (i, e, t) => {
  const n = i.num(), r = e.num();
  return new H(n + t * (r - n), "num");
};
kt.num = cC;
const { floor: hC } = Math, fC = (...i) => {
  i = ve(i, "hcg");
  let [e, t, n] = i, r, s, o;
  n = n * 255;
  const a = t * 255;
  if (t === 0)
    r = s = o = n;
  else {
    e === 360 && (e = 0), e > 360 && (e -= 360), e < 0 && (e += 360), e /= 60;
    const l = hC(e), c = e - l, h = n * (1 - t), f = h + a * (1 - c), u = h + a * c, d = h + a;
    switch (l) {
      case 0:
        [r, s, o] = [d, u, h];
        break;
      case 1:
        [r, s, o] = [f, d, h];
        break;
      case 2:
        [r, s, o] = [h, d, u];
        break;
      case 3:
        [r, s, o] = [h, f, d];
        break;
      case 4:
        [r, s, o] = [u, h, d];
        break;
      case 5:
        [r, s, o] = [d, h, f];
        break;
    }
  }
  return [r, s, o, i.length > 3 ? i[3] : 1];
}, uC = (...i) => {
  const [e, t, n] = ve(i, "rgb"), r = iy(e, t, n), s = ny(e, t, n), o = s - r, a = o * 100 / 255, l = r / (255 - o) * 100;
  let c;
  return o === 0 ? c = Number.NaN : (e === s && (c = (t - n) / o), t === s && (c = 2 + (n - e) / o), n === s && (c = 4 + (e - t) / o), c *= 60, c < 0 && (c += 360)), [c, a, l];
};
H.prototype.hcg = function() {
  return uC(this._rgb);
};
const dC = (...i) => new H(...i, "hcg");
ke.hcg = dC;
ye.format.hcg = fC;
ye.autodetect.push({
  p: 1,
  test: (...i) => {
    if (i = ve(i, "hcg"), we(i) === "array" && i.length === 3)
      return "hcg";
  }
});
const pC = (i, e, t) => ws(i, e, t, "hcg");
kt.hcg = pC;
const { cos: Cr } = Math, OC = (...i) => {
  i = ve(i, "hsi");
  let [e, t, n] = i, r, s, o;
  return isNaN(e) && (e = 0), isNaN(t) && (t = 0), e > 360 && (e -= 360), e < 0 && (e += 360), e /= 360, e < 1 / 3 ? (o = (1 - t) / 3, r = (1 + t * Cr(pn * e) / Cr(qc - pn * e)) / 3, s = 1 - (o + r)) : e < 2 / 3 ? (e -= 1 / 3, r = (1 - t) / 3, s = (1 + t * Cr(pn * e) / Cr(qc - pn * e)) / 3, o = 1 - (r + s)) : (e -= 2 / 3, s = (1 - t) / 3, o = (1 + t * Cr(pn * e) / Cr(qc - pn * e)) / 3, r = 1 - (s + o)), r = ur(n * r * 3), s = ur(n * s * 3), o = ur(n * o * 3), [r * 255, s * 255, o * 255, i.length > 3 ? i[3] : 1];
}, { min: mC, sqrt: gC, acos: bC } = Math, yC = (...i) => {
  let [e, t, n] = ve(i, "rgb");
  e /= 255, t /= 255, n /= 255;
  let r;
  const s = mC(e, t, n), o = (e + t + n) / 3, a = o > 0 ? 1 - s / o : 0;
  return a === 0 ? r = NaN : (r = (e - t + (e - n)) / 2, r /= gC((e - t) * (e - t) + (e - n) * (t - n)), r = bC(r), n > t && (r = pn - r), r /= pn), [r * 360, a, o];
};
H.prototype.hsi = function() {
  return yC(this._rgb);
};
const vC = (...i) => new H(...i, "hsi");
ke.hsi = vC;
ye.format.hsi = OC;
ye.autodetect.push({
  p: 2,
  test: (...i) => {
    if (i = ve(i, "hsi"), we(i) === "array" && i.length === 3)
      return "hsi";
  }
});
const SC = (i, e, t) => ws(i, e, t, "hsi");
kt.hsi = SC;
const bf = (...i) => {
  i = ve(i, "hsl");
  const [e, t, n] = i;
  let r, s, o;
  if (t === 0)
    r = s = o = n * 255;
  else {
    const a = [0, 0, 0], l = [0, 0, 0], c = n < 0.5 ? n * (1 + t) : n + t - n * t, h = 2 * n - c, f = e / 360;
    a[0] = f + 1 / 3, a[1] = f, a[2] = f - 1 / 3;
    for (let u = 0; u < 3; u++)
      a[u] < 0 && (a[u] += 1), a[u] > 1 && (a[u] -= 1), 6 * a[u] < 1 ? l[u] = h + (c - h) * 6 * a[u] : 2 * a[u] < 1 ? l[u] = c : 3 * a[u] < 2 ? l[u] = h + (c - h) * (2 / 3 - a[u]) * 6 : l[u] = h;
    [r, s, o] = [l[0] * 255, l[1] * 255, l[2] * 255];
  }
  return i.length > 3 ? [r, s, o, i[3]] : [r, s, o, 1];
}, uy = (...i) => {
  i = ve(i, "rgba");
  let [e, t, n] = i;
  e /= 255, t /= 255, n /= 255;
  const r = iy(e, t, n), s = ny(e, t, n), o = (s + r) / 2;
  let a, l;
  return s === r ? (a = 0, l = Number.NaN) : a = o < 0.5 ? (s - r) / (s + r) : (s - r) / (2 - s - r), e == s ? l = (t - n) / (s - r) : t == s ? l = 2 + (n - e) / (s - r) : n == s && (l = 4 + (e - t) / (s - r)), l *= 60, l < 0 && (l += 360), i.length > 3 && i[3] !== void 0 ? [l, a, o, i[3]] : [l, a, o];
};
H.prototype.hsl = function() {
  return uy(this._rgb);
};
const wC = (...i) => new H(...i, "hsl");
ke.hsl = wC;
ye.format.hsl = bf;
ye.autodetect.push({
  p: 2,
  test: (...i) => {
    if (i = ve(i, "hsl"), we(i) === "array" && i.length === 3)
      return "hsl";
  }
});
const xC = (i, e, t) => ws(i, e, t, "hsl");
kt.hsl = xC;
const { floor: kC } = Math, QC = (...i) => {
  i = ve(i, "hsv");
  let [e, t, n] = i, r, s, o;
  if (n *= 255, t === 0)
    r = s = o = n;
  else {
    e === 360 && (e = 0), e > 360 && (e -= 360), e < 0 && (e += 360), e /= 60;
    const a = kC(e), l = e - a, c = n * (1 - t), h = n * (1 - t * l), f = n * (1 - t * (1 - l));
    switch (a) {
      case 0:
        [r, s, o] = [n, f, c];
        break;
      case 1:
        [r, s, o] = [h, n, c];
        break;
      case 2:
        [r, s, o] = [c, n, f];
        break;
      case 3:
        [r, s, o] = [c, h, n];
        break;
      case 4:
        [r, s, o] = [f, c, n];
        break;
      case 5:
        [r, s, o] = [n, c, h];
        break;
    }
  }
  return [r, s, o, i.length > 3 ? i[3] : 1];
}, { min: _C, max: PC } = Math, $C = (...i) => {
  i = ve(i, "rgb");
  let [e, t, n] = i;
  const r = _C(e, t, n), s = PC(e, t, n), o = s - r;
  let a, l, c;
  return c = s / 255, s === 0 ? (a = Number.NaN, l = 0) : (l = o / s, e === s && (a = (t - n) / o), t === s && (a = 2 + (n - e) / o), n === s && (a = 4 + (e - t) / o), a *= 60, a < 0 && (a += 360)), [a, l, c];
};
H.prototype.hsv = function() {
  return $C(this._rgb);
};
const TC = (...i) => new H(...i, "hsv");
ke.hsv = TC;
ye.format.hsv = QC;
ye.autodetect.push({
  p: 2,
  test: (...i) => {
    if (i = ve(i, "hsv"), we(i) === "array" && i.length === 3)
      return "hsv";
  }
});
const CC = (i, e, t) => ws(i, e, t, "hsv");
kt.hsv = CC;
function Ol(i, e) {
  let t = i.length;
  Array.isArray(i[0]) || (i = [i]), Array.isArray(e[0]) || (e = e.map((o) => [o]));
  let n = e[0].length, r = e[0].map((o, a) => e.map((l) => l[a])), s = i.map(
    (o) => r.map((a) => Array.isArray(o) ? o.reduce((l, c, h) => l + c * (a[h] || 0), 0) : a.reduce((l, c) => l + c * o, 0))
  );
  return t === 1 && (s = s[0]), n === 1 ? s.map((o) => o[0]) : s;
}
const Eu = (...i) => {
  i = ve(i, "lab");
  const [e, t, n, ...r] = i, [s, o, a] = AC([e, t, n]), [l, c, h] = ay(s, o, a);
  return [l, c, h, ...r.length > 0 && r[0] < 1 ? [r[0]] : []];
};
function AC(i) {
  var e = [
    [1.2268798758459243, -0.5578149944602171, 0.2813910456659647],
    [-0.0405757452148008, 1.112286803280317, -0.0717110580655164],
    [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]
  ], t = [
    [1, 0.3963377773761749, 0.2158037573099136],
    [1, -0.1055613458156586, -0.0638541728258133],
    [1, -0.0894841775298119, -1.2914855480194092]
  ], n = Ol(t, i);
  return Ol(
    e,
    n.map((r) => r ** 3)
  );
}
const Mu = (...i) => {
  const [e, t, n, ...r] = ve(i, "rgb"), s = ly(e, t, n);
  return [...RC(s), ...r.length > 0 && r[0] < 1 ? [r[0]] : []];
};
function RC(i) {
  const e = [
    [0.819022437996703, 0.3619062600528904, -0.1288737815209879],
    [0.0329836539323885, 0.9292868615863434, 0.0361446663506424],
    [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]
  ], t = [
    [0.210454268309314, 0.7936177747023054, -0.0040720430116193],
    [1.9779985324311684, -2.42859224204858, 0.450593709617411],
    [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]
  ], n = Ol(e, i);
  return Ol(
    t,
    n.map((r) => Math.cbrt(r))
  );
}
H.prototype.oklab = function() {
  return Mu(this._rgb);
};
const EC = (...i) => new H(...i, "oklab");
Object.assign(ke, { oklab: EC });
ye.format.oklab = Eu;
ye.autodetect.push({
  p: 2,
  test: (...i) => {
    if (i = ve(i, "oklab"), we(i) === "array" && i.length === 3)
      return "oklab";
  }
});
const MC = (i, e, t) => {
  const n = i.oklab(), r = e.oklab();
  return new H(
    n[0] + t * (r[0] - n[0]),
    n[1] + t * (r[1] - n[1]),
    n[2] + t * (r[2] - n[2]),
    "oklab"
  );
};
kt.oklab = MC;
const ZC = (i, e, t) => ws(i, e, t, "oklch");
kt.oklch = ZC;
const { pow: Fc, sqrt: Hc, PI: Kc, cos: jO, sin: UO, atan2: XC } = Math, zC = (i, e = "lrgb", t = null) => {
  const n = i.length;
  t || (t = Array.from(new Array(n)).map(() => 1));
  const r = n / t.reduce(function(f, u) {
    return f + u;
  });
  if (t.forEach((f, u) => {
    t[u] *= r;
  }), i = i.map((f) => new H(f)), e === "lrgb")
    return DC(i, t);
  const s = i.shift(), o = s.get(e), a = [];
  let l = 0, c = 0;
  for (let f = 0; f < o.length; f++)
    if (o[f] = (o[f] || 0) * t[0], a.push(isNaN(o[f]) ? 0 : t[0]), e.charAt(f) === "h" && !isNaN(o[f])) {
      const u = o[f] / 180 * Kc;
      l += jO(u) * t[0], c += UO(u) * t[0];
    }
  let h = s.alpha() * t[0];
  i.forEach((f, u) => {
    const d = f.get(e);
    h += f.alpha() * t[u + 1];
    for (let p = 0; p < o.length; p++)
      if (!isNaN(d[p]))
        if (a[p] += t[u + 1], e.charAt(p) === "h") {
          const O = d[p] / 180 * Kc;
          l += jO(O) * t[u + 1], c += UO(O) * t[u + 1];
        } else
          o[p] += d[p] * t[u + 1];
  });
  for (let f = 0; f < o.length; f++)
    if (e.charAt(f) === "h") {
      let u = XC(c / a[f], l / a[f]) / Kc * 180;
      for (; u < 0; ) u += 360;
      for (; u >= 360; ) u -= 360;
      o[f] = u;
    } else
      o[f] = o[f] / a[f];
  return h /= n, new H(o, e).alpha(h > 0.99999 ? 1 : h, !0);
}, DC = (i, e) => {
  const t = i.length, n = [0, 0, 0, 0];
  for (let r = 0; r < i.length; r++) {
    const s = i[r], o = e[r] / t, a = s._rgb;
    n[0] += Fc(a[0], 2) * o, n[1] += Fc(a[1], 2) * o, n[2] += Fc(a[2], 2) * o, n[3] += a[3] * o;
  }
  return n[0] = Hc(n[0]), n[1] = Hc(n[1]), n[2] = Hc(n[2]), n[3] > 0.9999999 && (n[3] = 1), new H($u(n));
}, { pow: LC } = Math;
function ml(i) {
  let e = "rgb", t = ke("#ccc"), n = 0, r = [0, 1], s = [], o = [0, 0], a = !1, l = [], c = !1, h = 0, f = 1, u = !1, d = {}, p = !0, O = 1;
  const m = function(k) {
    if (k = k || ["#fff", "#000"], k && we(k) === "string" && ke.brewer && ke.brewer[k.toLowerCase()] && (k = ke.brewer[k.toLowerCase()]), we(k) === "array") {
      k.length === 1 && (k = [k[0], k[0]]), k = k.slice(0);
      for (let A = 0; A < k.length; A++)
        k[A] = ke(k[A]);
      s.length = 0;
      for (let A = 0; A < k.length; A++)
        s.push(A / (k.length - 1));
    }
    return x(), l = k;
  }, g = function(k) {
    if (a != null) {
      const A = a.length - 1;
      let C = 0;
      for (; C < A && k >= a[C]; )
        C++;
      return C - 1;
    }
    return 0;
  };
  let v = (k) => k, S = (k) => k;
  const w = function(k, A) {
    let C, Z;
    if (A == null && (A = !1), isNaN(k) || k === null)
      return t;
    A ? Z = k : a && a.length > 2 ? Z = g(k) / (a.length - 2) : f !== h ? Z = (k - h) / (f - h) : Z = 1, Z = S(Z), A || (Z = v(Z)), O !== 1 && (Z = LC(Z, O)), Z = o[0] + Z * (1 - o[0] - o[1]), Z = ur(Z, 0, 1);
    const I = Math.floor(Z * 1e4);
    if (p && d[I])
      C = d[I];
    else {
      if (we(l) === "array")
        for (let Q = 0; Q < s.length; Q++) {
          const E = s[Q];
          if (Z <= E) {
            C = l[Q];
            break;
          }
          if (Z >= E && Q === s.length - 1) {
            C = l[Q];
            break;
          }
          if (Z > E && Z < s[Q + 1]) {
            Z = (Z - E) / (s[Q + 1] - E), C = ke.interpolate(
              l[Q],
              l[Q + 1],
              Z,
              e
            );
            break;
          }
        }
      else we(l) === "function" && (C = l(Z));
      p && (d[I] = C);
    }
    return C;
  };
  var x = () => d = {};
  m(i);
  const P = function(k) {
    const A = ke(w(k));
    return c && A[c] ? A[c]() : A;
  };
  return P.classes = function(k) {
    if (k != null) {
      if (we(k) === "array")
        a = k, r = [k[0], k[k.length - 1]];
      else {
        const A = ke.analyze(r);
        k === 0 ? a = [A.min, A.max] : a = ke.limits(A, "e", k);
      }
      return P;
    }
    return a;
  }, P.domain = function(k) {
    if (!arguments.length)
      return r;
    h = k[0], f = k[k.length - 1], s = [];
    const A = l.length;
    if (k.length === A && h !== f)
      for (let C of Array.from(k))
        s.push((C - h) / (f - h));
    else {
      for (let C = 0; C < A; C++)
        s.push(C / (A - 1));
      if (k.length > 2) {
        const C = k.map((I, Q) => Q / (k.length - 1)), Z = k.map((I) => (I - h) / (f - h));
        Z.every((I, Q) => C[Q] === I) || (S = (I) => {
          if (I <= 0 || I >= 1) return I;
          let Q = 0;
          for (; I >= Z[Q + 1]; ) Q++;
          const E = (I - Z[Q]) / (Z[Q + 1] - Z[Q]);
          return C[Q] + E * (C[Q + 1] - C[Q]);
        });
      }
    }
    return r = [h, f], P;
  }, P.mode = function(k) {
    return arguments.length ? (e = k, x(), P) : e;
  }, P.range = function(k, A) {
    return m(k), P;
  }, P.out = function(k) {
    return c = k, P;
  }, P.spread = function(k) {
    return arguments.length ? (n = k, P) : n;
  }, P.correctLightness = function(k) {
    return k == null && (k = !0), u = k, x(), u ? v = function(A) {
      const C = w(0, !0).lab()[0], Z = w(1, !0).lab()[0], I = C > Z;
      let Q = w(A, !0).lab()[0];
      const E = C + (Z - C) * A;
      let y = Q - E, L = 0, se = 1, V = 20;
      for (; Math.abs(y) > 0.01 && V-- > 0; )
        (function() {
          return I && (y *= -1), y < 0 ? (L = A, A += (se - A) * 0.5) : (se = A, A += (L - A) * 0.5), Q = w(A, !0).lab()[0], y = Q - E;
        })();
      return A;
    } : v = (A) => A, P;
  }, P.padding = function(k) {
    return k != null ? (we(k) === "number" && (k = [k, k]), o = k, P) : o;
  }, P.colors = function(k, A) {
    arguments.length < 2 && (A = "hex");
    let C = [];
    if (arguments.length === 0)
      C = l.slice(0);
    else if (k === 1)
      C = [P(0.5)];
    else if (k > 1) {
      const Z = r[0], I = r[1] - Z;
      C = IC(0, k).map(
        (Q) => P(Z + Q / (k - 1) * I)
      );
    } else {
      i = [];
      let Z = [];
      if (a && a.length > 2)
        for (let I = 1, Q = a.length, E = 1 <= Q; E ? I < Q : I > Q; E ? I++ : I--)
          Z.push((a[I - 1] + a[I]) * 0.5);
      else
        Z = r;
      C = Z.map((I) => P(I));
    }
    return ke[A] && (C = C.map((Z) => Z[A]())), C;
  }, P.cache = function(k) {
    return k != null ? (p = k, P) : p;
  }, P.gamma = function(k) {
    return k != null ? (O = k, P) : O;
  }, P.nodata = function(k) {
    return k != null ? (t = ke(k), P) : t;
  }, P;
}
function IC(i, e, t) {
  let n = [], r = i < e, s = e;
  for (let o = i; r ? o < s : o > s; r ? o++ : o--)
    n.push(o);
  return n;
}
const BC = function(i) {
  let e = [1, 1];
  for (let t = 1; t < i; t++) {
    let n = [1];
    for (let r = 1; r <= e.length; r++)
      n[r] = (e[r] || 0) + e[r - 1];
    e = n;
  }
  return e;
}, YC = function(i) {
  let e, t, n, r;
  if (i = i.map((s) => new H(s)), i.length === 2)
    [t, n] = i.map((s) => s.lab()), e = function(s) {
      const o = [0, 1, 2].map((a) => t[a] + s * (n[a] - t[a]));
      return new H(o, "lab");
    };
  else if (i.length === 3)
    [t, n, r] = i.map((s) => s.lab()), e = function(s) {
      const o = [0, 1, 2].map(
        (a) => (1 - s) * (1 - s) * t[a] + 2 * (1 - s) * s * n[a] + s * s * r[a]
      );
      return new H(o, "lab");
    };
  else if (i.length === 4) {
    let s;
    [t, n, r, s] = i.map((o) => o.lab()), e = function(o) {
      const a = [0, 1, 2].map(
        (l) => (1 - o) * (1 - o) * (1 - o) * t[l] + 3 * (1 - o) * (1 - o) * o * n[l] + 3 * (1 - o) * o * o * r[l] + o * o * o * s[l]
      );
      return new H(a, "lab");
    };
  } else if (i.length >= 5) {
    let s, o, a;
    s = i.map((l) => l.lab()), a = i.length - 1, o = BC(a), e = function(l) {
      const c = 1 - l, h = [0, 1, 2].map(
        (f) => s.reduce(
          (u, d, p) => u + o[p] * c ** (a - p) * l ** p * d[f],
          0
        )
      );
      return new H(h, "lab");
    };
  } else
    throw new RangeError("No point in running bezier with only one color.");
  return e;
}, NC = (i) => {
  const e = YC(i);
  return e.scale = () => ml(e), e;
}, { round: dy } = Math;
H.prototype.rgb = function(i = !0) {
  return i === !1 ? this._rgb.slice(0, 3) : this._rgb.slice(0, 3).map(dy);
};
H.prototype.rgba = function(i = !0) {
  return this._rgb.slice(0, 4).map((e, t) => t < 3 ? i === !1 ? e : dy(e) : e);
};
const VC = (...i) => new H(...i, "rgb");
Object.assign(ke, { rgb: VC });
ye.format.rgb = (...i) => {
  const e = ve(i, "rgba");
  return e[3] === void 0 && (e[3] = 1), e;
};
ye.autodetect.push({
  p: 3,
  test: (...i) => {
    if (i = ve(i, "rgba"), we(i) === "array" && (i.length === 3 || i.length === 4 && we(i[3]) == "number" && i[3] >= 0 && i[3] <= 1))
      return "rgb";
  }
});
const _i = (i, e, t) => {
  if (!_i[t])
    throw new Error("unknown blend mode " + t);
  return _i[t](i, e);
}, Un = (i) => (e, t) => {
  const n = ke(t).rgb(), r = ke(e).rgb();
  return ke.rgb(i(n, r));
}, Gn = (i) => (e, t) => {
  const n = [];
  return n[0] = i(e[0], t[0]), n[1] = i(e[1], t[1]), n[2] = i(e[2], t[2]), n;
}, qC = (i) => i, WC = (i, e) => i * e / 255, jC = (i, e) => i > e ? e : i, UC = (i, e) => i > e ? i : e, GC = (i, e) => 255 * (1 - (1 - i / 255) * (1 - e / 255)), FC = (i, e) => e < 128 ? 2 * i * e / 255 : 255 * (1 - 2 * (1 - i / 255) * (1 - e / 255)), HC = (i, e) => 255 * (1 - (1 - e / 255) / (i / 255)), KC = (i, e) => i === 255 ? 255 : (i = 255 * (e / 255) / (1 - i / 255), i > 255 ? 255 : i);
_i.normal = Un(Gn(qC));
_i.multiply = Un(Gn(WC));
_i.screen = Un(Gn(GC));
_i.overlay = Un(Gn(FC));
_i.darken = Un(Gn(jC));
_i.lighten = Un(Gn(UC));
_i.dodge = Un(Gn(KC));
_i.burn = Un(Gn(HC));
const { pow: JC, sin: eA, cos: tA } = Math;
function iA(i = 300, e = -1.5, t = 1, n = 1, r = [0, 1]) {
  let s = 0, o;
  we(r) === "array" ? o = r[1] - r[0] : (o = 0, r = [r, r]);
  const a = function(l) {
    const c = pn * ((i + 120) / 360 + e * l), h = JC(r[0] + o * l, n), u = (s !== 0 ? t[0] + l * s : t) * h * (1 - h) / 2, d = tA(c), p = eA(c), O = h + u * (-0.14861 * d + 1.78277 * p), m = h + u * (-0.29227 * d - 0.90649 * p), g = h + u * (1.97294 * d);
    return ke($u([O * 255, m * 255, g * 255, 1]));
  };
  return a.start = function(l) {
    return l == null ? i : (i = l, a);
  }, a.rotations = function(l) {
    return l == null ? e : (e = l, a);
  }, a.gamma = function(l) {
    return l == null ? n : (n = l, a);
  }, a.hue = function(l) {
    return l == null ? t : (t = l, we(t) === "array" ? (s = t[1] - t[0], s === 0 && (t = t[1])) : s = 0, a);
  }, a.lightness = function(l) {
    return l == null ? r : (we(l) === "array" ? (r = l, o = l[1] - l[0]) : (r = [l, l], o = 0), a);
  }, a.scale = () => ke.scale(a), a.hue(t), a;
}
const nA = "0123456789abcdef", { floor: rA, random: sA } = Math, oA = () => {
  let i = "#";
  for (let e = 0; e < 6; e++)
    i += nA.charAt(rA(sA() * 16));
  return new H(i, "hex");
}, { log: GO, pow: aA, floor: lA, abs: cA } = Math;
function py(i, e = null) {
  const t = {
    min: Number.MAX_VALUE,
    max: Number.MAX_VALUE * -1,
    sum: 0,
    values: [],
    count: 0
  };
  return we(i) === "object" && (i = Object.values(i)), i.forEach((n) => {
    e && we(n) === "object" && (n = n[e]), n != null && !isNaN(n) && (t.values.push(n), t.sum += n, n < t.min && (t.min = n), n > t.max && (t.max = n), t.count += 1);
  }), t.domain = [t.min, t.max], t.limits = (n, r) => Oy(t, n, r), t;
}
function Oy(i, e = "equal", t = 7) {
  we(i) == "array" && (i = py(i));
  const { min: n, max: r } = i, s = i.values.sort((a, l) => a - l);
  if (t === 1)
    return [n, r];
  const o = [];
  if (e.substr(0, 1) === "c" && (o.push(n), o.push(r)), e.substr(0, 1) === "e") {
    o.push(n);
    for (let a = 1; a < t; a++)
      o.push(n + a / t * (r - n));
    o.push(r);
  } else if (e.substr(0, 1) === "l") {
    if (n <= 0)
      throw new Error(
        "Logarithmic scales are only possible for values > 0"
      );
    const a = Math.LOG10E * GO(n), l = Math.LOG10E * GO(r);
    o.push(n);
    for (let c = 1; c < t; c++)
      o.push(aA(10, a + c / t * (l - a)));
    o.push(r);
  } else if (e.substr(0, 1) === "q") {
    o.push(n);
    for (let a = 1; a < t; a++) {
      const l = (s.length - 1) * a / t, c = lA(l);
      if (c === l)
        o.push(s[c]);
      else {
        const h = l - c;
        o.push(s[c] * (1 - h) + s[c + 1] * h);
      }
    }
    o.push(r);
  } else if (e.substr(0, 1) === "k") {
    let a;
    const l = s.length, c = new Array(l), h = new Array(t);
    let f = !0, u = 0, d = null;
    d = [], d.push(n);
    for (let m = 1; m < t; m++)
      d.push(n + m / t * (r - n));
    for (d.push(r); f; ) {
      for (let g = 0; g < t; g++)
        h[g] = 0;
      for (let g = 0; g < l; g++) {
        const v = s[g];
        let S = Number.MAX_VALUE, w;
        for (let x = 0; x < t; x++) {
          const P = cA(d[x] - v);
          P < S && (S = P, w = x), h[w]++, c[g] = w;
        }
      }
      const m = new Array(t);
      for (let g = 0; g < t; g++)
        m[g] = null;
      for (let g = 0; g < l; g++)
        a = c[g], m[a] === null ? m[a] = s[g] : m[a] += s[g];
      for (let g = 0; g < t; g++)
        m[g] *= 1 / h[g];
      f = !1;
      for (let g = 0; g < t; g++)
        if (m[g] !== d[g]) {
          f = !0;
          break;
        }
      d = m, u++, u > 200 && (f = !1);
    }
    const p = {};
    for (let m = 0; m < t; m++)
      p[m] = [];
    for (let m = 0; m < l; m++)
      a = c[m], p[a].push(s[m]);
    let O = [];
    for (let m = 0; m < t; m++)
      O.push(p[m][0]), O.push(p[m][p[m].length - 1]);
    O = O.sort((m, g) => m - g), o.push(O[0]);
    for (let m = 1; m < O.length; m += 2) {
      const g = O[m];
      !isNaN(g) && o.indexOf(g) === -1 && o.push(g);
    }
  }
  return o;
}
const hA = (i, e) => {
  i = new H(i), e = new H(e);
  const t = i.luminance(), n = e.luminance();
  return t > n ? (t + 0.05) / (n + 0.05) : (n + 0.05) / (t + 0.05);
};
const FO = 0.027, fA = 5e-4, uA = 0.1, HO = 1.14, da = 0.022, KO = 1.414, dA = (i, e) => {
  i = new H(i), e = new H(e), i.alpha() < 1 && (i = cs(e, i, i.alpha(), "rgb"));
  const t = JO(...i.rgb()), n = JO(...e.rgb()), r = t >= da ? t : t + Math.pow(da - t, KO), s = n >= da ? n : n + Math.pow(da - n, KO), o = Math.pow(s, 0.56) - Math.pow(r, 0.57), a = Math.pow(s, 0.65) - Math.pow(r, 0.62), l = Math.abs(s - r) < fA ? 0 : r < s ? o * HO : a * HO;
  return (Math.abs(l) < uA ? 0 : l > 0 ? l - FO : l + FO) * 100;
};
function JO(i, e, t) {
  return 0.2126729 * Math.pow(i / 255, 2.4) + 0.7151522 * Math.pow(e / 255, 2.4) + 0.072175 * Math.pow(t / 255, 2.4);
}
const { sqrt: hn, pow: it, min: pA, max: OA, atan2: em, abs: tm, cos: pa, sin: im, exp: mA, PI: nm } = Math;
function gA(i, e, t = 1, n = 1, r = 1) {
  var s = function(J) {
    return 360 * J / (2 * nm);
  }, o = function(J) {
    return 2 * nm * J / 360;
  };
  i = new H(i), e = new H(e);
  const [a, l, c] = Array.from(i.lab()), [h, f, u] = Array.from(e.lab()), d = (a + h) / 2, p = hn(it(l, 2) + it(c, 2)), O = hn(it(f, 2) + it(u, 2)), m = (p + O) / 2, g = 0.5 * (1 - hn(it(m, 7) / (it(m, 7) + it(25, 7)))), v = l * (1 + g), S = f * (1 + g), w = hn(it(v, 2) + it(c, 2)), x = hn(it(S, 2) + it(u, 2)), P = (w + x) / 2, k = s(em(c, v)), A = s(em(u, S)), C = k >= 0 ? k : k + 360, Z = A >= 0 ? A : A + 360, I = tm(C - Z) > 180 ? (C + Z + 360) / 2 : (C + Z) / 2, Q = 1 - 0.17 * pa(o(I - 30)) + 0.24 * pa(o(2 * I)) + 0.32 * pa(o(3 * I + 6)) - 0.2 * pa(o(4 * I - 63));
  let E = Z - C;
  E = tm(E) <= 180 ? E : Z <= C ? E + 360 : E - 360, E = 2 * hn(w * x) * im(o(E) / 2);
  const y = h - a, L = x - w, se = 1 + 0.015 * it(d - 50, 2) / hn(20 + it(d - 50, 2)), V = 1 + 0.045 * P, fe = 1 + 0.015 * P * Q, W = 30 * mA(-it((I - 275) / 25, 2)), z = -(2 * hn(it(P, 7) / (it(P, 7) + it(25, 7)))) * im(2 * o(W)), D = hn(
    it(y / (t * se), 2) + it(L / (n * V), 2) + it(E / (r * fe), 2) + z * (L / (n * V)) * (E / (r * fe))
  );
  return OA(0, pA(100, D));
}
function bA(i, e, t = "lab") {
  i = new H(i), e = new H(e);
  const n = i.get(t), r = e.get(t);
  let s = 0;
  for (let o in n) {
    const a = (n[o] || 0) - (r[o] || 0);
    s += a * a;
  }
  return Math.sqrt(s);
}
const yA = (...i) => {
  try {
    return new H(...i), !0;
  } catch {
    return !1;
  }
}, vA = {
  cool() {
    return ml([ke.hsl(180, 1, 0.9), ke.hsl(250, 0.7, 0.4)]);
  },
  hot() {
    return ml(["#000", "#f00", "#ff0", "#fff"]).mode(
      "rgb"
    );
  }
}, yf = {
  // sequential
  OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
  PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
  BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
  Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
  BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
  YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
  YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
  Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
  RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
  Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
  YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
  Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
  GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
  Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
  YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
  PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
  Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
  PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
  Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
  // diverging
  Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
  RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
  RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
  PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
  PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
  RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
  BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
  RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
  PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
  // qualitative
  Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
  Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
  Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
  Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
  Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
  Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
  Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
  Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
}, my = Object.keys(yf), rm = new Map(my.map((i) => [i.toLowerCase(), i])), SA = typeof Proxy == "function" ? new Proxy(yf, {
  get(i, e) {
    const t = e.toLowerCase();
    if (rm.has(t))
      return i[rm.get(t)];
  },
  getOwnPropertyNames() {
    return Object.getOwnPropertyNames(my);
  }
}) : yf, wA = (...i) => {
  i = ve(i, "cmyk");
  const [e, t, n, r] = i, s = i.length > 4 ? i[4] : 1;
  return r === 1 ? [0, 0, 0, s] : [
    e >= 1 ? 0 : 255 * (1 - e) * (1 - r),
    // r
    t >= 1 ? 0 : 255 * (1 - t) * (1 - r),
    // g
    n >= 1 ? 0 : 255 * (1 - n) * (1 - r),
    // b
    s
  ];
}, { max: sm } = Math, xA = (...i) => {
  let [e, t, n] = ve(i, "rgb");
  e = e / 255, t = t / 255, n = n / 255;
  const r = 1 - sm(e, sm(t, n)), s = r < 1 ? 1 / (1 - r) : 0, o = (1 - e - r) * s, a = (1 - t - r) * s, l = (1 - n - r) * s;
  return [o, a, l, r];
};
H.prototype.cmyk = function() {
  return xA(this._rgb);
};
const kA = (...i) => new H(...i, "cmyk");
Object.assign(ke, { cmyk: kA });
ye.format.cmyk = wA;
ye.autodetect.push({
  p: 2,
  test: (...i) => {
    if (i = ve(i, "cmyk"), we(i) === "array" && i.length === 4)
      return "cmyk";
  }
});
const QA = (...i) => {
  const e = ve(i, "hsla");
  let t = Ss(i) || "lsa";
  return e[0] = di(e[0] || 0) + "deg", e[1] = di(e[1] * 100) + "%", e[2] = di(e[2] * 100) + "%", t === "hsla" || e.length > 3 && e[3] < 1 ? (e[3] = "/ " + (e.length > 3 ? e[3] : 1), t = "hsla") : e.length = 3, `${t.substr(0, 3)}(${e.join(" ")})`;
}, _A = (...i) => {
  const e = ve(i, "lab");
  let t = Ss(i) || "lab";
  return e[0] = di(e[0]) + "%", e[1] = di(e[1]), e[2] = di(e[2]), t === "laba" || e.length > 3 && e[3] < 1 ? e[3] = "/ " + (e.length > 3 ? e[3] : 1) : e.length = 3, `lab(${e.join(" ")})`;
}, PA = (...i) => {
  const e = ve(i, "lch");
  let t = Ss(i) || "lab";
  return e[0] = di(e[0]) + "%", e[1] = di(e[1]), e[2] = isNaN(e[2]) ? "none" : di(e[2]) + "deg", t === "lcha" || e.length > 3 && e[3] < 1 ? e[3] = "/ " + (e.length > 3 ? e[3] : 1) : e.length = 3, `lch(${e.join(" ")})`;
}, $A = (...i) => {
  const e = ve(i, "lab");
  return e[0] = di(e[0] * 100) + "%", e[1] = gf(e[1]), e[2] = gf(e[2]), e.length > 3 && e[3] < 1 ? e[3] = "/ " + (e.length > 3 ? e[3] : 1) : e.length = 3, `oklab(${e.join(" ")})`;
}, gy = (...i) => {
  const [e, t, n, ...r] = ve(i, "rgb"), [s, o, a] = Mu(e, t, n), [l, c, h] = hy(s, o, a);
  return [l, c, h, ...r.length > 0 && r[0] < 1 ? [r[0]] : []];
}, TA = (...i) => {
  const e = ve(i, "lch");
  return e[0] = di(e[0] * 100) + "%", e[1] = gf(e[1]), e[2] = isNaN(e[2]) ? "none" : di(e[2]) + "deg", e.length > 3 && e[3] < 1 ? e[3] = "/ " + (e.length > 3 ? e[3] : 1) : e.length = 3, `oklch(${e.join(" ")})`;
}, { round: Jc } = Math, CA = (...i) => {
  const e = ve(i, "rgba");
  let t = Ss(i) || "rgb";
  if (t.substr(0, 3) === "hsl")
    return QA(uy(e), t);
  if (t.substr(0, 3) === "lab") {
    const n = xo();
    gn("d50");
    const r = _A(Cu(e), t);
    return gn(n), r;
  }
  if (t.substr(0, 3) === "lch") {
    const n = xo();
    gn("d50");
    const r = PA(Ru(e), t);
    return gn(n), r;
  }
  return t.substr(0, 5) === "oklab" ? $A(Mu(e)) : t.substr(0, 5) === "oklch" ? TA(gy(e)) : (e[0] = Jc(e[0]), e[1] = Jc(e[1]), e[2] = Jc(e[2]), (t === "rgba" || e.length > 3 && e[3] < 1) && (e[3] = "/ " + (e.length > 3 ? e[3] : 1), t = "rgba"), `${t.substr(0, 3)}(${e.slice(0, t === "rgb" ? 3 : 4).join(" ")})`);
}, by = (...i) => {
  i = ve(i, "lch");
  const [e, t, n, ...r] = i, [s, o, a] = cy(e, t, n), [l, c, h] = Eu(s, o, a);
  return [l, c, h, ...r.length > 0 && r[0] < 1 ? [r[0]] : []];
}, Sn = /((?:-?\d+)|(?:-?\d+(?:\.\d+)?)%|none)/.source, Si = /((?:-?(?:\d+(?:\.\d*)?|\.\d+)%?)|none)/.source, gl = /((?:-?(?:\d+(?:\.\d*)?|\.\d+)%)|none)/.source, mi = /\s*/.source, xs = /\s+/.source, Zu = /\s*,\s*/.source, ql = /((?:-?(?:\d+(?:\.\d*)?|\.\d+)(?:deg)?)|none)/.source, ks = /\s*(?:\/\s*((?:[01]|[01]?\.\d+)|\d+(?:\.\d+)?%))?/.source, yy = new RegExp(
  "^rgba?\\(" + mi + [Sn, Sn, Sn].join(xs) + ks + "\\)$"
), vy = new RegExp(
  "^rgb\\(" + mi + [Sn, Sn, Sn].join(Zu) + mi + "\\)$"
), Sy = new RegExp(
  "^rgba\\(" + mi + [Sn, Sn, Sn, Si].join(Zu) + mi + "\\)$"
), wy = new RegExp(
  "^hsla?\\(" + mi + [ql, gl, gl].join(xs) + ks + "\\)$"
), xy = new RegExp(
  "^hsl?\\(" + mi + [ql, gl, gl].join(Zu) + mi + "\\)$"
), ky = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/, Qy = new RegExp(
  "^lab\\(" + mi + [Si, Si, Si].join(xs) + ks + "\\)$"
), _y = new RegExp(
  "^lch\\(" + mi + [Si, Si, ql].join(xs) + ks + "\\)$"
), Py = new RegExp(
  "^oklab\\(" + mi + [Si, Si, Si].join(xs) + ks + "\\)$"
), $y = new RegExp(
  "^oklch\\(" + mi + [Si, Si, ql].join(xs) + ks + "\\)$"
), { round: Ty } = Math, Ar = (i) => i.map((e, t) => t <= 2 ? ur(Ty(e), 0, 255) : e), nt = (i, e = 0, t = 100, n = !1) => (typeof i == "string" && i.endsWith("%") && (i = parseFloat(i.substring(0, i.length - 1)) / 100, n ? i = e + (i + 1) * 0.5 * (t - e) : i = e + i * (t - e)), +i), Ct = (i, e) => i === "none" ? e : i, Xu = (i) => {
  if (i = i.toLowerCase().trim(), i === "transparent")
    return [0, 0, 0, 0];
  let e;
  if (ye.format.named)
    try {
      return ye.format.named(i);
    } catch {
    }
  if ((e = i.match(yy)) || (e = i.match(vy))) {
    let t = e.slice(1, 4);
    for (let r = 0; r < 3; r++)
      t[r] = +nt(Ct(t[r], 0), 0, 255);
    t = Ar(t);
    const n = e[4] !== void 0 ? +nt(e[4], 0, 1) : 1;
    return t[3] = n, t;
  }
  if (e = i.match(Sy)) {
    const t = e.slice(1, 5);
    for (let n = 0; n < 4; n++)
      t[n] = +nt(t[n], 0, 255);
    return t;
  }
  if ((e = i.match(wy)) || (e = i.match(xy))) {
    const t = e.slice(1, 4);
    t[0] = +Ct(t[0].replace("deg", ""), 0), t[1] = +nt(Ct(t[1], 0), 0, 100) * 0.01, t[2] = +nt(Ct(t[2], 0), 0, 100) * 0.01;
    const n = Ar(bf(t)), r = e[4] !== void 0 ? +nt(e[4], 0, 1) : 1;
    return n[3] = r, n;
  }
  if (e = i.match(ky)) {
    const t = e.slice(1, 4);
    t[1] *= 0.01, t[2] *= 0.01;
    const n = bf(t);
    for (let r = 0; r < 3; r++)
      n[r] = Ty(n[r]);
    return n[3] = +e[4], n;
  }
  if (e = i.match(Qy)) {
    const t = e.slice(1, 4);
    t[0] = nt(Ct(t[0], 0), 0, 100), t[1] = nt(Ct(t[1], 0), -125, 125, !0), t[2] = nt(Ct(t[2], 0), -125, 125, !0);
    const n = xo();
    gn("d50");
    const r = Ar(Tu(t));
    gn(n);
    const s = e[4] !== void 0 ? +nt(e[4], 0, 1) : 1;
    return r[3] = s, r;
  }
  if (e = i.match(_y)) {
    const t = e.slice(1, 4);
    t[0] = nt(t[0], 0, 100), t[1] = nt(Ct(t[1], 0), 0, 150, !1), t[2] = +Ct(t[2].replace("deg", ""), 0);
    const n = xo();
    gn("d50");
    const r = Ar(Au(t));
    gn(n);
    const s = e[4] !== void 0 ? +nt(e[4], 0, 1) : 1;
    return r[3] = s, r;
  }
  if (e = i.match(Py)) {
    const t = e.slice(1, 4);
    t[0] = nt(Ct(t[0], 0), 0, 1), t[1] = nt(Ct(t[1], 0), -0.4, 0.4, !0), t[2] = nt(Ct(t[2], 0), -0.4, 0.4, !0);
    const n = Ar(Eu(t)), r = e[4] !== void 0 ? +nt(e[4], 0, 1) : 1;
    return n[3] = r, n;
  }
  if (e = i.match($y)) {
    const t = e.slice(1, 4);
    t[0] = nt(Ct(t[0], 0), 0, 1), t[1] = nt(Ct(t[1], 0), 0, 0.4, !1), t[2] = +Ct(t[2].replace("deg", ""), 0);
    const n = Ar(by(t)), r = e[4] !== void 0 ? +nt(e[4], 0, 1) : 1;
    return n[3] = r, n;
  }
};
Xu.test = (i) => (
  // modern
  yy.test(i) || wy.test(i) || Qy.test(i) || _y.test(i) || Py.test(i) || $y.test(i) || // legacy
  vy.test(i) || Sy.test(i) || xy.test(i) || ky.test(i) || i === "transparent"
);
H.prototype.css = function(i) {
  return CA(this._rgb, i);
};
const AA = (...i) => new H(...i, "css");
ke.css = AA;
ye.format.css = Xu;
ye.autodetect.push({
  p: 5,
  test: (i, ...e) => {
    if (!e.length && we(i) === "string" && Xu.test(i))
      return "css";
  }
});
ye.format.gl = (...i) => {
  const e = ve(i, "rgba");
  return e[0] *= 255, e[1] *= 255, e[2] *= 255, e;
};
const RA = (...i) => new H(...i, "gl");
ke.gl = RA;
H.prototype.gl = function() {
  const i = this._rgb;
  return [i[0] / 255, i[1] / 255, i[2] / 255, i[3]];
};
H.prototype.hex = function(i) {
  return oy(this._rgb, i);
};
const EA = (...i) => new H(...i, "hex");
ke.hex = EA;
ye.format.hex = sy;
ye.autodetect.push({
  p: 4,
  test: (i, ...e) => {
    if (!e.length && we(i) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(i.length) >= 0)
      return "hex";
  }
});
const { log: Oa } = Math, Cy = (i) => {
  const e = i / 100;
  let t, n, r;
  return e < 66 ? (t = 255, n = e < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (n = e - 2) + 104.49216199393888 * Oa(n), r = e < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (r = e - 10) + 115.67994401066147 * Oa(r)) : (t = 351.97690566805693 + 0.114206453784165 * (t = e - 55) - 40.25366309332127 * Oa(t), n = 325.4494125711974 + 0.07943456536662342 * (n = e - 50) - 28.0852963507957 * Oa(n), r = 255), [t, n, r, 1];
}, { round: MA } = Math, ZA = (...i) => {
  const e = ve(i, "rgb"), t = e[0], n = e[2];
  let r = 1e3, s = 4e4;
  const o = 0.4;
  let a;
  for (; s - r > o; ) {
    a = (s + r) * 0.5;
    const l = Cy(a);
    l[2] / l[0] >= n / t ? s = a : r = a;
  }
  return MA(a);
};
H.prototype.temp = H.prototype.kelvin = H.prototype.temperature = function() {
  return ZA(this._rgb);
};
const eh = (...i) => new H(...i, "temp");
Object.assign(ke, { temp: eh, kelvin: eh, temperature: eh });
ye.format.temp = ye.format.kelvin = ye.format.temperature = Cy;
H.prototype.oklch = function() {
  return gy(this._rgb);
};
const XA = (...i) => new H(...i, "oklch");
Object.assign(ke, { oklch: XA });
ye.format.oklch = by;
ye.autodetect.push({
  p: 2,
  test: (...i) => {
    if (i = ve(i, "oklch"), we(i) === "array" && i.length === 3)
      return "oklch";
  }
});
Object.assign(ke, {
  analyze: py,
  average: zC,
  bezier: NC,
  blend: _i,
  brewer: SA,
  Color: H,
  colors: ls,
  contrast: hA,
  contrastAPCA: dA,
  cubehelix: iA,
  deltaE: gA,
  distance: bA,
  input: ye,
  interpolate: cs,
  limits: Oy,
  mix: cs,
  random: oA,
  scale: ml,
  scales: vA,
  valid: yA
});
var zA = /* @__PURE__ */ ri("<button><!> </button>"), DA = /* @__PURE__ */ ri('<div class="tag-customise-window"></div>');
function LA(i, e) {
  us(e, !0);
  const t = [
    ["Red", "red"],
    ["Orange", "orange"],
    ["Yellow", "yellow"],
    ["Green", "green"],
    ["Light Blue", "light-blue"],
    ["Blue", "blue"],
    ["Purple", "purple"],
    ["Pink", "pink"]
  ];
  let n = Cn(e, "tag", 15);
  function r(a, l) {
    const c = (h) => {
      a.contains(h.target) || l();
    };
    return document.addEventListener("click", c, !0), {
      destroy() {
        document.removeEventListener("click", c, !0);
      }
    };
  }
  function s(a) {
    let c = getComputedStyle(document.documentElement).getPropertyValue(`--tag-${a}`);
    const f = ke(c).hsl();
    return ke.hsl(f[0], 0.55, 0.1).hex();
  }
  var o = DA();
  Zf(o, 21, () => t, Mf, (a, l) => {
    var c = zA();
    c.__click = () => n(n().color = te(l)[1], !0);
    let h;
    var f = Ee(c);
    Fv(f, () => e.colorPreview, () => te(l)[1]);
    var u = Ze(f);
    xi(
      (d) => {
        h = Ia(c, "", h, d), mn(u, ` ${te(l)[0] ?? ""}`);
      },
      [
        () => ({ "--tag-customise-hover": s(te(l)[1]) })
      ]
    ), qt(a, c);
  }), Km(o, (a, l) => r?.(a, l), () => () => {
    e.onloosefocus && e.onloosefocus();
  }), oS(3, o, () => E5, () => ({ duration: 200, y: 10 })), qt(i, o), ds();
}
Rf(["click"]);
const om = (i, e = zi) => {
  var t = IA(), n = Ee(t);
  xi(() => ya(n, "fill", `var(--tag-${e() ?? ""})`)), qt(i, t);
};
var IA = /* @__PURE__ */ Nv('<svg viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="7.5" cy="7.5" r="7" stroke="var(--tag-color-outline)"></circle></svg>'), BA = /* @__PURE__ */ ri('<input placeholder="Type here..."/>'), YA = /* @__PURE__ */ ri('<div class="article-tag"><button title="Change Color"><!></button> <input name="Tag Name" placeholder="Tag Name..."/>  <button title="Delete" class="delete-button"><svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><line x1="3.88909" y1="11.6673" x2="11.6673" y2="3.88909" stroke="var(--tag-delete-button)"></line><line x1="11.6673" y1="11.6673" x2="3.88909" y2="3.88908" stroke="var(--tag-delete-button)"></line></svg></button> <!></div>'), NA = /* @__PURE__ */ ri('<div class="tags"><!> <button class="add-tag-button"><svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill="var(--add-icon-color)" d="M8 0C12.4183 0 16 3.58172 16 8C16 12.4183 12.4183 16 8 16C3.58172 16 0 12.4183 0 8C0 3.58172 3.58172 0 8 0ZM8 3C7.44772 3 7 3.44772 7 4V7H4C3.44772 7 3 7.44772 3 8C3 8.55228 3.44772 9 4 9H7V12C7 12.5523 7.44772 13 8 13C8.55228 13 9 12.5523 9 12V9H12C12.5523 9 13 8.55228 13 8C13 7.44772 12.5523 7 12 7H9V4C9 3.44772 8.55228 3 8 3Z"></path></svg> Add Tag</button></div>'), VA = /* @__PURE__ */ ri('<div class="section"><label> </label> <!></div>');
function th(i, e) {
  us(e, !0);
  let t = Cn(e, "value", 15, ""), n = Cn(e, "type", 3, "normal"), r = li([]), s = li([]);
  function o(p) {
    const O = document.createElement("span");
    O.style.visibility = "hidden", O.style.position = "absolute", O.style.whiteSpace = "pre";
    const m = window.getComputedStyle(p);
    O.style.font = m.font, O.style.fontSize = m.fontSize, O.style.fontFamily = m.fontFamily, O.style.fontWeight = m.fontWeight, O.style.letterSpacing = m.letterSpacing, document.body.appendChild(O);
    const g = () => {
      O.textContent = p.value || p.placeholder || "", p.style.width = `${O.offsetWidth + 8}px`;
    };
    return g(), p.addEventListener("input", g), {
      destroy() {
        O.remove(), p.removeEventListener("input", g);
      }
    };
  }
  async function a() {
    if (!Array.isArray(t())) return;
    t().push({ name: "", color: "red" }), await Vm();
    const p = r.length - 1, O = r[p];
    O && O.querySelector("input")?.focus();
  }
  var l = VA(), c = Ee(l), h = Ee(c), f = Ze(c, 2);
  {
    var u = (p) => {
      var O = BA();
      xi(() => {
        ya(O, "name", e.name), ya(O, "spellcheck", e.spellcheck);
      }), ld(O, t), qt(p, O);
    }, d = (p) => {
      var O = NA(), m = Ee(O);
      Zf(m, 17, () => Array.isArray(t()) ? t() : [], Mf, (v, S, w) => {
        var x = YA(), P = Ee(x);
        P.__click = () => {
          console.log("show"), s[w] = !0;
        };
        var k = Ee(P);
        om(k, () => te(S).color);
        var A = Ze(P, 2);
        Po(() => ld(A, () => te(S).name, (Q) => te(S).name = Q)), Km(A, (Q) => o?.(Q));
        var C = Ze(A, 2);
        C.__click = () => {
          Array.isArray(t()) && t().splice(t().indexOf(te(S)), 1);
        };
        var Z = Ze(C, 2);
        {
          var I = (Q) => {
            LA(Q, {
              get colorPreview() {
                return om;
              },
              onloosefocus: () => s[w] = !1,
              get tag() {
                return te(S);
              }
            });
          };
          La(Z, (Q) => {
            s[w] && Q(I);
          });
        }
        Pl(x, (Q, E) => r[E] = Q, (Q) => r?.[Q], () => [w]), qt(v, x);
      });
      var g = Ze(m, 2);
      g.__click = () => a(), qt(p, O);
    };
    La(f, (p) => {
      n() === "normal" ? p(u) : p(d, !1);
    });
  }
  xi(() => {
    ya(c, "for", e.name), mn(h, e.name);
  }), qt(i, l), ds();
}
Rf(["click"]);
var ma = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function qA(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
function ga(i) {
  throw new Error('Could not dynamically require "' + i + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var ih = { exports: {} };
var am;
function WA() {
  return am || (am = 1, (function(i, e) {
    (function(t) {
      i.exports = t();
    })(function() {
      return (function t(n, r, s) {
        function o(c, h) {
          if (!r[c]) {
            if (!n[c]) {
              var f = typeof ga == "function" && ga;
              if (!h && f) return f(c, !0);
              if (a) return a(c, !0);
              var u = new Error("Cannot find module '" + c + "'");
              throw u.code = "MODULE_NOT_FOUND", u;
            }
            var d = r[c] = { exports: {} };
            n[c][0].call(d.exports, function(p) {
              var O = n[c][1][p];
              return o(O || p);
            }, d, d.exports, t, n, r, s);
          }
          return r[c].exports;
        }
        for (var a = typeof ga == "function" && ga, l = 0; l < s.length; l++) o(s[l]);
        return o;
      })({ 1: [function(t, n, r) {
        var s = t("./utils"), o = t("./support"), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(l) {
          for (var c, h, f, u, d, p, O, m = [], g = 0, v = l.length, S = v, w = s.getTypeOf(l) !== "string"; g < l.length; ) S = v - g, f = w ? (c = l[g++], h = g < v ? l[g++] : 0, g < v ? l[g++] : 0) : (c = l.charCodeAt(g++), h = g < v ? l.charCodeAt(g++) : 0, g < v ? l.charCodeAt(g++) : 0), u = c >> 2, d = (3 & c) << 4 | h >> 4, p = 1 < S ? (15 & h) << 2 | f >> 6 : 64, O = 2 < S ? 63 & f : 64, m.push(a.charAt(u) + a.charAt(d) + a.charAt(p) + a.charAt(O));
          return m.join("");
        }, r.decode = function(l) {
          var c, h, f, u, d, p, O = 0, m = 0, g = "data:";
          if (l.substr(0, g.length) === g) throw new Error("Invalid base64 input, it looks like a data url.");
          var v, S = 3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (l.charAt(l.length - 1) === a.charAt(64) && S--, l.charAt(l.length - 2) === a.charAt(64) && S--, S % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
          for (v = o.uint8array ? new Uint8Array(0 | S) : new Array(0 | S); O < l.length; ) c = a.indexOf(l.charAt(O++)) << 2 | (u = a.indexOf(l.charAt(O++))) >> 4, h = (15 & u) << 4 | (d = a.indexOf(l.charAt(O++))) >> 2, f = (3 & d) << 6 | (p = a.indexOf(l.charAt(O++))), v[m++] = c, d !== 64 && (v[m++] = h), p !== 64 && (v[m++] = f);
          return v;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(t, n, r) {
        var s = t("./external"), o = t("./stream/DataWorker"), a = t("./stream/Crc32Probe"), l = t("./stream/DataLengthProbe");
        function c(h, f, u, d, p) {
          this.compressedSize = h, this.uncompressedSize = f, this.crc32 = u, this.compression = d, this.compressedContent = p;
        }
        c.prototype = { getContentWorker: function() {
          var h = new o(s.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), f = this;
          return h.on("end", function() {
            if (this.streamInfo.data_length !== f.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
          }), h;
        }, getCompressedWorker: function() {
          return new o(s.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, c.createWorkerFrom = function(h, f, u) {
          return h.pipe(new a()).pipe(new l("uncompressedSize")).pipe(f.compressWorker(u)).pipe(new l("compressedSize")).withStreamInfo("compression", f);
        }, n.exports = c;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(t, n, r) {
        var s = t("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new s("STORE compression");
        }, uncompressWorker: function() {
          return new s("STORE decompression");
        } }, r.DEFLATE = t("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(t, n, r) {
        var s = t("./utils"), o = (function() {
          for (var a, l = [], c = 0; c < 256; c++) {
            a = c;
            for (var h = 0; h < 8; h++) a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
            l[c] = a;
          }
          return l;
        })();
        n.exports = function(a, l) {
          return a !== void 0 && a.length ? s.getTypeOf(a) !== "string" ? (function(c, h, f, u) {
            var d = o, p = u + f;
            c ^= -1;
            for (var O = u; O < p; O++) c = c >>> 8 ^ d[255 & (c ^ h[O])];
            return -1 ^ c;
          })(0 | l, a, a.length, 0) : (function(c, h, f, u) {
            var d = o, p = u + f;
            c ^= -1;
            for (var O = u; O < p; O++) c = c >>> 8 ^ d[255 & (c ^ h.charCodeAt(O))];
            return -1 ^ c;
          })(0 | l, a, a.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(t, n, r) {
        r.base64 = !1, r.binary = !1, r.dir = !1, r.createFolders = !0, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(t, n, r) {
        var s = null;
        s = typeof Promise < "u" ? Promise : t("lie"), n.exports = { Promise: s };
      }, { lie: 37 }], 7: [function(t, n, r) {
        var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = t("pako"), a = t("./utils"), l = t("./stream/GenericWorker"), c = s ? "uint8array" : "array";
        function h(f, u) {
          l.call(this, "FlateWorker/" + f), this._pako = null, this._pakoAction = f, this._pakoOptions = u, this.meta = {};
        }
        r.magic = "\b\0", a.inherits(h, l), h.prototype.processChunk = function(f) {
          this.meta = f.meta, this._pako === null && this._createPako(), this._pako.push(a.transformTo(c, f.data), !1);
        }, h.prototype.flush = function() {
          l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
        }, h.prototype.cleanUp = function() {
          l.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new o[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
          var f = this;
          this._pako.onData = function(u) {
            f.push({ data: u, meta: f.meta });
          };
        }, r.compressWorker = function(f) {
          return new h("Deflate", f);
        }, r.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(t, n, r) {
        function s(d, p) {
          var O, m = "";
          for (O = 0; O < p; O++) m += String.fromCharCode(255 & d), d >>>= 8;
          return m;
        }
        function o(d, p, O, m, g, v) {
          var S, w, x = d.file, P = d.compression, k = v !== c.utf8encode, A = a.transformTo("string", v(x.name)), C = a.transformTo("string", c.utf8encode(x.name)), Z = x.comment, I = a.transformTo("string", v(Z)), Q = a.transformTo("string", c.utf8encode(Z)), E = C.length !== x.name.length, y = Q.length !== Z.length, L = "", se = "", V = "", fe = x.dir, W = x.date, ce = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          p && !O || (ce.crc32 = d.crc32, ce.compressedSize = d.compressedSize, ce.uncompressedSize = d.uncompressedSize);
          var z = 0;
          p && (z |= 8), k || !E && !y || (z |= 2048);
          var D = 0, J = 0;
          fe && (D |= 16), g === "UNIX" ? (J = 798, D |= (function(U, Qe) {
            var Ie = U;
            return U || (Ie = Qe ? 16893 : 33204), (65535 & Ie) << 16;
          })(x.unixPermissions, fe)) : (J = 20, D |= (function(U) {
            return 63 & (U || 0);
          })(x.dosPermissions)), S = W.getUTCHours(), S <<= 6, S |= W.getUTCMinutes(), S <<= 5, S |= W.getUTCSeconds() / 2, w = W.getUTCFullYear() - 1980, w <<= 4, w |= W.getUTCMonth() + 1, w <<= 5, w |= W.getUTCDate(), E && (se = s(1, 1) + s(h(A), 4) + C, L += "up" + s(se.length, 2) + se), y && (V = s(1, 1) + s(h(I), 4) + Q, L += "uc" + s(V.length, 2) + V);
          var ie = "";
          return ie += `
\0`, ie += s(z, 2), ie += P.magic, ie += s(S, 2), ie += s(w, 2), ie += s(ce.crc32, 4), ie += s(ce.compressedSize, 4), ie += s(ce.uncompressedSize, 4), ie += s(A.length, 2), ie += s(L.length, 2), { fileRecord: f.LOCAL_FILE_HEADER + ie + A + L, dirRecord: f.CENTRAL_FILE_HEADER + s(J, 2) + ie + s(I.length, 2) + "\0\0\0\0" + s(D, 4) + s(m, 4) + A + L + I };
        }
        var a = t("../utils"), l = t("../stream/GenericWorker"), c = t("../utf8"), h = t("../crc32"), f = t("../signature");
        function u(d, p, O, m) {
          l.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = p, this.zipPlatform = O, this.encodeFileName = m, this.streamFiles = d, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        a.inherits(u, l), u.prototype.push = function(d) {
          var p = d.meta.percent || 0, O = this.entriesCount, m = this._sources.length;
          this.accumulate ? this.contentBuffer.push(d) : (this.bytesWritten += d.data.length, l.prototype.push.call(this, { data: d.data, meta: { currentFile: this.currentFile, percent: O ? (p + 100 * (O - m - 1)) / O : 100 } }));
        }, u.prototype.openedSource = function(d) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = d.file.name;
          var p = this.streamFiles && !d.file.dir;
          if (p) {
            var O = o(d, p, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: O.fileRecord, meta: { percent: 0 } });
          } else this.accumulate = !0;
        }, u.prototype.closedSource = function(d) {
          this.accumulate = !1;
          var p = this.streamFiles && !d.file.dir, O = o(d, p, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(O.dirRecord), p) this.push({ data: (function(m) {
            return f.DATA_DESCRIPTOR + s(m.crc32, 4) + s(m.compressedSize, 4) + s(m.uncompressedSize, 4);
          })(d), meta: { percent: 100 } });
          else for (this.push({ data: O.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, u.prototype.flush = function() {
          for (var d = this.bytesWritten, p = 0; p < this.dirRecords.length; p++) this.push({ data: this.dirRecords[p], meta: { percent: 100 } });
          var O = this.bytesWritten - d, m = (function(g, v, S, w, x) {
            var P = a.transformTo("string", x(w));
            return f.CENTRAL_DIRECTORY_END + "\0\0\0\0" + s(g, 2) + s(g, 2) + s(v, 4) + s(S, 4) + s(P.length, 2) + P;
          })(this.dirRecords.length, O, d, this.zipComment, this.encodeFileName);
          this.push({ data: m, meta: { percent: 100 } });
        }, u.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, u.prototype.registerPrevious = function(d) {
          this._sources.push(d);
          var p = this;
          return d.on("data", function(O) {
            p.processChunk(O);
          }), d.on("end", function() {
            p.closedSource(p.previous.streamInfo), p._sources.length ? p.prepareNextSource() : p.end();
          }), d.on("error", function(O) {
            p.error(O);
          }), this;
        }, u.prototype.resume = function() {
          return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
        }, u.prototype.error = function(d) {
          var p = this._sources;
          if (!l.prototype.error.call(this, d)) return !1;
          for (var O = 0; O < p.length; O++) try {
            p[O].error(d);
          } catch {
          }
          return !0;
        }, u.prototype.lock = function() {
          l.prototype.lock.call(this);
          for (var d = this._sources, p = 0; p < d.length; p++) d[p].lock();
        }, n.exports = u;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(t, n, r) {
        var s = t("../compressions"), o = t("./ZipFileWorker");
        r.generateWorker = function(a, l, c) {
          var h = new o(l.streamFiles, c, l.platform, l.encodeFileName), f = 0;
          try {
            a.forEach(function(u, d) {
              f++;
              var p = (function(v, S) {
                var w = v || S, x = s[w];
                if (!x) throw new Error(w + " is not a valid compression method !");
                return x;
              })(d.options.compression, l.compression), O = d.options.compressionOptions || l.compressionOptions || {}, m = d.dir, g = d.date;
              d._compressWorker(p, O).withStreamInfo("file", { name: u, dir: m, date: g, comment: d.comment || "", unixPermissions: d.unixPermissions, dosPermissions: d.dosPermissions }).pipe(h);
            }), h.entriesCount = f;
          } catch (u) {
            h.error(u);
          }
          return h;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(t, n, r) {
        function s() {
          if (!(this instanceof s)) return new s();
          if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var o = new s();
            for (var a in this) typeof this[a] != "function" && (o[a] = this[a]);
            return o;
          };
        }
        (s.prototype = t("./object")).loadAsync = t("./load"), s.support = t("./support"), s.defaults = t("./defaults"), s.version = "3.10.1", s.loadAsync = function(o, a) {
          return new s().loadAsync(o, a);
        }, s.external = t("./external"), n.exports = s;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(t, n, r) {
        var s = t("./utils"), o = t("./external"), a = t("./utf8"), l = t("./zipEntries"), c = t("./stream/Crc32Probe"), h = t("./nodejsUtils");
        function f(u) {
          return new o.Promise(function(d, p) {
            var O = u.decompressed.getContentWorker().pipe(new c());
            O.on("error", function(m) {
              p(m);
            }).on("end", function() {
              O.streamInfo.crc32 !== u.decompressed.crc32 ? p(new Error("Corrupted zip : CRC32 mismatch")) : d();
            }).resume();
          });
        }
        n.exports = function(u, d) {
          var p = this;
          return d = s.extend(d || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: a.utf8decode }), h.isNode && h.isStream(u) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : s.prepareContent("the loaded zip file", u, !0, d.optimizedBinaryString, d.base64).then(function(O) {
            var m = new l(d);
            return m.load(O), m;
          }).then(function(O) {
            var m = [o.Promise.resolve(O)], g = O.files;
            if (d.checkCRC32) for (var v = 0; v < g.length; v++) m.push(f(g[v]));
            return o.Promise.all(m);
          }).then(function(O) {
            for (var m = O.shift(), g = m.files, v = 0; v < g.length; v++) {
              var S = g[v], w = S.fileNameStr, x = s.resolve(S.fileNameStr);
              p.file(x, S.decompressed, { binary: !0, optimizedBinaryString: !0, date: S.date, dir: S.dir, comment: S.fileCommentStr.length ? S.fileCommentStr : null, unixPermissions: S.unixPermissions, dosPermissions: S.dosPermissions, createFolders: d.createFolders }), S.dir || (p.file(x).unsafeOriginalName = w);
            }
            return m.zipComment.length && (p.comment = m.zipComment), p;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(t, n, r) {
        var s = t("../utils"), o = t("../stream/GenericWorker");
        function a(l, c) {
          o.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(c);
        }
        s.inherits(a, o), a.prototype._bindStream = function(l) {
          var c = this;
          (this._stream = l).pause(), l.on("data", function(h) {
            c.push({ data: h, meta: { percent: 0 } });
          }).on("error", function(h) {
            c.isPaused ? this.generatedError = h : c.error(h);
          }).on("end", function() {
            c.isPaused ? c._upstreamEnded = !0 : c.end();
          });
        }, a.prototype.pause = function() {
          return !!o.prototype.pause.call(this) && (this._stream.pause(), !0);
        }, a.prototype.resume = function() {
          return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
        }, n.exports = a;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(t, n, r) {
        var s = t("readable-stream").Readable;
        function o(a, l, c) {
          s.call(this, l), this._helper = a;
          var h = this;
          a.on("data", function(f, u) {
            h.push(f) || h._helper.pause(), c && c(u);
          }).on("error", function(f) {
            h.emit("error", f);
          }).on("end", function() {
            h.push(null);
          });
        }
        t("../utils").inherits(o, s), o.prototype._read = function() {
          this._helper.resume();
        }, n.exports = o;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(t, n, r) {
        n.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(s, o) {
          if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(s, o);
          if (typeof s == "number") throw new Error('The "data" argument must not be a number');
          return new Buffer(s, o);
        }, allocBuffer: function(s) {
          if (Buffer.alloc) return Buffer.alloc(s);
          var o = new Buffer(s);
          return o.fill(0), o;
        }, isBuffer: function(s) {
          return Buffer.isBuffer(s);
        }, isStream: function(s) {
          return s && typeof s.on == "function" && typeof s.pause == "function" && typeof s.resume == "function";
        } };
      }, {}], 15: [function(t, n, r) {
        function s(x, P, k) {
          var A, C = a.getTypeOf(P), Z = a.extend(k || {}, h);
          Z.date = Z.date || /* @__PURE__ */ new Date(), Z.compression !== null && (Z.compression = Z.compression.toUpperCase()), typeof Z.unixPermissions == "string" && (Z.unixPermissions = parseInt(Z.unixPermissions, 8)), Z.unixPermissions && 16384 & Z.unixPermissions && (Z.dir = !0), Z.dosPermissions && 16 & Z.dosPermissions && (Z.dir = !0), Z.dir && (x = g(x)), Z.createFolders && (A = m(x)) && v.call(this, A, !0);
          var I = C === "string" && Z.binary === !1 && Z.base64 === !1;
          k && k.binary !== void 0 || (Z.binary = !I), (P instanceof f && P.uncompressedSize === 0 || Z.dir || !P || P.length === 0) && (Z.base64 = !1, Z.binary = !0, P = "", Z.compression = "STORE", C = "string");
          var Q = null;
          Q = P instanceof f || P instanceof l ? P : p.isNode && p.isStream(P) ? new O(x, P) : a.prepareContent(x, P, Z.binary, Z.optimizedBinaryString, Z.base64);
          var E = new u(x, Q, Z);
          this.files[x] = E;
        }
        var o = t("./utf8"), a = t("./utils"), l = t("./stream/GenericWorker"), c = t("./stream/StreamHelper"), h = t("./defaults"), f = t("./compressedObject"), u = t("./zipObject"), d = t("./generate"), p = t("./nodejsUtils"), O = t("./nodejs/NodejsStreamInputAdapter"), m = function(x) {
          x.slice(-1) === "/" && (x = x.substring(0, x.length - 1));
          var P = x.lastIndexOf("/");
          return 0 < P ? x.substring(0, P) : "";
        }, g = function(x) {
          return x.slice(-1) !== "/" && (x += "/"), x;
        }, v = function(x, P) {
          return P = P !== void 0 ? P : h.createFolders, x = g(x), this.files[x] || s.call(this, x, null, { dir: !0, createFolders: P }), this.files[x];
        };
        function S(x) {
          return Object.prototype.toString.call(x) === "[object RegExp]";
        }
        var w = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(x) {
          var P, k, A;
          for (P in this.files) A = this.files[P], (k = P.slice(this.root.length, P.length)) && P.slice(0, this.root.length) === this.root && x(k, A);
        }, filter: function(x) {
          var P = [];
          return this.forEach(function(k, A) {
            x(k, A) && P.push(A);
          }), P;
        }, file: function(x, P, k) {
          if (arguments.length !== 1) return x = this.root + x, s.call(this, x, P, k), this;
          if (S(x)) {
            var A = x;
            return this.filter(function(Z, I) {
              return !I.dir && A.test(Z);
            });
          }
          var C = this.files[this.root + x];
          return C && !C.dir ? C : null;
        }, folder: function(x) {
          if (!x) return this;
          if (S(x)) return this.filter(function(C, Z) {
            return Z.dir && x.test(C);
          });
          var P = this.root + x, k = v.call(this, P), A = this.clone();
          return A.root = k.name, A;
        }, remove: function(x) {
          x = this.root + x;
          var P = this.files[x];
          if (P || (x.slice(-1) !== "/" && (x += "/"), P = this.files[x]), P && !P.dir) delete this.files[x];
          else for (var k = this.filter(function(C, Z) {
            return Z.name.slice(0, x.length) === x;
          }), A = 0; A < k.length; A++) delete this.files[k[A].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(x) {
          var P, k = {};
          try {
            if ((k = a.extend(x || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = k.type.toLowerCase(), k.compression = k.compression.toUpperCase(), k.type === "binarystring" && (k.type = "string"), !k.type) throw new Error("No output type specified.");
            a.checkSupport(k.type), k.platform !== "darwin" && k.platform !== "freebsd" && k.platform !== "linux" && k.platform !== "sunos" || (k.platform = "UNIX"), k.platform === "win32" && (k.platform = "DOS");
            var A = k.comment || this.comment || "";
            P = d.generateWorker(this, k, A);
          } catch (C) {
            (P = new l("error")).error(C);
          }
          return new c(P, k.type || "string", k.mimeType);
        }, generateAsync: function(x, P) {
          return this.generateInternalStream(x).accumulate(P);
        }, generateNodeStream: function(x, P) {
          return (x = x || {}).type || (x.type = "nodebuffer"), this.generateInternalStream(x).toNodejsStream(P);
        } };
        n.exports = w;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(t, n, r) {
        n.exports = t("stream");
      }, { stream: void 0 }], 17: [function(t, n, r) {
        var s = t("./DataReader");
        function o(a) {
          s.call(this, a);
          for (var l = 0; l < this.data.length; l++) a[l] = 255 & a[l];
        }
        t("../utils").inherits(o, s), o.prototype.byteAt = function(a) {
          return this.data[this.zero + a];
        }, o.prototype.lastIndexOfSignature = function(a) {
          for (var l = a.charCodeAt(0), c = a.charCodeAt(1), h = a.charCodeAt(2), f = a.charCodeAt(3), u = this.length - 4; 0 <= u; --u) if (this.data[u] === l && this.data[u + 1] === c && this.data[u + 2] === h && this.data[u + 3] === f) return u - this.zero;
          return -1;
        }, o.prototype.readAndCheckSignature = function(a) {
          var l = a.charCodeAt(0), c = a.charCodeAt(1), h = a.charCodeAt(2), f = a.charCodeAt(3), u = this.readData(4);
          return l === u[0] && c === u[1] && h === u[2] && f === u[3];
        }, o.prototype.readData = function(a) {
          if (this.checkOffset(a), a === 0) return [];
          var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
          return this.index += a, l;
        }, n.exports = o;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(t, n, r) {
        var s = t("../utils");
        function o(a) {
          this.data = a, this.length = a.length, this.index = 0, this.zero = 0;
        }
        o.prototype = { checkOffset: function(a) {
          this.checkIndex(this.index + a);
        }, checkIndex: function(a) {
          if (this.length < this.zero + a || a < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
        }, setIndex: function(a) {
          this.checkIndex(a), this.index = a;
        }, skip: function(a) {
          this.setIndex(this.index + a);
        }, byteAt: function() {
        }, readInt: function(a) {
          var l, c = 0;
          for (this.checkOffset(a), l = this.index + a - 1; l >= this.index; l--) c = (c << 8) + this.byteAt(l);
          return this.index += a, c;
        }, readString: function(a) {
          return s.transformTo("string", this.readData(a));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var a = this.readInt(4);
          return new Date(Date.UTC(1980 + (a >> 25 & 127), (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1));
        } }, n.exports = o;
      }, { "../utils": 32 }], 19: [function(t, n, r) {
        var s = t("./Uint8ArrayReader");
        function o(a) {
          s.call(this, a);
        }
        t("../utils").inherits(o, s), o.prototype.readData = function(a) {
          this.checkOffset(a);
          var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
          return this.index += a, l;
        }, n.exports = o;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(t, n, r) {
        var s = t("./DataReader");
        function o(a) {
          s.call(this, a);
        }
        t("../utils").inherits(o, s), o.prototype.byteAt = function(a) {
          return this.data.charCodeAt(this.zero + a);
        }, o.prototype.lastIndexOfSignature = function(a) {
          return this.data.lastIndexOf(a) - this.zero;
        }, o.prototype.readAndCheckSignature = function(a) {
          return a === this.readData(4);
        }, o.prototype.readData = function(a) {
          this.checkOffset(a);
          var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
          return this.index += a, l;
        }, n.exports = o;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(t, n, r) {
        var s = t("./ArrayReader");
        function o(a) {
          s.call(this, a);
        }
        t("../utils").inherits(o, s), o.prototype.readData = function(a) {
          if (this.checkOffset(a), a === 0) return new Uint8Array(0);
          var l = this.data.subarray(this.zero + this.index, this.zero + this.index + a);
          return this.index += a, l;
        }, n.exports = o;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(t, n, r) {
        var s = t("../utils"), o = t("../support"), a = t("./ArrayReader"), l = t("./StringReader"), c = t("./NodeBufferReader"), h = t("./Uint8ArrayReader");
        n.exports = function(f) {
          var u = s.getTypeOf(f);
          return s.checkSupport(u), u !== "string" || o.uint8array ? u === "nodebuffer" ? new c(f) : o.uint8array ? new h(s.transformTo("uint8array", f)) : new a(s.transformTo("array", f)) : new l(f);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(t, n, r) {
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(t, n, r) {
        var s = t("./GenericWorker"), o = t("../utils");
        function a(l) {
          s.call(this, "ConvertWorker to " + l), this.destType = l;
        }
        o.inherits(a, s), a.prototype.processChunk = function(l) {
          this.push({ data: o.transformTo(this.destType, l.data), meta: l.meta });
        }, n.exports = a;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(t, n, r) {
        var s = t("./GenericWorker"), o = t("../crc32");
        function a() {
          s.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        t("../utils").inherits(a, s), a.prototype.processChunk = function(l) {
          this.streamInfo.crc32 = o(l.data, this.streamInfo.crc32 || 0), this.push(l);
        }, n.exports = a;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(t, n, r) {
        var s = t("../utils"), o = t("./GenericWorker");
        function a(l) {
          o.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
        }
        s.inherits(a, o), a.prototype.processChunk = function(l) {
          if (l) {
            var c = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = c + l.data.length;
          }
          o.prototype.processChunk.call(this, l);
        }, n.exports = a;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(t, n, r) {
        var s = t("../utils"), o = t("./GenericWorker");
        function a(l) {
          o.call(this, "DataWorker");
          var c = this;
          this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, l.then(function(h) {
            c.dataIsReady = !0, c.data = h, c.max = h && h.length || 0, c.type = s.getTypeOf(h), c.isPaused || c._tickAndRepeat();
          }, function(h) {
            c.error(h);
          });
        }
        s.inherits(a, o), a.prototype.cleanUp = function() {
          o.prototype.cleanUp.call(this), this.data = null;
        }, a.prototype.resume = function() {
          return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, s.delay(this._tickAndRepeat, [], this)), !0);
        }, a.prototype._tickAndRepeat = function() {
          this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (s.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
        }, a.prototype._tick = function() {
          if (this.isPaused || this.isFinished) return !1;
          var l = null, c = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max) return this.end();
          switch (this.type) {
            case "string":
              l = this.data.substring(this.index, c);
              break;
            case "uint8array":
              l = this.data.subarray(this.index, c);
              break;
            case "array":
            case "nodebuffer":
              l = this.data.slice(this.index, c);
          }
          return this.index = c, this.push({ data: l, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, n.exports = a;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(t, n, r) {
        function s(o) {
          this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        s.prototype = { push: function(o) {
          this.emit("data", o);
        }, end: function() {
          if (this.isFinished) return !1;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = !0;
          } catch (o) {
            this.emit("error", o);
          }
          return !0;
        }, error: function(o) {
          return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
        }, on: function(o, a) {
          return this._listeners[o].push(a), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(o, a) {
          if (this._listeners[o]) for (var l = 0; l < this._listeners[o].length; l++) this._listeners[o][l].call(this, a);
        }, pipe: function(o) {
          return o.registerPrevious(this);
        }, registerPrevious: function(o) {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
          var a = this;
          return o.on("data", function(l) {
            a.processChunk(l);
          }), o.on("end", function() {
            a.end();
          }), o.on("error", function(l) {
            a.error(l);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
        }, resume: function() {
          if (!this.isPaused || this.isFinished) return !1;
          var o = this.isPaused = !1;
          return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
        }, flush: function() {
        }, processChunk: function(o) {
          this.push(o);
        }, withStreamInfo: function(o, a) {
          return this.extraStreamInfo[o] = a, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var o in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
        }, lock: function() {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = !0, this.previous && this.previous.lock();
        }, toString: function() {
          var o = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + o : o;
        } }, n.exports = s;
      }, {}], 29: [function(t, n, r) {
        var s = t("../utils"), o = t("./ConvertWorker"), a = t("./GenericWorker"), l = t("../base64"), c = t("../support"), h = t("../external"), f = null;
        if (c.nodestream) try {
          f = t("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
        function u(p, O) {
          return new h.Promise(function(m, g) {
            var v = [], S = p._internalType, w = p._outputType, x = p._mimeType;
            p.on("data", function(P, k) {
              v.push(P), O && O(k);
            }).on("error", function(P) {
              v = [], g(P);
            }).on("end", function() {
              try {
                var P = (function(k, A, C) {
                  switch (k) {
                    case "blob":
                      return s.newBlob(s.transformTo("arraybuffer", A), C);
                    case "base64":
                      return l.encode(A);
                    default:
                      return s.transformTo(k, A);
                  }
                })(w, (function(k, A) {
                  var C, Z = 0, I = null, Q = 0;
                  for (C = 0; C < A.length; C++) Q += A[C].length;
                  switch (k) {
                    case "string":
                      return A.join("");
                    case "array":
                      return Array.prototype.concat.apply([], A);
                    case "uint8array":
                      for (I = new Uint8Array(Q), C = 0; C < A.length; C++) I.set(A[C], Z), Z += A[C].length;
                      return I;
                    case "nodebuffer":
                      return Buffer.concat(A);
                    default:
                      throw new Error("concat : unsupported type '" + k + "'");
                  }
                })(S, v), x);
                m(P);
              } catch (k) {
                g(k);
              }
              v = [];
            }).resume();
          });
        }
        function d(p, O, m) {
          var g = O;
          switch (O) {
            case "blob":
            case "arraybuffer":
              g = "uint8array";
              break;
            case "base64":
              g = "string";
          }
          try {
            this._internalType = g, this._outputType = O, this._mimeType = m, s.checkSupport(g), this._worker = p.pipe(new o(g)), p.lock();
          } catch (v) {
            this._worker = new a("error"), this._worker.error(v);
          }
        }
        d.prototype = { accumulate: function(p) {
          return u(this, p);
        }, on: function(p, O) {
          var m = this;
          return p === "data" ? this._worker.on(p, function(g) {
            O.call(m, g.data, g.meta);
          }) : this._worker.on(p, function() {
            s.delay(O, arguments, m);
          }), this;
        }, resume: function() {
          return s.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(p) {
          if (s.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
          return new f(this, { objectMode: this._outputType !== "nodebuffer" }, p);
        } }, n.exports = d;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(t, n, r) {
        if (r.base64 = !0, r.array = !0, r.string = !0, r.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", r.nodebuffer = typeof Buffer < "u", r.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") r.blob = !1;
        else {
          var s = new ArrayBuffer(0);
          try {
            r.blob = new Blob([s], { type: "application/zip" }).size === 0;
          } catch {
            try {
              var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              o.append(s), r.blob = o.getBlob("application/zip").size === 0;
            } catch {
              r.blob = !1;
            }
          }
        }
        try {
          r.nodestream = !!t("readable-stream").Readable;
        } catch {
          r.nodestream = !1;
        }
      }, { "readable-stream": 16 }], 31: [function(t, n, r) {
        for (var s = t("./utils"), o = t("./support"), a = t("./nodejsUtils"), l = t("./stream/GenericWorker"), c = new Array(256), h = 0; h < 256; h++) c[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
        c[254] = c[254] = 1;
        function f() {
          l.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function u() {
          l.call(this, "utf-8 encode");
        }
        r.utf8encode = function(d) {
          return o.nodebuffer ? a.newBufferFrom(d, "utf-8") : (function(p) {
            var O, m, g, v, S, w = p.length, x = 0;
            for (v = 0; v < w; v++) (64512 & (m = p.charCodeAt(v))) == 55296 && v + 1 < w && (64512 & (g = p.charCodeAt(v + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (g - 56320), v++), x += m < 128 ? 1 : m < 2048 ? 2 : m < 65536 ? 3 : 4;
            for (O = o.uint8array ? new Uint8Array(x) : new Array(x), v = S = 0; S < x; v++) (64512 & (m = p.charCodeAt(v))) == 55296 && v + 1 < w && (64512 & (g = p.charCodeAt(v + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (g - 56320), v++), m < 128 ? O[S++] = m : (m < 2048 ? O[S++] = 192 | m >>> 6 : (m < 65536 ? O[S++] = 224 | m >>> 12 : (O[S++] = 240 | m >>> 18, O[S++] = 128 | m >>> 12 & 63), O[S++] = 128 | m >>> 6 & 63), O[S++] = 128 | 63 & m);
            return O;
          })(d);
        }, r.utf8decode = function(d) {
          return o.nodebuffer ? s.transformTo("nodebuffer", d).toString("utf-8") : (function(p) {
            var O, m, g, v, S = p.length, w = new Array(2 * S);
            for (O = m = 0; O < S; ) if ((g = p[O++]) < 128) w[m++] = g;
            else if (4 < (v = c[g])) w[m++] = 65533, O += v - 1;
            else {
              for (g &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && O < S; ) g = g << 6 | 63 & p[O++], v--;
              1 < v ? w[m++] = 65533 : g < 65536 ? w[m++] = g : (g -= 65536, w[m++] = 55296 | g >> 10 & 1023, w[m++] = 56320 | 1023 & g);
            }
            return w.length !== m && (w.subarray ? w = w.subarray(0, m) : w.length = m), s.applyFromCharCode(w);
          })(d = s.transformTo(o.uint8array ? "uint8array" : "array", d));
        }, s.inherits(f, l), f.prototype.processChunk = function(d) {
          var p = s.transformTo(o.uint8array ? "uint8array" : "array", d.data);
          if (this.leftOver && this.leftOver.length) {
            if (o.uint8array) {
              var O = p;
              (p = new Uint8Array(O.length + this.leftOver.length)).set(this.leftOver, 0), p.set(O, this.leftOver.length);
            } else p = this.leftOver.concat(p);
            this.leftOver = null;
          }
          var m = (function(v, S) {
            var w;
            for ((S = S || v.length) > v.length && (S = v.length), w = S - 1; 0 <= w && (192 & v[w]) == 128; ) w--;
            return w < 0 || w === 0 ? S : w + c[v[w]] > S ? w : S;
          })(p), g = p;
          m !== p.length && (o.uint8array ? (g = p.subarray(0, m), this.leftOver = p.subarray(m, p.length)) : (g = p.slice(0, m), this.leftOver = p.slice(m, p.length))), this.push({ data: r.utf8decode(g), meta: d.meta });
        }, f.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: r.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, r.Utf8DecodeWorker = f, s.inherits(u, l), u.prototype.processChunk = function(d) {
          this.push({ data: r.utf8encode(d.data), meta: d.meta });
        }, r.Utf8EncodeWorker = u;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(t, n, r) {
        var s = t("./support"), o = t("./base64"), a = t("./nodejsUtils"), l = t("./external");
        function c(O) {
          return O;
        }
        function h(O, m) {
          for (var g = 0; g < O.length; ++g) m[g] = 255 & O.charCodeAt(g);
          return m;
        }
        t("setimmediate"), r.newBlob = function(O, m) {
          r.checkSupport("blob");
          try {
            return new Blob([O], { type: m });
          } catch {
            try {
              var g = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return g.append(O), g.getBlob(m);
            } catch {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var f = { stringifyByChunk: function(O, m, g) {
          var v = [], S = 0, w = O.length;
          if (w <= g) return String.fromCharCode.apply(null, O);
          for (; S < w; ) m === "array" || m === "nodebuffer" ? v.push(String.fromCharCode.apply(null, O.slice(S, Math.min(S + g, w)))) : v.push(String.fromCharCode.apply(null, O.subarray(S, Math.min(S + g, w)))), S += g;
          return v.join("");
        }, stringifyByChar: function(O) {
          for (var m = "", g = 0; g < O.length; g++) m += String.fromCharCode(O[g]);
          return m;
        }, applyCanBeUsed: { uint8array: (function() {
          try {
            return s.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch {
            return !1;
          }
        })(), nodebuffer: (function() {
          try {
            return s.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1;
          } catch {
            return !1;
          }
        })() } };
        function u(O) {
          var m = 65536, g = r.getTypeOf(O), v = !0;
          if (g === "uint8array" ? v = f.applyCanBeUsed.uint8array : g === "nodebuffer" && (v = f.applyCanBeUsed.nodebuffer), v) for (; 1 < m; ) try {
            return f.stringifyByChunk(O, g, m);
          } catch {
            m = Math.floor(m / 2);
          }
          return f.stringifyByChar(O);
        }
        function d(O, m) {
          for (var g = 0; g < O.length; g++) m[g] = O[g];
          return m;
        }
        r.applyFromCharCode = u;
        var p = {};
        p.string = { string: c, array: function(O) {
          return h(O, new Array(O.length));
        }, arraybuffer: function(O) {
          return p.string.uint8array(O).buffer;
        }, uint8array: function(O) {
          return h(O, new Uint8Array(O.length));
        }, nodebuffer: function(O) {
          return h(O, a.allocBuffer(O.length));
        } }, p.array = { string: u, array: c, arraybuffer: function(O) {
          return new Uint8Array(O).buffer;
        }, uint8array: function(O) {
          return new Uint8Array(O);
        }, nodebuffer: function(O) {
          return a.newBufferFrom(O);
        } }, p.arraybuffer = { string: function(O) {
          return u(new Uint8Array(O));
        }, array: function(O) {
          return d(new Uint8Array(O), new Array(O.byteLength));
        }, arraybuffer: c, uint8array: function(O) {
          return new Uint8Array(O);
        }, nodebuffer: function(O) {
          return a.newBufferFrom(new Uint8Array(O));
        } }, p.uint8array = { string: u, array: function(O) {
          return d(O, new Array(O.length));
        }, arraybuffer: function(O) {
          return O.buffer;
        }, uint8array: c, nodebuffer: function(O) {
          return a.newBufferFrom(O);
        } }, p.nodebuffer = { string: u, array: function(O) {
          return d(O, new Array(O.length));
        }, arraybuffer: function(O) {
          return p.nodebuffer.uint8array(O).buffer;
        }, uint8array: function(O) {
          return d(O, new Uint8Array(O.length));
        }, nodebuffer: c }, r.transformTo = function(O, m) {
          if (m = m || "", !O) return m;
          r.checkSupport(O);
          var g = r.getTypeOf(m);
          return p[g][O](m);
        }, r.resolve = function(O) {
          for (var m = O.split("/"), g = [], v = 0; v < m.length; v++) {
            var S = m[v];
            S === "." || S === "" && v !== 0 && v !== m.length - 1 || (S === ".." ? g.pop() : g.push(S));
          }
          return g.join("/");
        }, r.getTypeOf = function(O) {
          return typeof O == "string" ? "string" : Object.prototype.toString.call(O) === "[object Array]" ? "array" : s.nodebuffer && a.isBuffer(O) ? "nodebuffer" : s.uint8array && O instanceof Uint8Array ? "uint8array" : s.arraybuffer && O instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, r.checkSupport = function(O) {
          if (!s[O.toLowerCase()]) throw new Error(O + " is not supported by this platform");
        }, r.MAX_VALUE_16BITS = 65535, r.MAX_VALUE_32BITS = -1, r.pretty = function(O) {
          var m, g, v = "";
          for (g = 0; g < (O || "").length; g++) v += "\\x" + ((m = O.charCodeAt(g)) < 16 ? "0" : "") + m.toString(16).toUpperCase();
          return v;
        }, r.delay = function(O, m, g) {
          setImmediate(function() {
            O.apply(g || null, m || []);
          });
        }, r.inherits = function(O, m) {
          function g() {
          }
          g.prototype = m.prototype, O.prototype = new g();
        }, r.extend = function() {
          var O, m, g = {};
          for (O = 0; O < arguments.length; O++) for (m in arguments[O]) Object.prototype.hasOwnProperty.call(arguments[O], m) && g[m] === void 0 && (g[m] = arguments[O][m]);
          return g;
        }, r.prepareContent = function(O, m, g, v, S) {
          return l.Promise.resolve(m).then(function(w) {
            return s.blob && (w instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(w)) !== -1) && typeof FileReader < "u" ? new l.Promise(function(x, P) {
              var k = new FileReader();
              k.onload = function(A) {
                x(A.target.result);
              }, k.onerror = function(A) {
                P(A.target.error);
              }, k.readAsArrayBuffer(w);
            }) : w;
          }).then(function(w) {
            var x = r.getTypeOf(w);
            return x ? (x === "arraybuffer" ? w = r.transformTo("uint8array", w) : x === "string" && (S ? w = o.decode(w) : g && v !== !0 && (w = (function(P) {
              return h(P, s.uint8array ? new Uint8Array(P.length) : new Array(P.length));
            })(w))), w) : l.Promise.reject(new Error("Can't read the data of '" + O + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(t, n, r) {
        var s = t("./reader/readerFor"), o = t("./utils"), a = t("./signature"), l = t("./zipEntry"), c = t("./support");
        function h(f) {
          this.files = [], this.loadOptions = f;
        }
        h.prototype = { checkSignature: function(f) {
          if (!this.reader.readAndCheckSignature(f)) {
            this.reader.index -= 4;
            var u = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(u) + ", expected " + o.pretty(f) + ")");
          }
        }, isSignature: function(f, u) {
          var d = this.reader.index;
          this.reader.setIndex(f);
          var p = this.reader.readString(4) === u;
          return this.reader.setIndex(d), p;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var f = this.reader.readData(this.zipCommentLength), u = c.uint8array ? "uint8array" : "array", d = o.transformTo(u, f);
          this.zipComment = this.loadOptions.decodeFileName(d);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var f, u, d, p = this.zip64EndOfCentralSize - 44; 0 < p; ) f = this.reader.readInt(2), u = this.reader.readInt(4), d = this.reader.readData(u), this.zip64ExtensibleData[f] = { id: f, length: u, value: d };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var f, u;
          for (f = 0; f < this.files.length; f++) u = this.files[f], this.reader.setIndex(u.localHeaderOffset), this.checkSignature(a.LOCAL_FILE_HEADER), u.readLocalPart(this.reader), u.handleUTF8(), u.processAttributes();
        }, readCentralDir: function() {
          var f;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); ) (f = new l({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(f);
          if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var f = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
          if (f < 0) throw this.isSignature(0, a.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
          this.reader.setIndex(f);
          var u = f;
          if (this.checkSignature(a.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
            if (this.zip64 = !0, (f = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(f), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var d = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (d += 20, d += 12 + this.zip64EndOfCentralSize);
          var p = u - d;
          if (0 < p) this.isSignature(u, a.CENTRAL_FILE_HEADER) || (this.reader.zero = p);
          else if (p < 0) throw new Error("Corrupted zip: missing " + Math.abs(p) + " bytes.");
        }, prepareReader: function(f) {
          this.reader = s(f);
        }, load: function(f) {
          this.prepareReader(f), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, n.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(t, n, r) {
        var s = t("./reader/readerFor"), o = t("./utils"), a = t("./compressedObject"), l = t("./crc32"), c = t("./utf8"), h = t("./compressions"), f = t("./support");
        function u(d, p) {
          this.options = d, this.loadOptions = p;
        }
        u.prototype = { isEncrypted: function() {
          return (1 & this.bitFlag) == 1;
        }, useUTF8: function() {
          return (2048 & this.bitFlag) == 2048;
        }, readLocalPart: function(d) {
          var p, O;
          if (d.skip(22), this.fileNameLength = d.readInt(2), O = d.readInt(2), this.fileName = d.readData(this.fileNameLength), d.skip(O), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if ((p = (function(m) {
            for (var g in h) if (Object.prototype.hasOwnProperty.call(h, g) && h[g].magic === m) return h[g];
            return null;
          })(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
          this.decompressed = new a(this.compressedSize, this.uncompressedSize, this.crc32, p, d.readData(this.compressedSize));
        }, readCentralPart: function(d) {
          this.versionMadeBy = d.readInt(2), d.skip(2), this.bitFlag = d.readInt(2), this.compressionMethod = d.readString(2), this.date = d.readDate(), this.crc32 = d.readInt(4), this.compressedSize = d.readInt(4), this.uncompressedSize = d.readInt(4);
          var p = d.readInt(2);
          if (this.extraFieldsLength = d.readInt(2), this.fileCommentLength = d.readInt(2), this.diskNumberStart = d.readInt(2), this.internalFileAttributes = d.readInt(2), this.externalFileAttributes = d.readInt(4), this.localHeaderOffset = d.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
          d.skip(p), this.readExtraFields(d), this.parseZIP64ExtraField(d), this.fileComment = d.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var d = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), d == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), d == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var d = s(this.extraFields[1].value);
            this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = d.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = d.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = d.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = d.readInt(4));
          }
        }, readExtraFields: function(d) {
          var p, O, m, g = d.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); d.index + 4 < g; ) p = d.readInt(2), O = d.readInt(2), m = d.readData(O), this.extraFields[p] = { id: p, length: O, value: m };
          d.setIndex(g);
        }, handleUTF8: function() {
          var d = f.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
          else {
            var p = this.findExtraFieldUnicodePath();
            if (p !== null) this.fileNameStr = p;
            else {
              var O = o.transformTo(d, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(O);
            }
            var m = this.findExtraFieldUnicodeComment();
            if (m !== null) this.fileCommentStr = m;
            else {
              var g = o.transformTo(d, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(g);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var d = this.extraFields[28789];
          if (d) {
            var p = s(d.value);
            return p.readInt(1) !== 1 || l(this.fileName) !== p.readInt(4) ? null : c.utf8decode(p.readData(d.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var d = this.extraFields[25461];
          if (d) {
            var p = s(d.value);
            return p.readInt(1) !== 1 || l(this.fileComment) !== p.readInt(4) ? null : c.utf8decode(p.readData(d.length - 5));
          }
          return null;
        } }, n.exports = u;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(t, n, r) {
        function s(p, O, m) {
          this.name = p, this.dir = m.dir, this.date = m.date, this.comment = m.comment, this.unixPermissions = m.unixPermissions, this.dosPermissions = m.dosPermissions, this._data = O, this._dataBinary = m.binary, this.options = { compression: m.compression, compressionOptions: m.compressionOptions };
        }
        var o = t("./stream/StreamHelper"), a = t("./stream/DataWorker"), l = t("./utf8"), c = t("./compressedObject"), h = t("./stream/GenericWorker");
        s.prototype = { internalStream: function(p) {
          var O = null, m = "string";
          try {
            if (!p) throw new Error("No output type specified.");
            var g = (m = p.toLowerCase()) === "string" || m === "text";
            m !== "binarystring" && m !== "text" || (m = "string"), O = this._decompressWorker();
            var v = !this._dataBinary;
            v && !g && (O = O.pipe(new l.Utf8EncodeWorker())), !v && g && (O = O.pipe(new l.Utf8DecodeWorker()));
          } catch (S) {
            (O = new h("error")).error(S);
          }
          return new o(O, m, "");
        }, async: function(p, O) {
          return this.internalStream(p).accumulate(O);
        }, nodeStream: function(p, O) {
          return this.internalStream(p || "nodebuffer").toNodejsStream(O);
        }, _compressWorker: function(p, O) {
          if (this._data instanceof c && this._data.compression.magic === p.magic) return this._data.getCompressedWorker();
          var m = this._decompressWorker();
          return this._dataBinary || (m = m.pipe(new l.Utf8EncodeWorker())), c.createWorkerFrom(m, p, O);
        }, _decompressWorker: function() {
          return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof h ? this._data : new a(this._data);
        } };
        for (var f = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], u = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, d = 0; d < f.length; d++) s.prototype[f[d]] = u;
        n.exports = s;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(t, n, r) {
        (function(s) {
          var o, a, l = s.MutationObserver || s.WebKitMutationObserver;
          if (l) {
            var c = 0, h = new l(p), f = s.document.createTextNode("");
            h.observe(f, { characterData: !0 }), o = function() {
              f.data = c = ++c % 2;
            };
          } else if (s.setImmediate || s.MessageChannel === void 0) o = "document" in s && "onreadystatechange" in s.document.createElement("script") ? function() {
            var O = s.document.createElement("script");
            O.onreadystatechange = function() {
              p(), O.onreadystatechange = null, O.parentNode.removeChild(O), O = null;
            }, s.document.documentElement.appendChild(O);
          } : function() {
            setTimeout(p, 0);
          };
          else {
            var u = new s.MessageChannel();
            u.port1.onmessage = p, o = function() {
              u.port2.postMessage(0);
            };
          }
          var d = [];
          function p() {
            var O, m;
            a = !0;
            for (var g = d.length; g; ) {
              for (m = d, d = [], O = -1; ++O < g; ) m[O]();
              g = d.length;
            }
            a = !1;
          }
          n.exports = function(O) {
            d.push(O) !== 1 || a || o();
          };
        }).call(this, typeof ma < "u" ? ma : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}], 37: [function(t, n, r) {
        var s = t("immediate");
        function o() {
        }
        var a = {}, l = ["REJECTED"], c = ["FULFILLED"], h = ["PENDING"];
        function f(g) {
          if (typeof g != "function") throw new TypeError("resolver must be a function");
          this.state = h, this.queue = [], this.outcome = void 0, g !== o && O(this, g);
        }
        function u(g, v, S) {
          this.promise = g, typeof v == "function" && (this.onFulfilled = v, this.callFulfilled = this.otherCallFulfilled), typeof S == "function" && (this.onRejected = S, this.callRejected = this.otherCallRejected);
        }
        function d(g, v, S) {
          s(function() {
            var w;
            try {
              w = v(S);
            } catch (x) {
              return a.reject(g, x);
            }
            w === g ? a.reject(g, new TypeError("Cannot resolve promise with itself")) : a.resolve(g, w);
          });
        }
        function p(g) {
          var v = g && g.then;
          if (g && (typeof g == "object" || typeof g == "function") && typeof v == "function") return function() {
            v.apply(g, arguments);
          };
        }
        function O(g, v) {
          var S = !1;
          function w(k) {
            S || (S = !0, a.reject(g, k));
          }
          function x(k) {
            S || (S = !0, a.resolve(g, k));
          }
          var P = m(function() {
            v(x, w);
          });
          P.status === "error" && w(P.value);
        }
        function m(g, v) {
          var S = {};
          try {
            S.value = g(v), S.status = "success";
          } catch (w) {
            S.status = "error", S.value = w;
          }
          return S;
        }
        (n.exports = f).prototype.finally = function(g) {
          if (typeof g != "function") return this;
          var v = this.constructor;
          return this.then(function(S) {
            return v.resolve(g()).then(function() {
              return S;
            });
          }, function(S) {
            return v.resolve(g()).then(function() {
              throw S;
            });
          });
        }, f.prototype.catch = function(g) {
          return this.then(null, g);
        }, f.prototype.then = function(g, v) {
          if (typeof g != "function" && this.state === c || typeof v != "function" && this.state === l) return this;
          var S = new this.constructor(o);
          return this.state !== h ? d(S, this.state === c ? g : v, this.outcome) : this.queue.push(new u(S, g, v)), S;
        }, u.prototype.callFulfilled = function(g) {
          a.resolve(this.promise, g);
        }, u.prototype.otherCallFulfilled = function(g) {
          d(this.promise, this.onFulfilled, g);
        }, u.prototype.callRejected = function(g) {
          a.reject(this.promise, g);
        }, u.prototype.otherCallRejected = function(g) {
          d(this.promise, this.onRejected, g);
        }, a.resolve = function(g, v) {
          var S = m(p, v);
          if (S.status === "error") return a.reject(g, S.value);
          var w = S.value;
          if (w) O(g, w);
          else {
            g.state = c, g.outcome = v;
            for (var x = -1, P = g.queue.length; ++x < P; ) g.queue[x].callFulfilled(v);
          }
          return g;
        }, a.reject = function(g, v) {
          g.state = l, g.outcome = v;
          for (var S = -1, w = g.queue.length; ++S < w; ) g.queue[S].callRejected(v);
          return g;
        }, f.resolve = function(g) {
          return g instanceof this ? g : a.resolve(new this(o), g);
        }, f.reject = function(g) {
          var v = new this(o);
          return a.reject(v, g);
        }, f.all = function(g) {
          var v = this;
          if (Object.prototype.toString.call(g) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var S = g.length, w = !1;
          if (!S) return this.resolve([]);
          for (var x = new Array(S), P = 0, k = -1, A = new this(o); ++k < S; ) C(g[k], k);
          return A;
          function C(Z, I) {
            v.resolve(Z).then(function(Q) {
              x[I] = Q, ++P !== S || w || (w = !0, a.resolve(A, x));
            }, function(Q) {
              w || (w = !0, a.reject(A, Q));
            });
          }
        }, f.race = function(g) {
          var v = this;
          if (Object.prototype.toString.call(g) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var S = g.length, w = !1;
          if (!S) return this.resolve([]);
          for (var x = -1, P = new this(o); ++x < S; ) k = g[x], v.resolve(k).then(function(A) {
            w || (w = !0, a.resolve(P, A));
          }, function(A) {
            w || (w = !0, a.reject(P, A));
          });
          var k;
          return P;
        };
      }, { immediate: 36 }], 38: [function(t, n, r) {
        var s = {};
        (0, t("./lib/utils/common").assign)(s, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), n.exports = s;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(t, n, r) {
        var s = t("./zlib/deflate"), o = t("./utils/common"), a = t("./utils/strings"), l = t("./zlib/messages"), c = t("./zlib/zstream"), h = Object.prototype.toString, f = 0, u = -1, d = 0, p = 8;
        function O(g) {
          if (!(this instanceof O)) return new O(g);
          this.options = o.assign({ level: u, method: p, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d, to: "" }, g || {});
          var v = this.options;
          v.raw && 0 < v.windowBits ? v.windowBits = -v.windowBits : v.gzip && 0 < v.windowBits && v.windowBits < 16 && (v.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
          var S = s.deflateInit2(this.strm, v.level, v.method, v.windowBits, v.memLevel, v.strategy);
          if (S !== f) throw new Error(l[S]);
          if (v.header && s.deflateSetHeader(this.strm, v.header), v.dictionary) {
            var w;
            if (w = typeof v.dictionary == "string" ? a.string2buf(v.dictionary) : h.call(v.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(v.dictionary) : v.dictionary, (S = s.deflateSetDictionary(this.strm, w)) !== f) throw new Error(l[S]);
            this._dict_set = !0;
          }
        }
        function m(g, v) {
          var S = new O(v);
          if (S.push(g, !0), S.err) throw S.msg || l[S.err];
          return S.result;
        }
        O.prototype.push = function(g, v) {
          var S, w, x = this.strm, P = this.options.chunkSize;
          if (this.ended) return !1;
          w = v === ~~v ? v : v === !0 ? 4 : 0, typeof g == "string" ? x.input = a.string2buf(g) : h.call(g) === "[object ArrayBuffer]" ? x.input = new Uint8Array(g) : x.input = g, x.next_in = 0, x.avail_in = x.input.length;
          do {
            if (x.avail_out === 0 && (x.output = new o.Buf8(P), x.next_out = 0, x.avail_out = P), (S = s.deflate(x, w)) !== 1 && S !== f) return this.onEnd(S), !(this.ended = !0);
            x.avail_out !== 0 && (x.avail_in !== 0 || w !== 4 && w !== 2) || (this.options.to === "string" ? this.onData(a.buf2binstring(o.shrinkBuf(x.output, x.next_out))) : this.onData(o.shrinkBuf(x.output, x.next_out)));
          } while ((0 < x.avail_in || x.avail_out === 0) && S !== 1);
          return w === 4 ? (S = s.deflateEnd(this.strm), this.onEnd(S), this.ended = !0, S === f) : w !== 2 || (this.onEnd(f), !(x.avail_out = 0));
        }, O.prototype.onData = function(g) {
          this.chunks.push(g);
        }, O.prototype.onEnd = function(g) {
          g === f && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = g, this.msg = this.strm.msg;
        }, r.Deflate = O, r.deflate = m, r.deflateRaw = function(g, v) {
          return (v = v || {}).raw = !0, m(g, v);
        }, r.gzip = function(g, v) {
          return (v = v || {}).gzip = !0, m(g, v);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(t, n, r) {
        var s = t("./zlib/inflate"), o = t("./utils/common"), a = t("./utils/strings"), l = t("./zlib/constants"), c = t("./zlib/messages"), h = t("./zlib/zstream"), f = t("./zlib/gzheader"), u = Object.prototype.toString;
        function d(O) {
          if (!(this instanceof d)) return new d(O);
          this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, O || {});
          var m = this.options;
          m.raw && 0 <= m.windowBits && m.windowBits < 16 && (m.windowBits = -m.windowBits, m.windowBits === 0 && (m.windowBits = -15)), !(0 <= m.windowBits && m.windowBits < 16) || O && O.windowBits || (m.windowBits += 32), 15 < m.windowBits && m.windowBits < 48 && (15 & m.windowBits) == 0 && (m.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
          var g = s.inflateInit2(this.strm, m.windowBits);
          if (g !== l.Z_OK) throw new Error(c[g]);
          this.header = new f(), s.inflateGetHeader(this.strm, this.header);
        }
        function p(O, m) {
          var g = new d(m);
          if (g.push(O, !0), g.err) throw g.msg || c[g.err];
          return g.result;
        }
        d.prototype.push = function(O, m) {
          var g, v, S, w, x, P, k = this.strm, A = this.options.chunkSize, C = this.options.dictionary, Z = !1;
          if (this.ended) return !1;
          v = m === ~~m ? m : m === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof O == "string" ? k.input = a.binstring2buf(O) : u.call(O) === "[object ArrayBuffer]" ? k.input = new Uint8Array(O) : k.input = O, k.next_in = 0, k.avail_in = k.input.length;
          do {
            if (k.avail_out === 0 && (k.output = new o.Buf8(A), k.next_out = 0, k.avail_out = A), (g = s.inflate(k, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && C && (P = typeof C == "string" ? a.string2buf(C) : u.call(C) === "[object ArrayBuffer]" ? new Uint8Array(C) : C, g = s.inflateSetDictionary(this.strm, P)), g === l.Z_BUF_ERROR && Z === !0 && (g = l.Z_OK, Z = !1), g !== l.Z_STREAM_END && g !== l.Z_OK) return this.onEnd(g), !(this.ended = !0);
            k.next_out && (k.avail_out !== 0 && g !== l.Z_STREAM_END && (k.avail_in !== 0 || v !== l.Z_FINISH && v !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (S = a.utf8border(k.output, k.next_out), w = k.next_out - S, x = a.buf2string(k.output, S), k.next_out = w, k.avail_out = A - w, w && o.arraySet(k.output, k.output, S, w, 0), this.onData(x)) : this.onData(o.shrinkBuf(k.output, k.next_out)))), k.avail_in === 0 && k.avail_out === 0 && (Z = !0);
          } while ((0 < k.avail_in || k.avail_out === 0) && g !== l.Z_STREAM_END);
          return g === l.Z_STREAM_END && (v = l.Z_FINISH), v === l.Z_FINISH ? (g = s.inflateEnd(this.strm), this.onEnd(g), this.ended = !0, g === l.Z_OK) : v !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(k.avail_out = 0));
        }, d.prototype.onData = function(O) {
          this.chunks.push(O);
        }, d.prototype.onEnd = function(O) {
          O === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = O, this.msg = this.strm.msg;
        }, r.Inflate = d, r.inflate = p, r.inflateRaw = function(O, m) {
          return (m = m || {}).raw = !0, p(O, m);
        }, r.ungzip = p;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(t, n, r) {
        var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
        r.assign = function(l) {
          for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
            var h = c.shift();
            if (h) {
              if (typeof h != "object") throw new TypeError(h + "must be non-object");
              for (var f in h) h.hasOwnProperty(f) && (l[f] = h[f]);
            }
          }
          return l;
        }, r.shrinkBuf = function(l, c) {
          return l.length === c ? l : l.subarray ? l.subarray(0, c) : (l.length = c, l);
        };
        var o = { arraySet: function(l, c, h, f, u) {
          if (c.subarray && l.subarray) l.set(c.subarray(h, h + f), u);
          else for (var d = 0; d < f; d++) l[u + d] = c[h + d];
        }, flattenChunks: function(l) {
          var c, h, f, u, d, p;
          for (c = f = 0, h = l.length; c < h; c++) f += l[c].length;
          for (p = new Uint8Array(f), c = u = 0, h = l.length; c < h; c++) d = l[c], p.set(d, u), u += d.length;
          return p;
        } }, a = { arraySet: function(l, c, h, f, u) {
          for (var d = 0; d < f; d++) l[u + d] = c[h + d];
        }, flattenChunks: function(l) {
          return [].concat.apply([], l);
        } };
        r.setTyped = function(l) {
          l ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, o)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, a));
        }, r.setTyped(s);
      }, {}], 42: [function(t, n, r) {
        var s = t("./common"), o = !0, a = !0;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch {
          o = !1;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch {
          a = !1;
        }
        for (var l = new s.Buf8(256), c = 0; c < 256; c++) l[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
        function h(f, u) {
          if (u < 65537 && (f.subarray && a || !f.subarray && o)) return String.fromCharCode.apply(null, s.shrinkBuf(f, u));
          for (var d = "", p = 0; p < u; p++) d += String.fromCharCode(f[p]);
          return d;
        }
        l[254] = l[254] = 1, r.string2buf = function(f) {
          var u, d, p, O, m, g = f.length, v = 0;
          for (O = 0; O < g; O++) (64512 & (d = f.charCodeAt(O))) == 55296 && O + 1 < g && (64512 & (p = f.charCodeAt(O + 1))) == 56320 && (d = 65536 + (d - 55296 << 10) + (p - 56320), O++), v += d < 128 ? 1 : d < 2048 ? 2 : d < 65536 ? 3 : 4;
          for (u = new s.Buf8(v), O = m = 0; m < v; O++) (64512 & (d = f.charCodeAt(O))) == 55296 && O + 1 < g && (64512 & (p = f.charCodeAt(O + 1))) == 56320 && (d = 65536 + (d - 55296 << 10) + (p - 56320), O++), d < 128 ? u[m++] = d : (d < 2048 ? u[m++] = 192 | d >>> 6 : (d < 65536 ? u[m++] = 224 | d >>> 12 : (u[m++] = 240 | d >>> 18, u[m++] = 128 | d >>> 12 & 63), u[m++] = 128 | d >>> 6 & 63), u[m++] = 128 | 63 & d);
          return u;
        }, r.buf2binstring = function(f) {
          return h(f, f.length);
        }, r.binstring2buf = function(f) {
          for (var u = new s.Buf8(f.length), d = 0, p = u.length; d < p; d++) u[d] = f.charCodeAt(d);
          return u;
        }, r.buf2string = function(f, u) {
          var d, p, O, m, g = u || f.length, v = new Array(2 * g);
          for (d = p = 0; d < g; ) if ((O = f[d++]) < 128) v[p++] = O;
          else if (4 < (m = l[O])) v[p++] = 65533, d += m - 1;
          else {
            for (O &= m === 2 ? 31 : m === 3 ? 15 : 7; 1 < m && d < g; ) O = O << 6 | 63 & f[d++], m--;
            1 < m ? v[p++] = 65533 : O < 65536 ? v[p++] = O : (O -= 65536, v[p++] = 55296 | O >> 10 & 1023, v[p++] = 56320 | 1023 & O);
          }
          return h(v, p);
        }, r.utf8border = function(f, u) {
          var d;
          for ((u = u || f.length) > f.length && (u = f.length), d = u - 1; 0 <= d && (192 & f[d]) == 128; ) d--;
          return d < 0 || d === 0 ? u : d + l[f[d]] > u ? d : u;
        };
      }, { "./common": 41 }], 43: [function(t, n, r) {
        n.exports = function(s, o, a, l) {
          for (var c = 65535 & s | 0, h = s >>> 16 & 65535 | 0, f = 0; a !== 0; ) {
            for (a -= f = 2e3 < a ? 2e3 : a; h = h + (c = c + o[l++] | 0) | 0, --f; ) ;
            c %= 65521, h %= 65521;
          }
          return c | h << 16 | 0;
        };
      }, {}], 44: [function(t, n, r) {
        n.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(t, n, r) {
        var s = (function() {
          for (var o, a = [], l = 0; l < 256; l++) {
            o = l;
            for (var c = 0; c < 8; c++) o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
            a[l] = o;
          }
          return a;
        })();
        n.exports = function(o, a, l, c) {
          var h = s, f = c + l;
          o ^= -1;
          for (var u = c; u < f; u++) o = o >>> 8 ^ h[255 & (o ^ a[u])];
          return -1 ^ o;
        };
      }, {}], 46: [function(t, n, r) {
        var s, o = t("../utils/common"), a = t("./trees"), l = t("./adler32"), c = t("./crc32"), h = t("./messages"), f = 0, u = 4, d = 0, p = -2, O = -1, m = 4, g = 2, v = 8, S = 9, w = 286, x = 30, P = 19, k = 2 * w + 1, A = 15, C = 3, Z = 258, I = Z + C + 1, Q = 42, E = 113, y = 1, L = 2, se = 3, V = 4;
        function fe(b, N) {
          return b.msg = h[N], N;
        }
        function W(b) {
          return (b << 1) - (4 < b ? 9 : 0);
        }
        function ce(b) {
          for (var N = b.length; 0 <= --N; ) b[N] = 0;
        }
        function z(b) {
          var N = b.state, Y = N.pending;
          Y > b.avail_out && (Y = b.avail_out), Y !== 0 && (o.arraySet(b.output, N.pending_buf, N.pending_out, Y, b.next_out), b.next_out += Y, N.pending_out += Y, b.total_out += Y, b.avail_out -= Y, N.pending -= Y, N.pending === 0 && (N.pending_out = 0));
        }
        function D(b, N) {
          a._tr_flush_block(b, 0 <= b.block_start ? b.block_start : -1, b.strstart - b.block_start, N), b.block_start = b.strstart, z(b.strm);
        }
        function J(b, N) {
          b.pending_buf[b.pending++] = N;
        }
        function ie(b, N) {
          b.pending_buf[b.pending++] = N >>> 8 & 255, b.pending_buf[b.pending++] = 255 & N;
        }
        function U(b, N) {
          var Y, $, _ = b.max_chain_length, M = b.strstart, j = b.prev_length, B = b.nice_match, X = b.strstart > b.w_size - I ? b.strstart - (b.w_size - I) : 0, G = b.window, ee = b.w_mask, F = b.prev, oe = b.strstart + Z, me = G[M + j - 1], Oe = G[M + j];
          b.prev_length >= b.good_match && (_ >>= 2), B > b.lookahead && (B = b.lookahead);
          do
            if (G[(Y = N) + j] === Oe && G[Y + j - 1] === me && G[Y] === G[M] && G[++Y] === G[M + 1]) {
              M += 2, Y++;
              do
                ;
              while (G[++M] === G[++Y] && G[++M] === G[++Y] && G[++M] === G[++Y] && G[++M] === G[++Y] && G[++M] === G[++Y] && G[++M] === G[++Y] && G[++M] === G[++Y] && G[++M] === G[++Y] && M < oe);
              if ($ = Z - (oe - M), M = oe - Z, j < $) {
                if (b.match_start = N, B <= (j = $)) break;
                me = G[M + j - 1], Oe = G[M + j];
              }
            }
          while ((N = F[N & ee]) > X && --_ != 0);
          return j <= b.lookahead ? j : b.lookahead;
        }
        function Qe(b) {
          var N, Y, $, _, M, j, B, X, G, ee, F = b.w_size;
          do {
            if (_ = b.window_size - b.lookahead - b.strstart, b.strstart >= F + (F - I)) {
              for (o.arraySet(b.window, b.window, F, F, 0), b.match_start -= F, b.strstart -= F, b.block_start -= F, N = Y = b.hash_size; $ = b.head[--N], b.head[N] = F <= $ ? $ - F : 0, --Y; ) ;
              for (N = Y = F; $ = b.prev[--N], b.prev[N] = F <= $ ? $ - F : 0, --Y; ) ;
              _ += F;
            }
            if (b.strm.avail_in === 0) break;
            if (j = b.strm, B = b.window, X = b.strstart + b.lookahead, G = _, ee = void 0, ee = j.avail_in, G < ee && (ee = G), Y = ee === 0 ? 0 : (j.avail_in -= ee, o.arraySet(B, j.input, j.next_in, ee, X), j.state.wrap === 1 ? j.adler = l(j.adler, B, ee, X) : j.state.wrap === 2 && (j.adler = c(j.adler, B, ee, X)), j.next_in += ee, j.total_in += ee, ee), b.lookahead += Y, b.lookahead + b.insert >= C) for (M = b.strstart - b.insert, b.ins_h = b.window[M], b.ins_h = (b.ins_h << b.hash_shift ^ b.window[M + 1]) & b.hash_mask; b.insert && (b.ins_h = (b.ins_h << b.hash_shift ^ b.window[M + C - 1]) & b.hash_mask, b.prev[M & b.w_mask] = b.head[b.ins_h], b.head[b.ins_h] = M, M++, b.insert--, !(b.lookahead + b.insert < C)); ) ;
          } while (b.lookahead < I && b.strm.avail_in !== 0);
        }
        function Ie(b, N) {
          for (var Y, $; ; ) {
            if (b.lookahead < I) {
              if (Qe(b), b.lookahead < I && N === f) return y;
              if (b.lookahead === 0) break;
            }
            if (Y = 0, b.lookahead >= C && (b.ins_h = (b.ins_h << b.hash_shift ^ b.window[b.strstart + C - 1]) & b.hash_mask, Y = b.prev[b.strstart & b.w_mask] = b.head[b.ins_h], b.head[b.ins_h] = b.strstart), Y !== 0 && b.strstart - Y <= b.w_size - I && (b.match_length = U(b, Y)), b.match_length >= C) if ($ = a._tr_tally(b, b.strstart - b.match_start, b.match_length - C), b.lookahead -= b.match_length, b.match_length <= b.max_lazy_match && b.lookahead >= C) {
              for (b.match_length--; b.strstart++, b.ins_h = (b.ins_h << b.hash_shift ^ b.window[b.strstart + C - 1]) & b.hash_mask, Y = b.prev[b.strstart & b.w_mask] = b.head[b.ins_h], b.head[b.ins_h] = b.strstart, --b.match_length != 0; ) ;
              b.strstart++;
            } else b.strstart += b.match_length, b.match_length = 0, b.ins_h = b.window[b.strstart], b.ins_h = (b.ins_h << b.hash_shift ^ b.window[b.strstart + 1]) & b.hash_mask;
            else $ = a._tr_tally(b, 0, b.window[b.strstart]), b.lookahead--, b.strstart++;
            if ($ && (D(b, !1), b.strm.avail_out === 0)) return y;
          }
          return b.insert = b.strstart < C - 1 ? b.strstart : C - 1, N === u ? (D(b, !0), b.strm.avail_out === 0 ? se : V) : b.last_lit && (D(b, !1), b.strm.avail_out === 0) ? y : L;
        }
        function be(b, N) {
          for (var Y, $, _; ; ) {
            if (b.lookahead < I) {
              if (Qe(b), b.lookahead < I && N === f) return y;
              if (b.lookahead === 0) break;
            }
            if (Y = 0, b.lookahead >= C && (b.ins_h = (b.ins_h << b.hash_shift ^ b.window[b.strstart + C - 1]) & b.hash_mask, Y = b.prev[b.strstart & b.w_mask] = b.head[b.ins_h], b.head[b.ins_h] = b.strstart), b.prev_length = b.match_length, b.prev_match = b.match_start, b.match_length = C - 1, Y !== 0 && b.prev_length < b.max_lazy_match && b.strstart - Y <= b.w_size - I && (b.match_length = U(b, Y), b.match_length <= 5 && (b.strategy === 1 || b.match_length === C && 4096 < b.strstart - b.match_start) && (b.match_length = C - 1)), b.prev_length >= C && b.match_length <= b.prev_length) {
              for (_ = b.strstart + b.lookahead - C, $ = a._tr_tally(b, b.strstart - 1 - b.prev_match, b.prev_length - C), b.lookahead -= b.prev_length - 1, b.prev_length -= 2; ++b.strstart <= _ && (b.ins_h = (b.ins_h << b.hash_shift ^ b.window[b.strstart + C - 1]) & b.hash_mask, Y = b.prev[b.strstart & b.w_mask] = b.head[b.ins_h], b.head[b.ins_h] = b.strstart), --b.prev_length != 0; ) ;
              if (b.match_available = 0, b.match_length = C - 1, b.strstart++, $ && (D(b, !1), b.strm.avail_out === 0)) return y;
            } else if (b.match_available) {
              if (($ = a._tr_tally(b, 0, b.window[b.strstart - 1])) && D(b, !1), b.strstart++, b.lookahead--, b.strm.avail_out === 0) return y;
            } else b.match_available = 1, b.strstart++, b.lookahead--;
          }
          return b.match_available && ($ = a._tr_tally(b, 0, b.window[b.strstart - 1]), b.match_available = 0), b.insert = b.strstart < C - 1 ? b.strstart : C - 1, N === u ? (D(b, !0), b.strm.avail_out === 0 ? se : V) : b.last_lit && (D(b, !1), b.strm.avail_out === 0) ? y : L;
        }
        function _e(b, N, Y, $, _) {
          this.good_length = b, this.max_lazy = N, this.nice_length = Y, this.max_chain = $, this.func = _;
        }
        function Ue() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * k), this.dyn_dtree = new o.Buf16(2 * (2 * x + 1)), this.bl_tree = new o.Buf16(2 * (2 * P + 1)), ce(this.dyn_ltree), ce(this.dyn_dtree), ce(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(A + 1), this.heap = new o.Buf16(2 * w + 1), ce(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * w + 1), ce(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function Be(b) {
          var N;
          return b && b.state ? (b.total_in = b.total_out = 0, b.data_type = g, (N = b.state).pending = 0, N.pending_out = 0, N.wrap < 0 && (N.wrap = -N.wrap), N.status = N.wrap ? Q : E, b.adler = N.wrap === 2 ? 0 : 1, N.last_flush = f, a._tr_init(N), d) : fe(b, p);
        }
        function $t(b) {
          var N = Be(b);
          return N === d && (function(Y) {
            Y.window_size = 2 * Y.w_size, ce(Y.head), Y.max_lazy_match = s[Y.level].max_lazy, Y.good_match = s[Y.level].good_length, Y.nice_match = s[Y.level].nice_length, Y.max_chain_length = s[Y.level].max_chain, Y.strstart = 0, Y.block_start = 0, Y.lookahead = 0, Y.insert = 0, Y.match_length = Y.prev_length = C - 1, Y.match_available = 0, Y.ins_h = 0;
          })(b.state), N;
        }
        function Je(b, N, Y, $, _, M) {
          if (!b) return p;
          var j = 1;
          if (N === O && (N = 6), $ < 0 ? (j = 0, $ = -$) : 15 < $ && (j = 2, $ -= 16), _ < 1 || S < _ || Y !== v || $ < 8 || 15 < $ || N < 0 || 9 < N || M < 0 || m < M) return fe(b, p);
          $ === 8 && ($ = 9);
          var B = new Ue();
          return (b.state = B).strm = b, B.wrap = j, B.gzhead = null, B.w_bits = $, B.w_size = 1 << B.w_bits, B.w_mask = B.w_size - 1, B.hash_bits = _ + 7, B.hash_size = 1 << B.hash_bits, B.hash_mask = B.hash_size - 1, B.hash_shift = ~~((B.hash_bits + C - 1) / C), B.window = new o.Buf8(2 * B.w_size), B.head = new o.Buf16(B.hash_size), B.prev = new o.Buf16(B.w_size), B.lit_bufsize = 1 << _ + 6, B.pending_buf_size = 4 * B.lit_bufsize, B.pending_buf = new o.Buf8(B.pending_buf_size), B.d_buf = 1 * B.lit_bufsize, B.l_buf = 3 * B.lit_bufsize, B.level = N, B.strategy = M, B.method = Y, $t(b);
        }
        s = [new _e(0, 0, 0, 0, function(b, N) {
          var Y = 65535;
          for (Y > b.pending_buf_size - 5 && (Y = b.pending_buf_size - 5); ; ) {
            if (b.lookahead <= 1) {
              if (Qe(b), b.lookahead === 0 && N === f) return y;
              if (b.lookahead === 0) break;
            }
            b.strstart += b.lookahead, b.lookahead = 0;
            var $ = b.block_start + Y;
            if ((b.strstart === 0 || b.strstart >= $) && (b.lookahead = b.strstart - $, b.strstart = $, D(b, !1), b.strm.avail_out === 0) || b.strstart - b.block_start >= b.w_size - I && (D(b, !1), b.strm.avail_out === 0)) return y;
          }
          return b.insert = 0, N === u ? (D(b, !0), b.strm.avail_out === 0 ? se : V) : (b.strstart > b.block_start && (D(b, !1), b.strm.avail_out), y);
        }), new _e(4, 4, 8, 4, Ie), new _e(4, 5, 16, 8, Ie), new _e(4, 6, 32, 32, Ie), new _e(4, 4, 16, 16, be), new _e(8, 16, 32, 32, be), new _e(8, 16, 128, 128, be), new _e(8, 32, 128, 256, be), new _e(32, 128, 258, 1024, be), new _e(32, 258, 258, 4096, be)], r.deflateInit = function(b, N) {
          return Je(b, N, v, 15, 8, 0);
        }, r.deflateInit2 = Je, r.deflateReset = $t, r.deflateResetKeep = Be, r.deflateSetHeader = function(b, N) {
          return b && b.state ? b.state.wrap !== 2 ? p : (b.state.gzhead = N, d) : p;
        }, r.deflate = function(b, N) {
          var Y, $, _, M;
          if (!b || !b.state || 5 < N || N < 0) return b ? fe(b, p) : p;
          if ($ = b.state, !b.output || !b.input && b.avail_in !== 0 || $.status === 666 && N !== u) return fe(b, b.avail_out === 0 ? -5 : p);
          if ($.strm = b, Y = $.last_flush, $.last_flush = N, $.status === Q) if ($.wrap === 2) b.adler = 0, J($, 31), J($, 139), J($, 8), $.gzhead ? (J($, ($.gzhead.text ? 1 : 0) + ($.gzhead.hcrc ? 2 : 0) + ($.gzhead.extra ? 4 : 0) + ($.gzhead.name ? 8 : 0) + ($.gzhead.comment ? 16 : 0)), J($, 255 & $.gzhead.time), J($, $.gzhead.time >> 8 & 255), J($, $.gzhead.time >> 16 & 255), J($, $.gzhead.time >> 24 & 255), J($, $.level === 9 ? 2 : 2 <= $.strategy || $.level < 2 ? 4 : 0), J($, 255 & $.gzhead.os), $.gzhead.extra && $.gzhead.extra.length && (J($, 255 & $.gzhead.extra.length), J($, $.gzhead.extra.length >> 8 & 255)), $.gzhead.hcrc && (b.adler = c(b.adler, $.pending_buf, $.pending, 0)), $.gzindex = 0, $.status = 69) : (J($, 0), J($, 0), J($, 0), J($, 0), J($, 0), J($, $.level === 9 ? 2 : 2 <= $.strategy || $.level < 2 ? 4 : 0), J($, 3), $.status = E);
          else {
            var j = v + ($.w_bits - 8 << 4) << 8;
            j |= (2 <= $.strategy || $.level < 2 ? 0 : $.level < 6 ? 1 : $.level === 6 ? 2 : 3) << 6, $.strstart !== 0 && (j |= 32), j += 31 - j % 31, $.status = E, ie($, j), $.strstart !== 0 && (ie($, b.adler >>> 16), ie($, 65535 & b.adler)), b.adler = 1;
          }
          if ($.status === 69) if ($.gzhead.extra) {
            for (_ = $.pending; $.gzindex < (65535 & $.gzhead.extra.length) && ($.pending !== $.pending_buf_size || ($.gzhead.hcrc && $.pending > _ && (b.adler = c(b.adler, $.pending_buf, $.pending - _, _)), z(b), _ = $.pending, $.pending !== $.pending_buf_size)); ) J($, 255 & $.gzhead.extra[$.gzindex]), $.gzindex++;
            $.gzhead.hcrc && $.pending > _ && (b.adler = c(b.adler, $.pending_buf, $.pending - _, _)), $.gzindex === $.gzhead.extra.length && ($.gzindex = 0, $.status = 73);
          } else $.status = 73;
          if ($.status === 73) if ($.gzhead.name) {
            _ = $.pending;
            do {
              if ($.pending === $.pending_buf_size && ($.gzhead.hcrc && $.pending > _ && (b.adler = c(b.adler, $.pending_buf, $.pending - _, _)), z(b), _ = $.pending, $.pending === $.pending_buf_size)) {
                M = 1;
                break;
              }
              M = $.gzindex < $.gzhead.name.length ? 255 & $.gzhead.name.charCodeAt($.gzindex++) : 0, J($, M);
            } while (M !== 0);
            $.gzhead.hcrc && $.pending > _ && (b.adler = c(b.adler, $.pending_buf, $.pending - _, _)), M === 0 && ($.gzindex = 0, $.status = 91);
          } else $.status = 91;
          if ($.status === 91) if ($.gzhead.comment) {
            _ = $.pending;
            do {
              if ($.pending === $.pending_buf_size && ($.gzhead.hcrc && $.pending > _ && (b.adler = c(b.adler, $.pending_buf, $.pending - _, _)), z(b), _ = $.pending, $.pending === $.pending_buf_size)) {
                M = 1;
                break;
              }
              M = $.gzindex < $.gzhead.comment.length ? 255 & $.gzhead.comment.charCodeAt($.gzindex++) : 0, J($, M);
            } while (M !== 0);
            $.gzhead.hcrc && $.pending > _ && (b.adler = c(b.adler, $.pending_buf, $.pending - _, _)), M === 0 && ($.status = 103);
          } else $.status = 103;
          if ($.status === 103 && ($.gzhead.hcrc ? ($.pending + 2 > $.pending_buf_size && z(b), $.pending + 2 <= $.pending_buf_size && (J($, 255 & b.adler), J($, b.adler >> 8 & 255), b.adler = 0, $.status = E)) : $.status = E), $.pending !== 0) {
            if (z(b), b.avail_out === 0) return $.last_flush = -1, d;
          } else if (b.avail_in === 0 && W(N) <= W(Y) && N !== u) return fe(b, -5);
          if ($.status === 666 && b.avail_in !== 0) return fe(b, -5);
          if (b.avail_in !== 0 || $.lookahead !== 0 || N !== f && $.status !== 666) {
            var B = $.strategy === 2 ? (function(X, G) {
              for (var ee; ; ) {
                if (X.lookahead === 0 && (Qe(X), X.lookahead === 0)) {
                  if (G === f) return y;
                  break;
                }
                if (X.match_length = 0, ee = a._tr_tally(X, 0, X.window[X.strstart]), X.lookahead--, X.strstart++, ee && (D(X, !1), X.strm.avail_out === 0)) return y;
              }
              return X.insert = 0, G === u ? (D(X, !0), X.strm.avail_out === 0 ? se : V) : X.last_lit && (D(X, !1), X.strm.avail_out === 0) ? y : L;
            })($, N) : $.strategy === 3 ? (function(X, G) {
              for (var ee, F, oe, me, Oe = X.window; ; ) {
                if (X.lookahead <= Z) {
                  if (Qe(X), X.lookahead <= Z && G === f) return y;
                  if (X.lookahead === 0) break;
                }
                if (X.match_length = 0, X.lookahead >= C && 0 < X.strstart && (F = Oe[oe = X.strstart - 1]) === Oe[++oe] && F === Oe[++oe] && F === Oe[++oe]) {
                  me = X.strstart + Z;
                  do
                    ;
                  while (F === Oe[++oe] && F === Oe[++oe] && F === Oe[++oe] && F === Oe[++oe] && F === Oe[++oe] && F === Oe[++oe] && F === Oe[++oe] && F === Oe[++oe] && oe < me);
                  X.match_length = Z - (me - oe), X.match_length > X.lookahead && (X.match_length = X.lookahead);
                }
                if (X.match_length >= C ? (ee = a._tr_tally(X, 1, X.match_length - C), X.lookahead -= X.match_length, X.strstart += X.match_length, X.match_length = 0) : (ee = a._tr_tally(X, 0, X.window[X.strstart]), X.lookahead--, X.strstart++), ee && (D(X, !1), X.strm.avail_out === 0)) return y;
              }
              return X.insert = 0, G === u ? (D(X, !0), X.strm.avail_out === 0 ? se : V) : X.last_lit && (D(X, !1), X.strm.avail_out === 0) ? y : L;
            })($, N) : s[$.level].func($, N);
            if (B !== se && B !== V || ($.status = 666), B === y || B === se) return b.avail_out === 0 && ($.last_flush = -1), d;
            if (B === L && (N === 1 ? a._tr_align($) : N !== 5 && (a._tr_stored_block($, 0, 0, !1), N === 3 && (ce($.head), $.lookahead === 0 && ($.strstart = 0, $.block_start = 0, $.insert = 0))), z(b), b.avail_out === 0)) return $.last_flush = -1, d;
          }
          return N !== u ? d : $.wrap <= 0 ? 1 : ($.wrap === 2 ? (J($, 255 & b.adler), J($, b.adler >> 8 & 255), J($, b.adler >> 16 & 255), J($, b.adler >> 24 & 255), J($, 255 & b.total_in), J($, b.total_in >> 8 & 255), J($, b.total_in >> 16 & 255), J($, b.total_in >> 24 & 255)) : (ie($, b.adler >>> 16), ie($, 65535 & b.adler)), z(b), 0 < $.wrap && ($.wrap = -$.wrap), $.pending !== 0 ? d : 1);
        }, r.deflateEnd = function(b) {
          var N;
          return b && b.state ? (N = b.state.status) !== Q && N !== 69 && N !== 73 && N !== 91 && N !== 103 && N !== E && N !== 666 ? fe(b, p) : (b.state = null, N === E ? fe(b, -3) : d) : p;
        }, r.deflateSetDictionary = function(b, N) {
          var Y, $, _, M, j, B, X, G, ee = N.length;
          if (!b || !b.state || (M = (Y = b.state).wrap) === 2 || M === 1 && Y.status !== Q || Y.lookahead) return p;
          for (M === 1 && (b.adler = l(b.adler, N, ee, 0)), Y.wrap = 0, ee >= Y.w_size && (M === 0 && (ce(Y.head), Y.strstart = 0, Y.block_start = 0, Y.insert = 0), G = new o.Buf8(Y.w_size), o.arraySet(G, N, ee - Y.w_size, Y.w_size, 0), N = G, ee = Y.w_size), j = b.avail_in, B = b.next_in, X = b.input, b.avail_in = ee, b.next_in = 0, b.input = N, Qe(Y); Y.lookahead >= C; ) {
            for ($ = Y.strstart, _ = Y.lookahead - (C - 1); Y.ins_h = (Y.ins_h << Y.hash_shift ^ Y.window[$ + C - 1]) & Y.hash_mask, Y.prev[$ & Y.w_mask] = Y.head[Y.ins_h], Y.head[Y.ins_h] = $, $++, --_; ) ;
            Y.strstart = $, Y.lookahead = C - 1, Qe(Y);
          }
          return Y.strstart += Y.lookahead, Y.block_start = Y.strstart, Y.insert = Y.lookahead, Y.lookahead = 0, Y.match_length = Y.prev_length = C - 1, Y.match_available = 0, b.next_in = B, b.input = X, b.avail_in = j, Y.wrap = M, d;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(t, n, r) {
        n.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
        };
      }, {}], 48: [function(t, n, r) {
        n.exports = function(s, o) {
          var a, l, c, h, f, u, d, p, O, m, g, v, S, w, x, P, k, A, C, Z, I, Q, E, y, L;
          a = s.state, l = s.next_in, y = s.input, c = l + (s.avail_in - 5), h = s.next_out, L = s.output, f = h - (o - s.avail_out), u = h + (s.avail_out - 257), d = a.dmax, p = a.wsize, O = a.whave, m = a.wnext, g = a.window, v = a.hold, S = a.bits, w = a.lencode, x = a.distcode, P = (1 << a.lenbits) - 1, k = (1 << a.distbits) - 1;
          e: do {
            S < 15 && (v += y[l++] << S, S += 8, v += y[l++] << S, S += 8), A = w[v & P];
            t: for (; ; ) {
              if (v >>>= C = A >>> 24, S -= C, (C = A >>> 16 & 255) === 0) L[h++] = 65535 & A;
              else {
                if (!(16 & C)) {
                  if ((64 & C) == 0) {
                    A = w[(65535 & A) + (v & (1 << C) - 1)];
                    continue t;
                  }
                  if (32 & C) {
                    a.mode = 12;
                    break e;
                  }
                  s.msg = "invalid literal/length code", a.mode = 30;
                  break e;
                }
                Z = 65535 & A, (C &= 15) && (S < C && (v += y[l++] << S, S += 8), Z += v & (1 << C) - 1, v >>>= C, S -= C), S < 15 && (v += y[l++] << S, S += 8, v += y[l++] << S, S += 8), A = x[v & k];
                i: for (; ; ) {
                  if (v >>>= C = A >>> 24, S -= C, !(16 & (C = A >>> 16 & 255))) {
                    if ((64 & C) == 0) {
                      A = x[(65535 & A) + (v & (1 << C) - 1)];
                      continue i;
                    }
                    s.msg = "invalid distance code", a.mode = 30;
                    break e;
                  }
                  if (I = 65535 & A, S < (C &= 15) && (v += y[l++] << S, (S += 8) < C && (v += y[l++] << S, S += 8)), d < (I += v & (1 << C) - 1)) {
                    s.msg = "invalid distance too far back", a.mode = 30;
                    break e;
                  }
                  if (v >>>= C, S -= C, (C = h - f) < I) {
                    if (O < (C = I - C) && a.sane) {
                      s.msg = "invalid distance too far back", a.mode = 30;
                      break e;
                    }
                    if (E = g, (Q = 0) === m) {
                      if (Q += p - C, C < Z) {
                        for (Z -= C; L[h++] = g[Q++], --C; ) ;
                        Q = h - I, E = L;
                      }
                    } else if (m < C) {
                      if (Q += p + m - C, (C -= m) < Z) {
                        for (Z -= C; L[h++] = g[Q++], --C; ) ;
                        if (Q = 0, m < Z) {
                          for (Z -= C = m; L[h++] = g[Q++], --C; ) ;
                          Q = h - I, E = L;
                        }
                      }
                    } else if (Q += m - C, C < Z) {
                      for (Z -= C; L[h++] = g[Q++], --C; ) ;
                      Q = h - I, E = L;
                    }
                    for (; 2 < Z; ) L[h++] = E[Q++], L[h++] = E[Q++], L[h++] = E[Q++], Z -= 3;
                    Z && (L[h++] = E[Q++], 1 < Z && (L[h++] = E[Q++]));
                  } else {
                    for (Q = h - I; L[h++] = L[Q++], L[h++] = L[Q++], L[h++] = L[Q++], 2 < (Z -= 3); ) ;
                    Z && (L[h++] = L[Q++], 1 < Z && (L[h++] = L[Q++]));
                  }
                  break;
                }
              }
              break;
            }
          } while (l < c && h < u);
          l -= Z = S >> 3, v &= (1 << (S -= Z << 3)) - 1, s.next_in = l, s.next_out = h, s.avail_in = l < c ? c - l + 5 : 5 - (l - c), s.avail_out = h < u ? u - h + 257 : 257 - (h - u), a.hold = v, a.bits = S;
        };
      }, {}], 49: [function(t, n, r) {
        var s = t("../utils/common"), o = t("./adler32"), a = t("./crc32"), l = t("./inffast"), c = t("./inftrees"), h = 1, f = 2, u = 0, d = -2, p = 1, O = 852, m = 592;
        function g(Q) {
          return (Q >>> 24 & 255) + (Q >>> 8 & 65280) + ((65280 & Q) << 8) + ((255 & Q) << 24);
        }
        function v() {
          this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new s.Buf16(320), this.work = new s.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function S(Q) {
          var E;
          return Q && Q.state ? (E = Q.state, Q.total_in = Q.total_out = E.total = 0, Q.msg = "", E.wrap && (Q.adler = 1 & E.wrap), E.mode = p, E.last = 0, E.havedict = 0, E.dmax = 32768, E.head = null, E.hold = 0, E.bits = 0, E.lencode = E.lendyn = new s.Buf32(O), E.distcode = E.distdyn = new s.Buf32(m), E.sane = 1, E.back = -1, u) : d;
        }
        function w(Q) {
          var E;
          return Q && Q.state ? ((E = Q.state).wsize = 0, E.whave = 0, E.wnext = 0, S(Q)) : d;
        }
        function x(Q, E) {
          var y, L;
          return Q && Q.state ? (L = Q.state, E < 0 ? (y = 0, E = -E) : (y = 1 + (E >> 4), E < 48 && (E &= 15)), E && (E < 8 || 15 < E) ? d : (L.window !== null && L.wbits !== E && (L.window = null), L.wrap = y, L.wbits = E, w(Q))) : d;
        }
        function P(Q, E) {
          var y, L;
          return Q ? (L = new v(), (Q.state = L).window = null, (y = x(Q, E)) !== u && (Q.state = null), y) : d;
        }
        var k, A, C = !0;
        function Z(Q) {
          if (C) {
            var E;
            for (k = new s.Buf32(512), A = new s.Buf32(32), E = 0; E < 144; ) Q.lens[E++] = 8;
            for (; E < 256; ) Q.lens[E++] = 9;
            for (; E < 280; ) Q.lens[E++] = 7;
            for (; E < 288; ) Q.lens[E++] = 8;
            for (c(h, Q.lens, 0, 288, k, 0, Q.work, { bits: 9 }), E = 0; E < 32; ) Q.lens[E++] = 5;
            c(f, Q.lens, 0, 32, A, 0, Q.work, { bits: 5 }), C = !1;
          }
          Q.lencode = k, Q.lenbits = 9, Q.distcode = A, Q.distbits = 5;
        }
        function I(Q, E, y, L) {
          var se, V = Q.state;
          return V.window === null && (V.wsize = 1 << V.wbits, V.wnext = 0, V.whave = 0, V.window = new s.Buf8(V.wsize)), L >= V.wsize ? (s.arraySet(V.window, E, y - V.wsize, V.wsize, 0), V.wnext = 0, V.whave = V.wsize) : (L < (se = V.wsize - V.wnext) && (se = L), s.arraySet(V.window, E, y - L, se, V.wnext), (L -= se) ? (s.arraySet(V.window, E, y - L, L, 0), V.wnext = L, V.whave = V.wsize) : (V.wnext += se, V.wnext === V.wsize && (V.wnext = 0), V.whave < V.wsize && (V.whave += se))), 0;
        }
        r.inflateReset = w, r.inflateReset2 = x, r.inflateResetKeep = S, r.inflateInit = function(Q) {
          return P(Q, 15);
        }, r.inflateInit2 = P, r.inflate = function(Q, E) {
          var y, L, se, V, fe, W, ce, z, D, J, ie, U, Qe, Ie, be, _e, Ue, Be, $t, Je, b, N, Y, $, _ = 0, M = new s.Buf8(4), j = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!Q || !Q.state || !Q.output || !Q.input && Q.avail_in !== 0) return d;
          (y = Q.state).mode === 12 && (y.mode = 13), fe = Q.next_out, se = Q.output, ce = Q.avail_out, V = Q.next_in, L = Q.input, W = Q.avail_in, z = y.hold, D = y.bits, J = W, ie = ce, N = u;
          e: for (; ; ) switch (y.mode) {
            case p:
              if (y.wrap === 0) {
                y.mode = 13;
                break;
              }
              for (; D < 16; ) {
                if (W === 0) break e;
                W--, z += L[V++] << D, D += 8;
              }
              if (2 & y.wrap && z === 35615) {
                M[y.check = 0] = 255 & z, M[1] = z >>> 8 & 255, y.check = a(y.check, M, 2, 0), D = z = 0, y.mode = 2;
                break;
              }
              if (y.flags = 0, y.head && (y.head.done = !1), !(1 & y.wrap) || (((255 & z) << 8) + (z >> 8)) % 31) {
                Q.msg = "incorrect header check", y.mode = 30;
                break;
              }
              if ((15 & z) != 8) {
                Q.msg = "unknown compression method", y.mode = 30;
                break;
              }
              if (D -= 4, b = 8 + (15 & (z >>>= 4)), y.wbits === 0) y.wbits = b;
              else if (b > y.wbits) {
                Q.msg = "invalid window size", y.mode = 30;
                break;
              }
              y.dmax = 1 << b, Q.adler = y.check = 1, y.mode = 512 & z ? 10 : 12, D = z = 0;
              break;
            case 2:
              for (; D < 16; ) {
                if (W === 0) break e;
                W--, z += L[V++] << D, D += 8;
              }
              if (y.flags = z, (255 & y.flags) != 8) {
                Q.msg = "unknown compression method", y.mode = 30;
                break;
              }
              if (57344 & y.flags) {
                Q.msg = "unknown header flags set", y.mode = 30;
                break;
              }
              y.head && (y.head.text = z >> 8 & 1), 512 & y.flags && (M[0] = 255 & z, M[1] = z >>> 8 & 255, y.check = a(y.check, M, 2, 0)), D = z = 0, y.mode = 3;
            case 3:
              for (; D < 32; ) {
                if (W === 0) break e;
                W--, z += L[V++] << D, D += 8;
              }
              y.head && (y.head.time = z), 512 & y.flags && (M[0] = 255 & z, M[1] = z >>> 8 & 255, M[2] = z >>> 16 & 255, M[3] = z >>> 24 & 255, y.check = a(y.check, M, 4, 0)), D = z = 0, y.mode = 4;
            case 4:
              for (; D < 16; ) {
                if (W === 0) break e;
                W--, z += L[V++] << D, D += 8;
              }
              y.head && (y.head.xflags = 255 & z, y.head.os = z >> 8), 512 & y.flags && (M[0] = 255 & z, M[1] = z >>> 8 & 255, y.check = a(y.check, M, 2, 0)), D = z = 0, y.mode = 5;
            case 5:
              if (1024 & y.flags) {
                for (; D < 16; ) {
                  if (W === 0) break e;
                  W--, z += L[V++] << D, D += 8;
                }
                y.length = z, y.head && (y.head.extra_len = z), 512 & y.flags && (M[0] = 255 & z, M[1] = z >>> 8 & 255, y.check = a(y.check, M, 2, 0)), D = z = 0;
              } else y.head && (y.head.extra = null);
              y.mode = 6;
            case 6:
              if (1024 & y.flags && (W < (U = y.length) && (U = W), U && (y.head && (b = y.head.extra_len - y.length, y.head.extra || (y.head.extra = new Array(y.head.extra_len)), s.arraySet(y.head.extra, L, V, U, b)), 512 & y.flags && (y.check = a(y.check, L, U, V)), W -= U, V += U, y.length -= U), y.length)) break e;
              y.length = 0, y.mode = 7;
            case 7:
              if (2048 & y.flags) {
                if (W === 0) break e;
                for (U = 0; b = L[V + U++], y.head && b && y.length < 65536 && (y.head.name += String.fromCharCode(b)), b && U < W; ) ;
                if (512 & y.flags && (y.check = a(y.check, L, U, V)), W -= U, V += U, b) break e;
              } else y.head && (y.head.name = null);
              y.length = 0, y.mode = 8;
            case 8:
              if (4096 & y.flags) {
                if (W === 0) break e;
                for (U = 0; b = L[V + U++], y.head && b && y.length < 65536 && (y.head.comment += String.fromCharCode(b)), b && U < W; ) ;
                if (512 & y.flags && (y.check = a(y.check, L, U, V)), W -= U, V += U, b) break e;
              } else y.head && (y.head.comment = null);
              y.mode = 9;
            case 9:
              if (512 & y.flags) {
                for (; D < 16; ) {
                  if (W === 0) break e;
                  W--, z += L[V++] << D, D += 8;
                }
                if (z !== (65535 & y.check)) {
                  Q.msg = "header crc mismatch", y.mode = 30;
                  break;
                }
                D = z = 0;
              }
              y.head && (y.head.hcrc = y.flags >> 9 & 1, y.head.done = !0), Q.adler = y.check = 0, y.mode = 12;
              break;
            case 10:
              for (; D < 32; ) {
                if (W === 0) break e;
                W--, z += L[V++] << D, D += 8;
              }
              Q.adler = y.check = g(z), D = z = 0, y.mode = 11;
            case 11:
              if (y.havedict === 0) return Q.next_out = fe, Q.avail_out = ce, Q.next_in = V, Q.avail_in = W, y.hold = z, y.bits = D, 2;
              Q.adler = y.check = 1, y.mode = 12;
            case 12:
              if (E === 5 || E === 6) break e;
            case 13:
              if (y.last) {
                z >>>= 7 & D, D -= 7 & D, y.mode = 27;
                break;
              }
              for (; D < 3; ) {
                if (W === 0) break e;
                W--, z += L[V++] << D, D += 8;
              }
              switch (y.last = 1 & z, D -= 1, 3 & (z >>>= 1)) {
                case 0:
                  y.mode = 14;
                  break;
                case 1:
                  if (Z(y), y.mode = 20, E !== 6) break;
                  z >>>= 2, D -= 2;
                  break e;
                case 2:
                  y.mode = 17;
                  break;
                case 3:
                  Q.msg = "invalid block type", y.mode = 30;
              }
              z >>>= 2, D -= 2;
              break;
            case 14:
              for (z >>>= 7 & D, D -= 7 & D; D < 32; ) {
                if (W === 0) break e;
                W--, z += L[V++] << D, D += 8;
              }
              if ((65535 & z) != (z >>> 16 ^ 65535)) {
                Q.msg = "invalid stored block lengths", y.mode = 30;
                break;
              }
              if (y.length = 65535 & z, D = z = 0, y.mode = 15, E === 6) break e;
            case 15:
              y.mode = 16;
            case 16:
              if (U = y.length) {
                if (W < U && (U = W), ce < U && (U = ce), U === 0) break e;
                s.arraySet(se, L, V, U, fe), W -= U, V += U, ce -= U, fe += U, y.length -= U;
                break;
              }
              y.mode = 12;
              break;
            case 17:
              for (; D < 14; ) {
                if (W === 0) break e;
                W--, z += L[V++] << D, D += 8;
              }
              if (y.nlen = 257 + (31 & z), z >>>= 5, D -= 5, y.ndist = 1 + (31 & z), z >>>= 5, D -= 5, y.ncode = 4 + (15 & z), z >>>= 4, D -= 4, 286 < y.nlen || 30 < y.ndist) {
                Q.msg = "too many length or distance symbols", y.mode = 30;
                break;
              }
              y.have = 0, y.mode = 18;
            case 18:
              for (; y.have < y.ncode; ) {
                for (; D < 3; ) {
                  if (W === 0) break e;
                  W--, z += L[V++] << D, D += 8;
                }
                y.lens[j[y.have++]] = 7 & z, z >>>= 3, D -= 3;
              }
              for (; y.have < 19; ) y.lens[j[y.have++]] = 0;
              if (y.lencode = y.lendyn, y.lenbits = 7, Y = { bits: y.lenbits }, N = c(0, y.lens, 0, 19, y.lencode, 0, y.work, Y), y.lenbits = Y.bits, N) {
                Q.msg = "invalid code lengths set", y.mode = 30;
                break;
              }
              y.have = 0, y.mode = 19;
            case 19:
              for (; y.have < y.nlen + y.ndist; ) {
                for (; _e = (_ = y.lencode[z & (1 << y.lenbits) - 1]) >>> 16 & 255, Ue = 65535 & _, !((be = _ >>> 24) <= D); ) {
                  if (W === 0) break e;
                  W--, z += L[V++] << D, D += 8;
                }
                if (Ue < 16) z >>>= be, D -= be, y.lens[y.have++] = Ue;
                else {
                  if (Ue === 16) {
                    for ($ = be + 2; D < $; ) {
                      if (W === 0) break e;
                      W--, z += L[V++] << D, D += 8;
                    }
                    if (z >>>= be, D -= be, y.have === 0) {
                      Q.msg = "invalid bit length repeat", y.mode = 30;
                      break;
                    }
                    b = y.lens[y.have - 1], U = 3 + (3 & z), z >>>= 2, D -= 2;
                  } else if (Ue === 17) {
                    for ($ = be + 3; D < $; ) {
                      if (W === 0) break e;
                      W--, z += L[V++] << D, D += 8;
                    }
                    D -= be, b = 0, U = 3 + (7 & (z >>>= be)), z >>>= 3, D -= 3;
                  } else {
                    for ($ = be + 7; D < $; ) {
                      if (W === 0) break e;
                      W--, z += L[V++] << D, D += 8;
                    }
                    D -= be, b = 0, U = 11 + (127 & (z >>>= be)), z >>>= 7, D -= 7;
                  }
                  if (y.have + U > y.nlen + y.ndist) {
                    Q.msg = "invalid bit length repeat", y.mode = 30;
                    break;
                  }
                  for (; U--; ) y.lens[y.have++] = b;
                }
              }
              if (y.mode === 30) break;
              if (y.lens[256] === 0) {
                Q.msg = "invalid code -- missing end-of-block", y.mode = 30;
                break;
              }
              if (y.lenbits = 9, Y = { bits: y.lenbits }, N = c(h, y.lens, 0, y.nlen, y.lencode, 0, y.work, Y), y.lenbits = Y.bits, N) {
                Q.msg = "invalid literal/lengths set", y.mode = 30;
                break;
              }
              if (y.distbits = 6, y.distcode = y.distdyn, Y = { bits: y.distbits }, N = c(f, y.lens, y.nlen, y.ndist, y.distcode, 0, y.work, Y), y.distbits = Y.bits, N) {
                Q.msg = "invalid distances set", y.mode = 30;
                break;
              }
              if (y.mode = 20, E === 6) break e;
            case 20:
              y.mode = 21;
            case 21:
              if (6 <= W && 258 <= ce) {
                Q.next_out = fe, Q.avail_out = ce, Q.next_in = V, Q.avail_in = W, y.hold = z, y.bits = D, l(Q, ie), fe = Q.next_out, se = Q.output, ce = Q.avail_out, V = Q.next_in, L = Q.input, W = Q.avail_in, z = y.hold, D = y.bits, y.mode === 12 && (y.back = -1);
                break;
              }
              for (y.back = 0; _e = (_ = y.lencode[z & (1 << y.lenbits) - 1]) >>> 16 & 255, Ue = 65535 & _, !((be = _ >>> 24) <= D); ) {
                if (W === 0) break e;
                W--, z += L[V++] << D, D += 8;
              }
              if (_e && (240 & _e) == 0) {
                for (Be = be, $t = _e, Je = Ue; _e = (_ = y.lencode[Je + ((z & (1 << Be + $t) - 1) >> Be)]) >>> 16 & 255, Ue = 65535 & _, !(Be + (be = _ >>> 24) <= D); ) {
                  if (W === 0) break e;
                  W--, z += L[V++] << D, D += 8;
                }
                z >>>= Be, D -= Be, y.back += Be;
              }
              if (z >>>= be, D -= be, y.back += be, y.length = Ue, _e === 0) {
                y.mode = 26;
                break;
              }
              if (32 & _e) {
                y.back = -1, y.mode = 12;
                break;
              }
              if (64 & _e) {
                Q.msg = "invalid literal/length code", y.mode = 30;
                break;
              }
              y.extra = 15 & _e, y.mode = 22;
            case 22:
              if (y.extra) {
                for ($ = y.extra; D < $; ) {
                  if (W === 0) break e;
                  W--, z += L[V++] << D, D += 8;
                }
                y.length += z & (1 << y.extra) - 1, z >>>= y.extra, D -= y.extra, y.back += y.extra;
              }
              y.was = y.length, y.mode = 23;
            case 23:
              for (; _e = (_ = y.distcode[z & (1 << y.distbits) - 1]) >>> 16 & 255, Ue = 65535 & _, !((be = _ >>> 24) <= D); ) {
                if (W === 0) break e;
                W--, z += L[V++] << D, D += 8;
              }
              if ((240 & _e) == 0) {
                for (Be = be, $t = _e, Je = Ue; _e = (_ = y.distcode[Je + ((z & (1 << Be + $t) - 1) >> Be)]) >>> 16 & 255, Ue = 65535 & _, !(Be + (be = _ >>> 24) <= D); ) {
                  if (W === 0) break e;
                  W--, z += L[V++] << D, D += 8;
                }
                z >>>= Be, D -= Be, y.back += Be;
              }
              if (z >>>= be, D -= be, y.back += be, 64 & _e) {
                Q.msg = "invalid distance code", y.mode = 30;
                break;
              }
              y.offset = Ue, y.extra = 15 & _e, y.mode = 24;
            case 24:
              if (y.extra) {
                for ($ = y.extra; D < $; ) {
                  if (W === 0) break e;
                  W--, z += L[V++] << D, D += 8;
                }
                y.offset += z & (1 << y.extra) - 1, z >>>= y.extra, D -= y.extra, y.back += y.extra;
              }
              if (y.offset > y.dmax) {
                Q.msg = "invalid distance too far back", y.mode = 30;
                break;
              }
              y.mode = 25;
            case 25:
              if (ce === 0) break e;
              if (U = ie - ce, y.offset > U) {
                if ((U = y.offset - U) > y.whave && y.sane) {
                  Q.msg = "invalid distance too far back", y.mode = 30;
                  break;
                }
                Qe = U > y.wnext ? (U -= y.wnext, y.wsize - U) : y.wnext - U, U > y.length && (U = y.length), Ie = y.window;
              } else Ie = se, Qe = fe - y.offset, U = y.length;
              for (ce < U && (U = ce), ce -= U, y.length -= U; se[fe++] = Ie[Qe++], --U; ) ;
              y.length === 0 && (y.mode = 21);
              break;
            case 26:
              if (ce === 0) break e;
              se[fe++] = y.length, ce--, y.mode = 21;
              break;
            case 27:
              if (y.wrap) {
                for (; D < 32; ) {
                  if (W === 0) break e;
                  W--, z |= L[V++] << D, D += 8;
                }
                if (ie -= ce, Q.total_out += ie, y.total += ie, ie && (Q.adler = y.check = y.flags ? a(y.check, se, ie, fe - ie) : o(y.check, se, ie, fe - ie)), ie = ce, (y.flags ? z : g(z)) !== y.check) {
                  Q.msg = "incorrect data check", y.mode = 30;
                  break;
                }
                D = z = 0;
              }
              y.mode = 28;
            case 28:
              if (y.wrap && y.flags) {
                for (; D < 32; ) {
                  if (W === 0) break e;
                  W--, z += L[V++] << D, D += 8;
                }
                if (z !== (4294967295 & y.total)) {
                  Q.msg = "incorrect length check", y.mode = 30;
                  break;
                }
                D = z = 0;
              }
              y.mode = 29;
            case 29:
              N = 1;
              break e;
            case 30:
              N = -3;
              break e;
            case 31:
              return -4;
            case 32:
            default:
              return d;
          }
          return Q.next_out = fe, Q.avail_out = ce, Q.next_in = V, Q.avail_in = W, y.hold = z, y.bits = D, (y.wsize || ie !== Q.avail_out && y.mode < 30 && (y.mode < 27 || E !== 4)) && I(Q, Q.output, Q.next_out, ie - Q.avail_out) ? (y.mode = 31, -4) : (J -= Q.avail_in, ie -= Q.avail_out, Q.total_in += J, Q.total_out += ie, y.total += ie, y.wrap && ie && (Q.adler = y.check = y.flags ? a(y.check, se, ie, Q.next_out - ie) : o(y.check, se, ie, Q.next_out - ie)), Q.data_type = y.bits + (y.last ? 64 : 0) + (y.mode === 12 ? 128 : 0) + (y.mode === 20 || y.mode === 15 ? 256 : 0), (J == 0 && ie === 0 || E === 4) && N === u && (N = -5), N);
        }, r.inflateEnd = function(Q) {
          if (!Q || !Q.state) return d;
          var E = Q.state;
          return E.window && (E.window = null), Q.state = null, u;
        }, r.inflateGetHeader = function(Q, E) {
          var y;
          return Q && Q.state ? (2 & (y = Q.state).wrap) == 0 ? d : ((y.head = E).done = !1, u) : d;
        }, r.inflateSetDictionary = function(Q, E) {
          var y, L = E.length;
          return Q && Q.state ? (y = Q.state).wrap !== 0 && y.mode !== 11 ? d : y.mode === 11 && o(1, E, L, 0) !== y.check ? -3 : I(Q, E, L, L) ? (y.mode = 31, -4) : (y.havedict = 1, u) : d;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(t, n, r) {
        var s = t("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        n.exports = function(h, f, u, d, p, O, m, g) {
          var v, S, w, x, P, k, A, C, Z, I = g.bits, Q = 0, E = 0, y = 0, L = 0, se = 0, V = 0, fe = 0, W = 0, ce = 0, z = 0, D = null, J = 0, ie = new s.Buf16(16), U = new s.Buf16(16), Qe = null, Ie = 0;
          for (Q = 0; Q <= 15; Q++) ie[Q] = 0;
          for (E = 0; E < d; E++) ie[f[u + E]]++;
          for (se = I, L = 15; 1 <= L && ie[L] === 0; L--) ;
          if (L < se && (se = L), L === 0) return p[O++] = 20971520, p[O++] = 20971520, g.bits = 1, 0;
          for (y = 1; y < L && ie[y] === 0; y++) ;
          for (se < y && (se = y), Q = W = 1; Q <= 15; Q++) if (W <<= 1, (W -= ie[Q]) < 0) return -1;
          if (0 < W && (h === 0 || L !== 1)) return -1;
          for (U[1] = 0, Q = 1; Q < 15; Q++) U[Q + 1] = U[Q] + ie[Q];
          for (E = 0; E < d; E++) f[u + E] !== 0 && (m[U[f[u + E]]++] = E);
          if (k = h === 0 ? (D = Qe = m, 19) : h === 1 ? (D = o, J -= 257, Qe = a, Ie -= 257, 256) : (D = l, Qe = c, -1), Q = y, P = O, fe = E = z = 0, w = -1, x = (ce = 1 << (V = se)) - 1, h === 1 && 852 < ce || h === 2 && 592 < ce) return 1;
          for (; ; ) {
            for (A = Q - fe, Z = m[E] < k ? (C = 0, m[E]) : m[E] > k ? (C = Qe[Ie + m[E]], D[J + m[E]]) : (C = 96, 0), v = 1 << Q - fe, y = S = 1 << V; p[P + (z >> fe) + (S -= v)] = A << 24 | C << 16 | Z | 0, S !== 0; ) ;
            for (v = 1 << Q - 1; z & v; ) v >>= 1;
            if (v !== 0 ? (z &= v - 1, z += v) : z = 0, E++, --ie[Q] == 0) {
              if (Q === L) break;
              Q = f[u + m[E]];
            }
            if (se < Q && (z & x) !== w) {
              for (fe === 0 && (fe = se), P += y, W = 1 << (V = Q - fe); V + fe < L && !((W -= ie[V + fe]) <= 0); ) V++, W <<= 1;
              if (ce += 1 << V, h === 1 && 852 < ce || h === 2 && 592 < ce) return 1;
              p[w = z & x] = se << 24 | V << 16 | P - O | 0;
            }
          }
          return z !== 0 && (p[P + z] = Q - fe << 24 | 64 << 16 | 0), g.bits = se, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(t, n, r) {
        n.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(t, n, r) {
        var s = t("../utils/common"), o = 0, a = 1;
        function l(_) {
          for (var M = _.length; 0 <= --M; ) _[M] = 0;
        }
        var c = 0, h = 29, f = 256, u = f + 1 + h, d = 30, p = 19, O = 2 * u + 1, m = 15, g = 16, v = 7, S = 256, w = 16, x = 17, P = 18, k = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], A = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], C = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], Z = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], I = new Array(2 * (u + 2));
        l(I);
        var Q = new Array(2 * d);
        l(Q);
        var E = new Array(512);
        l(E);
        var y = new Array(256);
        l(y);
        var L = new Array(h);
        l(L);
        var se, V, fe, W = new Array(d);
        function ce(_, M, j, B, X) {
          this.static_tree = _, this.extra_bits = M, this.extra_base = j, this.elems = B, this.max_length = X, this.has_stree = _ && _.length;
        }
        function z(_, M) {
          this.dyn_tree = _, this.max_code = 0, this.stat_desc = M;
        }
        function D(_) {
          return _ < 256 ? E[_] : E[256 + (_ >>> 7)];
        }
        function J(_, M) {
          _.pending_buf[_.pending++] = 255 & M, _.pending_buf[_.pending++] = M >>> 8 & 255;
        }
        function ie(_, M, j) {
          _.bi_valid > g - j ? (_.bi_buf |= M << _.bi_valid & 65535, J(_, _.bi_buf), _.bi_buf = M >> g - _.bi_valid, _.bi_valid += j - g) : (_.bi_buf |= M << _.bi_valid & 65535, _.bi_valid += j);
        }
        function U(_, M, j) {
          ie(_, j[2 * M], j[2 * M + 1]);
        }
        function Qe(_, M) {
          for (var j = 0; j |= 1 & _, _ >>>= 1, j <<= 1, 0 < --M; ) ;
          return j >>> 1;
        }
        function Ie(_, M, j) {
          var B, X, G = new Array(m + 1), ee = 0;
          for (B = 1; B <= m; B++) G[B] = ee = ee + j[B - 1] << 1;
          for (X = 0; X <= M; X++) {
            var F = _[2 * X + 1];
            F !== 0 && (_[2 * X] = Qe(G[F]++, F));
          }
        }
        function be(_) {
          var M;
          for (M = 0; M < u; M++) _.dyn_ltree[2 * M] = 0;
          for (M = 0; M < d; M++) _.dyn_dtree[2 * M] = 0;
          for (M = 0; M < p; M++) _.bl_tree[2 * M] = 0;
          _.dyn_ltree[2 * S] = 1, _.opt_len = _.static_len = 0, _.last_lit = _.matches = 0;
        }
        function _e(_) {
          8 < _.bi_valid ? J(_, _.bi_buf) : 0 < _.bi_valid && (_.pending_buf[_.pending++] = _.bi_buf), _.bi_buf = 0, _.bi_valid = 0;
        }
        function Ue(_, M, j, B) {
          var X = 2 * M, G = 2 * j;
          return _[X] < _[G] || _[X] === _[G] && B[M] <= B[j];
        }
        function Be(_, M, j) {
          for (var B = _.heap[j], X = j << 1; X <= _.heap_len && (X < _.heap_len && Ue(M, _.heap[X + 1], _.heap[X], _.depth) && X++, !Ue(M, B, _.heap[X], _.depth)); ) _.heap[j] = _.heap[X], j = X, X <<= 1;
          _.heap[j] = B;
        }
        function $t(_, M, j) {
          var B, X, G, ee, F = 0;
          if (_.last_lit !== 0) for (; B = _.pending_buf[_.d_buf + 2 * F] << 8 | _.pending_buf[_.d_buf + 2 * F + 1], X = _.pending_buf[_.l_buf + F], F++, B === 0 ? U(_, X, M) : (U(_, (G = y[X]) + f + 1, M), (ee = k[G]) !== 0 && ie(_, X -= L[G], ee), U(_, G = D(--B), j), (ee = A[G]) !== 0 && ie(_, B -= W[G], ee)), F < _.last_lit; ) ;
          U(_, S, M);
        }
        function Je(_, M) {
          var j, B, X, G = M.dyn_tree, ee = M.stat_desc.static_tree, F = M.stat_desc.has_stree, oe = M.stat_desc.elems, me = -1;
          for (_.heap_len = 0, _.heap_max = O, j = 0; j < oe; j++) G[2 * j] !== 0 ? (_.heap[++_.heap_len] = me = j, _.depth[j] = 0) : G[2 * j + 1] = 0;
          for (; _.heap_len < 2; ) G[2 * (X = _.heap[++_.heap_len] = me < 2 ? ++me : 0)] = 1, _.depth[X] = 0, _.opt_len--, F && (_.static_len -= ee[2 * X + 1]);
          for (M.max_code = me, j = _.heap_len >> 1; 1 <= j; j--) Be(_, G, j);
          for (X = oe; j = _.heap[1], _.heap[1] = _.heap[_.heap_len--], Be(_, G, 1), B = _.heap[1], _.heap[--_.heap_max] = j, _.heap[--_.heap_max] = B, G[2 * X] = G[2 * j] + G[2 * B], _.depth[X] = (_.depth[j] >= _.depth[B] ? _.depth[j] : _.depth[B]) + 1, G[2 * j + 1] = G[2 * B + 1] = X, _.heap[1] = X++, Be(_, G, 1), 2 <= _.heap_len; ) ;
          _.heap[--_.heap_max] = _.heap[1], (function(Oe, Me) {
            var Lt, at, Ti, Xe, on, Ut, yt = Me.dyn_tree, xr = Me.max_code, Qs = Me.stat_desc.static_tree, Wl = Me.stat_desc.has_stree, kr = Me.stat_desc.extra_bits, Fn = Me.stat_desc.extra_base, Hn = Me.stat_desc.max_length, Ci = 0;
            for (Xe = 0; Xe <= m; Xe++) Oe.bl_count[Xe] = 0;
            for (yt[2 * Oe.heap[Oe.heap_max] + 1] = 0, Lt = Oe.heap_max + 1; Lt < O; Lt++) Hn < (Xe = yt[2 * yt[2 * (at = Oe.heap[Lt]) + 1] + 1] + 1) && (Xe = Hn, Ci++), yt[2 * at + 1] = Xe, xr < at || (Oe.bl_count[Xe]++, on = 0, Fn <= at && (on = kr[at - Fn]), Ut = yt[2 * at], Oe.opt_len += Ut * (Xe + on), Wl && (Oe.static_len += Ut * (Qs[2 * at + 1] + on)));
            if (Ci !== 0) {
              do {
                for (Xe = Hn - 1; Oe.bl_count[Xe] === 0; ) Xe--;
                Oe.bl_count[Xe]--, Oe.bl_count[Xe + 1] += 2, Oe.bl_count[Hn]--, Ci -= 2;
              } while (0 < Ci);
              for (Xe = Hn; Xe !== 0; Xe--) for (at = Oe.bl_count[Xe]; at !== 0; ) xr < (Ti = Oe.heap[--Lt]) || (yt[2 * Ti + 1] !== Xe && (Oe.opt_len += (Xe - yt[2 * Ti + 1]) * yt[2 * Ti], yt[2 * Ti + 1] = Xe), at--);
            }
          })(_, M), Ie(G, me, _.bl_count);
        }
        function b(_, M, j) {
          var B, X, G = -1, ee = M[1], F = 0, oe = 7, me = 4;
          for (ee === 0 && (oe = 138, me = 3), M[2 * (j + 1) + 1] = 65535, B = 0; B <= j; B++) X = ee, ee = M[2 * (B + 1) + 1], ++F < oe && X === ee || (F < me ? _.bl_tree[2 * X] += F : X !== 0 ? (X !== G && _.bl_tree[2 * X]++, _.bl_tree[2 * w]++) : F <= 10 ? _.bl_tree[2 * x]++ : _.bl_tree[2 * P]++, G = X, me = (F = 0) === ee ? (oe = 138, 3) : X === ee ? (oe = 6, 3) : (oe = 7, 4));
        }
        function N(_, M, j) {
          var B, X, G = -1, ee = M[1], F = 0, oe = 7, me = 4;
          for (ee === 0 && (oe = 138, me = 3), B = 0; B <= j; B++) if (X = ee, ee = M[2 * (B + 1) + 1], !(++F < oe && X === ee)) {
            if (F < me) for (; U(_, X, _.bl_tree), --F != 0; ) ;
            else X !== 0 ? (X !== G && (U(_, X, _.bl_tree), F--), U(_, w, _.bl_tree), ie(_, F - 3, 2)) : F <= 10 ? (U(_, x, _.bl_tree), ie(_, F - 3, 3)) : (U(_, P, _.bl_tree), ie(_, F - 11, 7));
            G = X, me = (F = 0) === ee ? (oe = 138, 3) : X === ee ? (oe = 6, 3) : (oe = 7, 4);
          }
        }
        l(W);
        var Y = !1;
        function $(_, M, j, B) {
          ie(_, (c << 1) + (B ? 1 : 0), 3), (function(X, G, ee, F) {
            _e(X), J(X, ee), J(X, ~ee), s.arraySet(X.pending_buf, X.window, G, ee, X.pending), X.pending += ee;
          })(_, M, j);
        }
        r._tr_init = function(_) {
          Y || ((function() {
            var M, j, B, X, G, ee = new Array(m + 1);
            for (X = B = 0; X < h - 1; X++) for (L[X] = B, M = 0; M < 1 << k[X]; M++) y[B++] = X;
            for (y[B - 1] = X, X = G = 0; X < 16; X++) for (W[X] = G, M = 0; M < 1 << A[X]; M++) E[G++] = X;
            for (G >>= 7; X < d; X++) for (W[X] = G << 7, M = 0; M < 1 << A[X] - 7; M++) E[256 + G++] = X;
            for (j = 0; j <= m; j++) ee[j] = 0;
            for (M = 0; M <= 143; ) I[2 * M + 1] = 8, M++, ee[8]++;
            for (; M <= 255; ) I[2 * M + 1] = 9, M++, ee[9]++;
            for (; M <= 279; ) I[2 * M + 1] = 7, M++, ee[7]++;
            for (; M <= 287; ) I[2 * M + 1] = 8, M++, ee[8]++;
            for (Ie(I, u + 1, ee), M = 0; M < d; M++) Q[2 * M + 1] = 5, Q[2 * M] = Qe(M, 5);
            se = new ce(I, k, f + 1, u, m), V = new ce(Q, A, 0, d, m), fe = new ce(new Array(0), C, 0, p, v);
          })(), Y = !0), _.l_desc = new z(_.dyn_ltree, se), _.d_desc = new z(_.dyn_dtree, V), _.bl_desc = new z(_.bl_tree, fe), _.bi_buf = 0, _.bi_valid = 0, be(_);
        }, r._tr_stored_block = $, r._tr_flush_block = function(_, M, j, B) {
          var X, G, ee = 0;
          0 < _.level ? (_.strm.data_type === 2 && (_.strm.data_type = (function(F) {
            var oe, me = 4093624447;
            for (oe = 0; oe <= 31; oe++, me >>>= 1) if (1 & me && F.dyn_ltree[2 * oe] !== 0) return o;
            if (F.dyn_ltree[18] !== 0 || F.dyn_ltree[20] !== 0 || F.dyn_ltree[26] !== 0) return a;
            for (oe = 32; oe < f; oe++) if (F.dyn_ltree[2 * oe] !== 0) return a;
            return o;
          })(_)), Je(_, _.l_desc), Je(_, _.d_desc), ee = (function(F) {
            var oe;
            for (b(F, F.dyn_ltree, F.l_desc.max_code), b(F, F.dyn_dtree, F.d_desc.max_code), Je(F, F.bl_desc), oe = p - 1; 3 <= oe && F.bl_tree[2 * Z[oe] + 1] === 0; oe--) ;
            return F.opt_len += 3 * (oe + 1) + 5 + 5 + 4, oe;
          })(_), X = _.opt_len + 3 + 7 >>> 3, (G = _.static_len + 3 + 7 >>> 3) <= X && (X = G)) : X = G = j + 5, j + 4 <= X && M !== -1 ? $(_, M, j, B) : _.strategy === 4 || G === X ? (ie(_, 2 + (B ? 1 : 0), 3), $t(_, I, Q)) : (ie(_, 4 + (B ? 1 : 0), 3), (function(F, oe, me, Oe) {
            var Me;
            for (ie(F, oe - 257, 5), ie(F, me - 1, 5), ie(F, Oe - 4, 4), Me = 0; Me < Oe; Me++) ie(F, F.bl_tree[2 * Z[Me] + 1], 3);
            N(F, F.dyn_ltree, oe - 1), N(F, F.dyn_dtree, me - 1);
          })(_, _.l_desc.max_code + 1, _.d_desc.max_code + 1, ee + 1), $t(_, _.dyn_ltree, _.dyn_dtree)), be(_), B && _e(_);
        }, r._tr_tally = function(_, M, j) {
          return _.pending_buf[_.d_buf + 2 * _.last_lit] = M >>> 8 & 255, _.pending_buf[_.d_buf + 2 * _.last_lit + 1] = 255 & M, _.pending_buf[_.l_buf + _.last_lit] = 255 & j, _.last_lit++, M === 0 ? _.dyn_ltree[2 * j]++ : (_.matches++, M--, _.dyn_ltree[2 * (y[j] + f + 1)]++, _.dyn_dtree[2 * D(M)]++), _.last_lit === _.lit_bufsize - 1;
        }, r._tr_align = function(_) {
          ie(_, 2, 3), U(_, S, I), (function(M) {
            M.bi_valid === 16 ? (J(M, M.bi_buf), M.bi_buf = 0, M.bi_valid = 0) : 8 <= M.bi_valid && (M.pending_buf[M.pending++] = 255 & M.bi_buf, M.bi_buf >>= 8, M.bi_valid -= 8);
          })(_);
        };
      }, { "../utils/common": 41 }], 53: [function(t, n, r) {
        n.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(t, n, r) {
        (function(s) {
          (function(o, a) {
            if (!o.setImmediate) {
              var l, c, h, f, u = 1, d = {}, p = !1, O = o.document, m = Object.getPrototypeOf && Object.getPrototypeOf(o);
              m = m && m.setTimeout ? m : o, l = {}.toString.call(o.process) === "[object process]" ? function(w) {
                process.nextTick(function() {
                  v(w);
                });
              } : (function() {
                if (o.postMessage && !o.importScripts) {
                  var w = !0, x = o.onmessage;
                  return o.onmessage = function() {
                    w = !1;
                  }, o.postMessage("", "*"), o.onmessage = x, w;
                }
              })() ? (f = "setImmediate$" + Math.random() + "$", o.addEventListener ? o.addEventListener("message", S, !1) : o.attachEvent("onmessage", S), function(w) {
                o.postMessage(f + w, "*");
              }) : o.MessageChannel ? ((h = new MessageChannel()).port1.onmessage = function(w) {
                v(w.data);
              }, function(w) {
                h.port2.postMessage(w);
              }) : O && "onreadystatechange" in O.createElement("script") ? (c = O.documentElement, function(w) {
                var x = O.createElement("script");
                x.onreadystatechange = function() {
                  v(w), x.onreadystatechange = null, c.removeChild(x), x = null;
                }, c.appendChild(x);
              }) : function(w) {
                setTimeout(v, 0, w);
              }, m.setImmediate = function(w) {
                typeof w != "function" && (w = new Function("" + w));
                for (var x = new Array(arguments.length - 1), P = 0; P < x.length; P++) x[P] = arguments[P + 1];
                var k = { callback: w, args: x };
                return d[u] = k, l(u), u++;
              }, m.clearImmediate = g;
            }
            function g(w) {
              delete d[w];
            }
            function v(w) {
              if (p) setTimeout(v, 0, w);
              else {
                var x = d[w];
                if (x) {
                  p = !0;
                  try {
                    (function(P) {
                      var k = P.callback, A = P.args;
                      switch (A.length) {
                        case 0:
                          k();
                          break;
                        case 1:
                          k(A[0]);
                          break;
                        case 2:
                          k(A[0], A[1]);
                          break;
                        case 3:
                          k(A[0], A[1], A[2]);
                          break;
                        default:
                          k.apply(a, A);
                      }
                    })(x);
                  } finally {
                    g(w), p = !1;
                  }
                }
              }
            }
            function S(w) {
              w.source === o && typeof w.data == "string" && w.data.indexOf(f) === 0 && v(+w.data.slice(f.length));
            }
          })(typeof self > "u" ? s === void 0 ? this : s : self);
        }).call(this, typeof ma < "u" ? ma : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}] }, {}, [10])(10);
    });
  })(ih)), ih.exports;
}
var jA = WA();
const UA = /* @__PURE__ */ qA(jA);
var GA = /* @__PURE__ */ ri('<div class="article-info-edit-pane"><!> <!> <!> <div class="below-text"><!> <p>DNN Article Editor.</p> <p class="secondary">Very early release. More features coming soon!</p> <br/> <p class="secondary"></p></div></div>'), FA = /* @__PURE__ */ ri('<div class="export-popup"><div class="top"><p> </p> <div class="export-options"><button>Copy HTML</button> <button>Download</button></div></div> <!> <button class="close-button">Close</button></div> <div class="export-bg"></div>', 1), HA = /* @__PURE__ */ ri('<main><div class="editor-container"><p class="save-text"> </p> <div class="editor-pane pane"><div class="header"><div class="left"><p class="header-title">HTML Editor</p> <a href="/articles/what-is-html" class="what-is-html" target="_blank">What is HTML?</a></div> <div class="right"><label for="image-upload" class="input-button">Add Image</label> <input id="image-upload" type="file" title="Image" accept="image/*"/> <button> </button></div></div> <!> <!></div> <div class="preview-pane pane"><div class="header"><div class="left"><p class="header-title">Preview</p></div> <div class="right"><button>Export</button></div></div> <article class="preview"><!> <!></article></div></div> <!></main>');
function KA(i, e) {
  us(e, !0);
  const t = new kS();
  async function n(B) {
    const X = WS.sanitize(B, {
      FORBID_TAGS: [
        "script",
        "style",
        "iframe",
        "object",
        "embed",
        "form",
        "input"
      ],
      FORBID_ATTR: ["class", "style"],
      USE_PROFILES: { html: !0 }
      // ALLOWED_URI_REGEXP: /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|blob):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
    }), G = document.createElement("div");
    G.innerHTML = X;
    const ee = G.querySelectorAll("img[src]");
    return await Promise.all(Array.from(ee).map(async (F) => {
      const oe = F.getAttribute("src");
      if (oe) {
        const me = await t.get(oe);
        if (me !== void 0)
          return F.setAttribute("src", me), new Promise((Oe) => {
            const Me = new Image();
            Me.onload = Oe, Me.onerror = Oe, Me.src = me;
          });
      }
    })), G.innerHTML;
  }
  let r = localStorage.getItem("article-editor-saved-article"), s;
  r && (s = JSON.parse(r));
  let o = !0, a = s?.info, l = /* @__PURE__ */ qe(li(a?.title ?? "My Article")), c = /* @__PURE__ */ qe(li(a?.author ?? "Me")), h = /* @__PURE__ */ qe(li(a?.tags ?? [{ name: "SHOCKING", color: "red" }]));
  lr(() => {
    if (te(l), te(c), JSON.stringify(te(h)), o) {
      o = !1;
      return;
    } else
      Pe(g, "Saving...");
    se();
  });
  const f = /* @__PURE__ */ new Date();
  function u(B) {
    if (B > 3 && B < 21) return "th";
    switch (B % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  }
  const d = f.getFullYear(), p = f.toLocaleString("default", { month: "long" }), O = f.getDate().toString() + u(f.getDate());
  let m = `${p} ${O}, ${d}`, g = /* @__PURE__ */ qe("");
  const v = 100, S = s?.content ?? "<p>Hello DNN!</p>";
  let w = /* @__PURE__ */ qe(void 0), x = /* @__PURE__ */ qe(li(S)), P, k;
  function A(B) {
    k || (k = setTimeout(
      () => {
        Pe(x, B.detail.view.state.doc.toString(), !0), se(), k = void 0;
      },
      v
    ));
  }
  let C = /* @__PURE__ */ qe("");
  lr(() => {
    n(te(x)).then((B) => {
      Pe(C, B, !0);
    });
  });
  let Z = /* @__PURE__ */ qe(!1), I = /* @__PURE__ */ qe(!1), Q = /* @__PURE__ */ qe(void 0);
  lr(() => {
    if (!te(Q) || !te(w)) return;
    let B = te(Q)[0];
    t.createKey(B).then((G) => {
      t.add(G, B).then(() => {
        const ee = `
<img src="${G}" alt="${B.name}">`, F = te(w).state.selection.main.from, me = te(w).state.doc.lineAt(F).to, Oe = ee + `
`;
        te(w).dispatch({ changes: { from: me, insert: Oe } }), Pe(x, te(w).state.doc.toString(), !0);
      });
    }), Pe(Q, void 0);
    const X = document.getElementById("image-upload");
    X && (X.value = "");
  });
  function E() {
    const B = `---
title: "${te(l)}"
title_short: "${te(l)}"
layout: "article"
author: "${te(c)}"
article_tags:
${te(h).map((G) => `  - ["${G.name}", "${G.color}"]`).join(`
`)}
cover_image: "PUT_YOUR_COVER_HERE.png"
---
`, X = te(x).replace(/<img([^>]*?)src="([^"]+)"/g, (G, ee, F) => !F.startsWith("http://") && !F.startsWith("https://") && !F.startsWith("/") ? `<img${ee}src="/images/${F}"` : G);
    return B + X;
  }
  async function y() {
    const B = new UA(), X = (te(l) || "Unnamed Article").replace(/[/\\:*?"<>|]/g, "-").trim();
    B.file(`${X}.html`, E());
    const G = B.folder("images");
    if (G) {
      const me = /<img\s+[^>]*src="([^"]+)"/g, Oe = /* @__PURE__ */ new Set();
      let Me;
      for (; (Me = me.exec(te(x))) !== null; )
        Oe.add(Me[1]);
      for (const Lt of Oe) {
        const at = await t.getBlob(Lt);
        at && G.file(Lt, at);
      }
    }
    const ee = await B.generateAsync({ type: "blob" }), F = URL.createObjectURL(ee), oe = document.createElement("a");
    oe.href = F, oe.download = `${X}.zip`, document.body.appendChild(oe), oe.click(), document.body.removeChild(oe), URL.revokeObjectURL(F);
  }
  function L(B) {
    navigator.clipboard.writeText(B);
  }
  function se() {
    let B = {
      info: {
        author: te(c),
        title: te(l),
        tags: te(h)
      },
      content: te(x)
    };
    localStorage.setItem("article-editor-saved-article", JSON.stringify(B)), Pe(g, `${te(l)} is being auto-saved.`);
  }
  var V = HA(), fe = Ee(V), W = Ee(fe), ce = Ee(W), z = Ze(W, 2), D = Ee(z), J = Ee(D), ie = Ze(Ee(J), 2);
  Ia(ie, "", {}, { "font-size": "0.8rem" });
  var U = Ze(J, 2), Qe = Ze(Ee(U), 2);
  Ia(Qe, "", {}, { display: "none" });
  var Ie = Ze(Qe, 2);
  Ie.__click = () => {
    Pe(Z, !te(Z));
  };
  var be = Ee(Ie), _e = Ze(D, 2);
  {
    let B = /* @__PURE__ */ Fl(() => [
      HP,
      qO,
      zO(),
      gs.of([{ key: "Tab", run: h_ }])
    ]);
    LO(_e, {
      get hidden() {
        return te(Z);
      },
      get doc() {
        return te(x);
      },
      get extensions() {
        return te(B);
      },
      get view() {
        return te(w);
      },
      set view(X) {
        Pe(w, X, !0);
      },
      $$events: { change: A }
    });
  }
  var Ue = Ze(_e, 2);
  {
    var Be = (B) => {
      var X = GA(), G = Ee(X);
      th(G, {
        name: "Title",
        get value() {
          return te(l);
        },
        set value(Me) {
          Pe(l, Me, !0);
        }
      });
      var ee = Ze(G, 2);
      th(ee, {
        name: "Tags",
        type: "tags",
        get value() {
          return te(h);
        },
        set value(Me) {
          Pe(h, Me, !0);
        }
      });
      var F = Ze(ee, 2);
      th(F, {
        name: "Author",
        spellcheck: !1,
        get value() {
          return te(c);
        },
        set value(Me) {
          Pe(c, Me, !0);
        }
      });
      var oe = Ze(F, 2), me = Ee(oe);
      wS(me, {});
      var Oe = Ze(me, 8);
      Oe.textContent = "Version BETA.0.1", qt(B, X);
    };
    La(Ue, (B) => {
      te(Z) && B(Be);
    });
  }
  var $t = Ze(z, 2), Je = Ee($t), b = Ze(Ee(Je), 2), N = Ee(b);
  N.__click = () => Pe(I, !0);
  var Y = Ze(Je, 2), $ = Ee(Y);
  GS($, {
    get title() {
      return te(l);
    },
    get tags() {
      return te(h);
    },
    get author() {
      return te(c);
    },
    get date() {
      return m;
    }
  });
  var _ = Ze($, 2);
  Gv(_, () => te(C)), Pl(Y, (B) => P = B, () => P);
  var M = Ze(fe, 2);
  {
    var j = (B) => {
      var X = FA(), G = Pm(X), ee = Ee(G), F = Ee(ee), oe = Ee(F), me = Ze(F, 2), Oe = Ee(me);
      Oe.__click = () => L(E());
      var Me = Ze(Oe, 2);
      Me.__click = () => {
        (te(l) || "Unnamed Article").replace(/[/\\:*?"<>|]/g, "-").trim(), y();
      };
      var Lt = Ze(ee, 2);
      {
        let Ti = /* @__PURE__ */ Fl(E), Xe = /* @__PURE__ */ Fl(() => [yb, zO(), qO, $e.readOnly.of(!0)]);
        LO(Lt, {
          get doc() {
            return te(Ti);
          },
          get extensions() {
            return te(Xe);
          }
        });
      }
      var at = Ze(Lt, 2);
      at.__click = () => Pe(I, !1), xi(() => mn(oe, `Exported "${(te(l) === "" ? "Unnamed Article" : te(l)) ?? ""}"`)), qt(B, X);
    };
    La(M, (B) => {
      te(I) && B(j);
    });
  }
  xi(() => {
    mn(ce, te(g)), mn(be, te(Z) ? "Edit Article" : "Edit Article Info");
  }), aS(Qe, () => te(Q), (B) => Pe(Q, B)), qt(i, V), ds();
}
Rf(["click"]);
const n3 = Vv(KA, {
  target: document.body
});
export {
  n3 as default
};
